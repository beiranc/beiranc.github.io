<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="复习,">










<meta name="description" content="对象导论 访问控制的第一个存在原因就是让客户端程序员无法接触到他们不该接触的部分，这些部分对数据类型的内部操作来说是必须的，但并不是用户解决特定问题所需的接口的一部分。  访问控制的第二个存在原因就是允许库设计者可以改变内部的工作方式而不用担心会影响到客户端程序员。  因为是在使用现有的类合成新的类，所以这种概念被称为“组合”，如果组合是动态发生的，那么它通常被称为“聚合”。组合通常被视为“拥有(">
<meta name="keywords" content="复习">
<meta property="og:type" content="article">
<meta property="og:title" content="Thinking in Java 笔记">
<meta property="og:url" content="http://yoursite.com/2019/07/28/Thinking-in-Java-笔记/index.html">
<meta property="og:site_name" content="北然">
<meta property="og:description" content="对象导论 访问控制的第一个存在原因就是让客户端程序员无法接触到他们不该接触的部分，这些部分对数据类型的内部操作来说是必须的，但并不是用户解决特定问题所需的接口的一部分。  访问控制的第二个存在原因就是允许库设计者可以改变内部的工作方式而不用担心会影响到客户端程序员。  因为是在使用现有的类合成新的类，所以这种概念被称为“组合”，如果组合是动态发生的，那么它通常被称为“聚合”。组合通常被视为“拥有(">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-07-28T15:33:44.389Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Thinking in Java 笔记">
<meta name="twitter:description" content="对象导论 访问控制的第一个存在原因就是让客户端程序员无法接触到他们不该接触的部分，这些部分对数据类型的内部操作来说是必须的，但并不是用户解决特定问题所需的接口的一部分。  访问控制的第二个存在原因就是允许库设计者可以改变内部的工作方式而不用担心会影响到客户端程序员。  因为是在使用现有的类合成新的类，所以这种概念被称为“组合”，如果组合是动态发生的，那么它通常被称为“聚合”。组合通常被视为“拥有(">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/07/28/Thinking-in-Java-笔记/">





  <title>Thinking in Java 笔记 | 北然</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">北然</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">insomniac</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>
            
            日程表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/28/Thinking-in-Java-笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="beiranc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="北然">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Thinking in Java 笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-28T23:16:47+08:00">
                2019-07-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="对象导论"><a href="#对象导论" class="headerlink" title="对象导论"></a>对象导论</h4><ol>
<li><p>访问控制的第一个存在原因就是让客户端程序员无法接触到他们不该接触的部分，这些部分对数据类型的内部操作来说是必须的，但并不是用户解决特定问题所需的接口的一部分。</p>
</li>
<li><p>访问控制的第二个存在原因就是允许库设计者可以改变内部的工作方式而不用担心会影响到客户端程序员。</p>
</li>
<li><p>因为是在使用现有的类合成新的类，所以这种概念被称为“<em>组合</em>”，如果组合是动态发生的，那么它通常被称为“<em>聚合</em>”。组合通常被视为“拥有( has a )”关系。</p>
</li>
<li><p>继承：青出于蓝而胜于蓝</p>
</li>
<li><p>两种方法使子类与父类具有差异性：①新增父类没有的方法(需要考虑是否父类也有需要这些新增的方法的可能性) ②覆盖父类中已有的方法</p>
</li>
<li><p>纯粹替代(替代原则)</p>
</li>
<li><p>前期绑定、后期绑定</p>
<ul>
<li>前期绑定：在程序执行前根据编译时类型绑定。</li>
<li>后期绑定：当向对象发送消息时，被调用的代码直到运行时才能确定，编译器确保被调用方法的存在，并对调用参数和返回值执行类型检查(无法提供此类保证的语言被称为是弱类型的)，但是并不知道将被执行的确切代码。</li>
</ul>
</li>
<li><p>把将子类看作是他的父类的过程称为“向上转型”。</p>
</li>
<li><p>并发需要考虑共享资源的问题。</p>
</li>
<li><p>事务处理：保证一个客户插入的新数据不会覆盖另一个客户插入的新数据，也不会在将其添加到数据库的过程中丢失。</p>
</li>
</ol>
<hr>
<h4 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h4><ol>
<li><p>“==“ 和 ”!=“ 比较的是对象的引用。equals() 的默认行为也是比较引用。</p>
</li>
<li><p>窄化转换(高精度转换为低精度，例如 long 转为 int )与扩展转换(低精度转换为高精度，例如 int 转换为 long )。</p>
</li>
<li><p>在进行窄化转换时，JAVA 默认是不会进行四舍五入操作的，也就是说是直接舍弃掉小数部分只保留整数部分。如果需要四舍五入，则要使用 Math.round() 方法对数字进行操作。</p>
</li>
<li><p>低位数值(如 int )在与高位数值(如 long )进行运算时，结果会按高位来进行输入(输入 long 类型的结果)。</p>
</li>
<li><p>在进行运算时要注意溢出。</p>
</li>
</ol>
<hr>
<h4 id="初始化和清理"><a href="#初始化和清理" class="headerlink" title="初始化和清理"></a>初始化和清理</h4><ol>
<li><p>只能在构造器中使用 this 来调用其他构造器，并且这个调用在一个构造器中只能调用一次，并且这个调用一定是在起始处，并且禁止在非构造方法中使用 this 调用构造器。</p>
</li>
<li><p>引用计数模式、停止-复制模式、标记-清扫模式。自适应清理</p>
</li>
<li><p>在类的内部，变量定义的先后顺序决定了初始化的顺序，即时变量定义分散在方法定义之间，它们仍旧会在任何方法(包括构造器)被调用之前初始化。</p>
</li>
<li><p>可变参数(Object… args)本质上是一个数组，如若传0个参数给可变参数列表，这是可行的。在 JDK1.5 之前没有可变参数特性时，会使用(Object[] args)这样的形式来实现可变参数。</p>
</li>
<li><p>可变参数列表使得重载过程变得复杂了，可以通过增加一个非可变参数来解决这个问题。</p>
</li>
</ol>
<hr>
<h4 id="访问权限控制"><a href="#访问权限控制" class="headerlink" title="访问权限控制"></a>访问权限控制</h4><ol>
<li><p>package 关键字和 import 关键字允许做的是将单一的全局名字空间分割开，使得无论多少人使用，都不会出现名称冲突的问题。</p>
</li>
<li><p>访问权限的控制通常被称为是具体实现的隐藏。把数据和方法包装进类当中，以及具体实现的隐藏，共同被称为封装。其结果是一个同时带有特征和行为的数据类型。</p>
</li>
</ol>
<hr>
<h4 id="复用类"><a href="#复用类" class="headerlink" title="复用类"></a>复用类</h4><ol>
<li>初始化引用有四种方法：</li>
</ol>
<ul>
<li>在定义对象的地方，这意味着它们总是能够在构造器被调用之前被初始化（也就是定义了就直接初始化）</li>
<li>在类的构造器中（也就是在构造方法中对本类所拥有的属性或其他的进行初始化）</li>
<li>在正要使用对象之前，这种方法被称为惰性初始化（即延迟初始化 Delayed initialization ），在生成对象不值得及不必每次都生成对象的情况下，这种方式可以减少额外的负担</li>
<li>使用实例初始化（new 一个对象）</li>
</ul>
<hr>
<ol start="2">
<li>当创建了一个子类的对象时，该对象包含了一个父类的子对象，这个对象与用父类直接创建的对象是一样的。所以在子类的构造方法中第一件应该做的事就是调用父类的构造方法（即 <code>super.constructor();</code> ）</li>
</ol>
<hr>
<ol start="3">
<li>复用类的三种方法：组合、继承、代理。</li>
</ol>
<ul>
<li>代理：在类中放置一个成员对象，并暴露该成员对象的所有方法（调用）</li>
</ul>
<hr>
<ol start="4">
<li>到底是使用组合还是继承，一个最清晰的办法是问一问自己是否需要从新类想基类进行向上转型；如果需要向上转型，那么继承是必要的；如果不需要，则应当好好考虑是否需要继承。</li>
</ol>
<hr>
<ol start="5">
<li>一个既是 static 又是 final 的域只占据一段不能改变的存储空间。</li>
</ol>
<hr>
<ol start="6">
<li>给引用添加 final 时，意味着这个引用无法再指向另一个新的对象，但是已经指向的对象内部的成员变量是允许修改的。</li>
</ol>
<hr>
<ol start="7">
<li>空白 final ：声明为 final 但是又未给定初值的域。（如 <code>public final String s;</code>）空白 final 必须在使用之前被初始化（意味着必须在构造器中初始化）</li>
</ol>
<hr>
<ol start="8">
<li>final 参数：在参数列表中以声明方式将参数指明为 final ，这一特性主要用来向匿名内部类传递数据</li>
</ol>
<hr>
<ol start="9">
<li>final 类中的所有方法都隐式指定为 final 的，因为无法覆盖他们。所以在 final 类中可以给方法添加 final 修饰词，但是这样没意义。</li>
</ol>
<hr>
<ol start="10">
<li>构造器也是 static 方法，尽管 static 关键字并没有显式的写出来，因此更准确地讲，类是在其任何 static 成员被访问时加载的。</li>
</ol>
<hr>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><ol>
<li>将一个方法同一个方法主体关联起来称为 “绑定” 。</li>
</ol>
<ul>
<li>若在程序执行前进行绑定（如果有的话，由编译器和连接程序实现），叫做<strong>前期绑定</strong></li>
<li>在运行时根据对象类型进行绑定叫做<strong>后期绑定</strong>，也叫做<strong>动态绑定</strong>或<strong>运行时绑定</strong></li>
<li>Java 中除了 static 方法和 final 方法（ private 方法属于 final 方法）之外，其他所有方法都是后期绑定</li>
</ul>
<hr>
<ol start="2">
<li>我们所做的修改，不会对程序中其他不应受到影响的部分造成破坏。</li>
</ol>
<hr>
<ol start="3">
<li><p>★注意：调用构造器的顺序：</p>
</li>
<li><p>在其他任何事物发生之前，将分配给对象的存储空间初始化成二进制的<strong>零</strong></p>
</li>
<li><p>调用基类构造器。这个步骤会不断地反复递归下去，首先是构造这种层次结构的根，然后是下一层导入类，依此类推，直到最低层的导出类</p>
</li>
<li><p>按声明顺序调用成员变量的初始化方法</p>
</li>
<li><p>调用导出类构造器的主体</p>
</li>
</ol>
<hr>
<ol start="4">
<li>销毁对象的顺序应与声明对象的顺序相反。若某个类中的成员对象也存在于其他一个或多个类中（共享的情况），那就不能简单的进行销毁，这种情况应当使用 “引用计数” 来跟踪仍旧访问着共享对象的数量。</li>
</ol>
<hr>
<ol start="5">
<li>由于在构造器中调用某个动态绑定的方法会造成所有数据可能为零的情况（原因参考3中的第一点），所以在编写构造器时，要尽可能地遵循这一条规则：“用尽可能简单的方法使对象进入正常状态，如果可以的话，避免调用其他方法”。在构造器内部唯一能够安全调用的方法是基类中的 final 方法（也适用于 private 方法，因为private 方法自动属于 final 方法），因为这些方法不能被覆盖，也就不存在在基类构造器中调用导出类中对基类的某个方法的覆盖。</li>
</ol>
<hr>
<ol start="6">
<li>协变返回类型：在导出类中的被覆盖方法可以返回基类方法的返回类型的某种导出类型。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Grain"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wheat</span> <span class="keyword">extends</span> <span class="title">Grain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Wheat"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mill</span> </span>&#123;</span><br><span class="line">    <span class="function">Grain <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Grain();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WheatMill</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 覆盖父类的 process() 方法</span></span><br><span class="line">    <span class="comment">// 并将返回值修改成 Grain 类的子类 Wheat</span></span><br><span class="line">    <span class="function">Wheat <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wheat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<ol start="7">
<li>用继承表达行为间的差异，并用字段表达状态上的变化（状态模式）</li>
</ol>
<hr>
<ol start="8">
<li>运行时类型识别 ( RTTI : Runtime type information)</li>
</ol>
<ul>
<li>向下转型对类型进行检查时，如果类型不对，会抛出一个 <strong>ClassCastException</strong> (类转型异常)</li>
</ul>
<hr>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ol>
<li>创建一个能够根据所传递的参数对象的不同而具有不同行为的方法，叫做 “策略模式”</li>
</ol>
<hr>
<ol start="2">
<li>适配器中的代码将接收你所拥有的接口，并产生你所需要的接口（适配器模式）</li>
</ol>
<hr>
<ol start="3">
<li><p>使用接口的核心原因：为了能够向上转型为多个基类</p>
<p> 使用接口的第二个原因：防止客户端程序员创建该类的对象（抽象类也能做到）</p>
<p> 如果要创建一个不带任何方法定义以及成员变量的基类，那么就应该使用接口而不是抽象类</p>
</li>
</ol>
<hr>
<ol start="4">
<li>恰当的原则是应当优先选择类而不是接口，从类开始，如果接口的必需性变得非常明确，那么就进行重构。</li>
</ol>
<hr>
<ol start="5">
<li>尽量避免在组合的不同接口中使用相同的方法名。</li>
</ol>
<hr>
<ol start="6">
<li>使用工厂方法模式的常见原因是创建框架</li>
</ol>
<hr>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><ol>
<li>在内部类中生成外部类对象的引用需要使用 <code>OuterClass.this</code> ；要想创建某个内部类的对象需要使用外部类对象才能创建。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        <span class="comment">// 使用外部类对象创建内部类对象</span></span><br><span class="line">        Inner inner = outer.new Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在拥有外部类对象之前是不可能创建内部类对象的，因为内部类对象会连接到创建他的外部类对象上。如果创建的是<strong>静态内部类</strong>，那么就不需要对外部类对象的引用</li>
</ul>
<hr>
<ol start="2">
<li>定义一个匿名内部类并且希望他使用一个在其外部定义的对象，那么编译器会要求其参数引用是 final 的。</li>
</ol>
<hr>
<ol start="3">
<li>匿名内部类中的实例初始化（构造器效果）：使用非静态代码块来实现（因为每次创建对象都会执行）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getProduct</span><span class="params">(<span class="keyword">final</span> <span class="keyword">float</span> widget)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Product() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> cost;</span><br><span class="line">            <span class="comment">// 非静态代码块(相当于匿名内部类的构造器)</span></span><br><span class="line">            &#123;</span><br><span class="line">                cost = Math.round(widget);</span><br><span class="line">                <span class="keyword">if</span> (cost &gt; <span class="number">100</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"超重！"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"Product!"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>匿名内部类中的实例初始化方法无法重载，所以有且仅有一个构造器</li>
<li>基类需要的是有参构造器：将基类需要的参数传递给基类的构造器即可</li>
</ul>
<hr>
<ol start="4">
<li>不需要内部类与外部类有联系时，可以使用关键字 static 来声明内部类，通常称为嵌套类</li>
</ol>
<ul>
<li>普通内部类对象隐式地保存了一个引用，指向创建他的外部类对象</li>
<li>当内部类是 <strong>static</strong> 时意味着：<ul>
<li>要创建嵌套类的对象，并不需要外部类的对象</li>
<li>不能从嵌套类的对象中访问非静态的外部类对象</li>
<li>普通内部类的字段与方法，只能放在类的外部层次上，所以普通内部类中不能有 <strong>static</strong> 数据和 <strong>static</strong> 字段，也不能包含嵌套类。但是嵌套类中可以包含上述所有</li>
</ul>
</li>
</ul>
<hr>
<ol start="5">
<li>接口内部的类由于是自动 public 和 static 的，所以甚至可以在接口内部实现接口本身</li>
</ol>
<hr>
<ol start="6">
<li>一个内部类被嵌套多少层不重要，反正都能访问所有在他外面的外部类的所有成员</li>
</ol>
<hr>
<ol start="7">
<li>使用内部类最重要的原因是：每个内部类都能独立地继承自一个（接口的）实现，所以无论外部类是否已经继承了某个（接口的）实现，对于内部类都没有影响</li>
</ol>
<hr>
<ol start="8">
<li>如果使用内部类，可以获得一些如下所示的特性：</li>
</ol>
<ul>
<li>内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外部类对象的信息相互独立</li>
<li>在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类</li>
<li>创建内部类对象的时刻不依赖于外部类对象的实现</li>
<li>内部类没有 “ is - a ” 关系，他就是一个独立的实体</li>
</ul>
<hr>
<ol start="9">
<li>闭包（ closure ）：是一个可调用的对象，它记录了一些信息（持有上下文中某部分信息），这些信息来自于创建它的作用域。</li>
</ol>
<ul>
<li><p>内部类是面向对象的闭包，因为它不仅包含了外部类对象（创建内部类的作用域）的信息，还持有一个指向外部类对象的引用，在此作用域内，内部类有权操作所有的成员（包括 private 成员）</p>
</li>
<li><p><strong>回调（ callback ）: 通过回调，对象能够携带一些信息，这些信息允许他在稍后的某个时刻调用初始的对象</strong></p>
</li>
<li><p>回调的价值在于他的灵活性，可以在运行时动态决定需要调用什么方法</p>
</li>
</ul>
<hr>
<ol start="10">
<li>模板方法模式：模板方法包括算法的基本结构，并且会调用一个或多个可覆盖方法，以完成算法的动作。设计模式总是将变化的事物与不变的事物分离开，在模板方法模式中，模板方法是保持不变的事物，而那些可覆盖的方法就是变化的事物</li>
</ol>
<hr>
<ol start="11">
<li>主要用来响应事件的系统叫做 “ 事件驱动系统 ”</li>
</ol>
<hr>
<ol start="12">
<li>内部类允许：</li>
</ol>
<ul>
<li>控制框架的完整实现是由单个的类创建的，从而使得实现的细节被封装了起来，内部类用来表示解决问题所必须的各种动作</li>
<li>内部类能够很容易的访问外部类的任意成员，所以可以避免这种实现变得笨拙</li>
</ul>
<hr>
<ol start="13">
<li>内部类的继承：</li>
</ol>
<ul>
<li>内部类的构造器必须连接到指向外部类对象的引用</li>
<li>所以在继承内部类时必须要有一个已经初始化了的外部类的对象，也就是要在内部类的子类的构造器中调用包含内部类的外部类对象的初始化方法 <code>enclosingClassReference.super()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部类和内部类原型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承内部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendInnerClass</span> <span class="keyword">extends</span> <span class="title">Outer</span>.<span class="title">Inner</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造方法中传递一个外部类的引用</span></span><br><span class="line">    <span class="comment">// 并且调用这个引用生成一个可连接的外部类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExtendInnerClass</span><span class="params">(Outer outer)</span> </span>&#123;</span><br><span class="line">        outer.<span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExtendInnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        ExtendInnerClass extendInnerClass = <span class="keyword">new</span> ExtendInnerClass(outer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<ol start="14">
<li>创建一个新类继承自外部类时，重新定义外部类里面的内部类（也就是覆盖他们），实际上是覆盖不了的，除非在新类中创建一个内部类并指定他继承自外部类里面的内部类</li>
</ol>
<hr>
<ol start="15">
<li>局部内部类不能有访问说明符，因为他不是外部类的一部分，但是他可以访问当前代码块里的常量以及外部类的所有成员。局部内部类允许有以类名命名的构造器</li>
</ol>
<ul>
<li>使用局部内部类而不是匿名内部类的原因是<strong>需要一个已命名的构造器，或者需要重载构造器</strong>，而匿名内部类只能用于实例初始化</li>
<li>使用局部内部类而不是匿名内部类的另一个原因就是<strong>需要不止一个该内部类的对象</strong></li>
</ul>
<hr>
<ol start="16">
<li>内部类编译文件命名规则（ .class 文件）：外部类类名$内部类类名.class</li>
</ol>
<ul>
<li>匿名内部类编译文件则只会简单地产生一个数字作为标识符，例如 <code>外部类类名$1.class</code> 、 <code>外部类类名$2.class</code> 。如果是嵌套的内部类，只需用 <code>$</code> 将其连接在其外部类后面即可。</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/复习/" rel="tag"># 复习</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/16/笔记（五）/" rel="next" title="笔记（五）">
                <i class="fa fa-chevron-left"></i> 笔记（五）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/head.jpg" alt="beiranc">
            
              <p class="site-author-name" itemprop="name">beiranc</p>
              <p class="site-description motion-element" itemprop="description">你在想peach</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/beiranc" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1429123035@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://plus.google.com/lintsky" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://www.zhihu.com/people/chen-jun-jie-50-22" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-book"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象导论"><span class="nav-number">1.</span> <span class="nav-text">对象导论</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#操作符"><span class="nav-number">2.</span> <span class="nav-text">操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化和清理"><span class="nav-number">3.</span> <span class="nav-text">初始化和清理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#访问权限控制"><span class="nav-number">4.</span> <span class="nav-text">访问权限控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复用类"><span class="nav-number">5.</span> <span class="nav-text">复用类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多态"><span class="nav-number">6.</span> <span class="nav-text">多态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接口"><span class="nav-number">7.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部类"><span class="nav-number">8.</span> <span class="nav-text">内部类</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">beiranc</span>

  
</div>








  <div class="footer-custom">Hosted by <a target="_blank" href="https://pages.github.com">GitHub Pages</a></div>


        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
