<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="复习,">










<meta name="description" content="ORM的思想​    将关系数据库中表的记录映射为对象，以对象的形式展现，可以把对数据库的操作转化为对对象的操作。  Hibernate开发步骤​    ①创建 Hibernate 配置文件 ​    ②创建持久化类 ​    ③创建对象-关系映射文件 ​    ④通过 Hibernate API 编写访问数据库的代码  HibernateTool For Eclipse安装​    Instal">
<meta name="keywords" content="复习">
<meta property="og:type" content="article">
<meta property="og:title" content="Hibernate">
<meta property="og:url" content="http://yoursite.com/2019/10/25/Hibernate/index.html">
<meta property="og:site_name" content="北然">
<meta property="og:description" content="ORM的思想​    将关系数据库中表的记录映射为对象，以对象的形式展现，可以把对数据库的操作转化为对对象的操作。  Hibernate开发步骤​    ①创建 Hibernate 配置文件 ​    ②创建持久化类 ​    ③创建对象-关系映射文件 ​    ④通过 Hibernate API 编写访问数据库的代码  HibernateTool For Eclipse安装​    Instal">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-10-24T17:19:01.280Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hibernate">
<meta name="twitter:description" content="ORM的思想​    将关系数据库中表的记录映射为对象，以对象的形式展现，可以把对数据库的操作转化为对对象的操作。  Hibernate开发步骤​    ①创建 Hibernate 配置文件 ​    ②创建持久化类 ​    ③创建对象-关系映射文件 ​    ④通过 Hibernate API 编写访问数据库的代码  HibernateTool For Eclipse安装​    Instal">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/10/25/Hibernate/">





  <title>Hibernate | 北然</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">北然</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">insomniac</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>
            
            日程表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/25/Hibernate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="beiranc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="北然">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Hibernate</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-25T01:11:52+08:00">
                2019-10-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/笔记/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h5 id="ORM的思想"><a href="#ORM的思想" class="headerlink" title="ORM的思想"></a>ORM的思想</h5><p>​    将关系数据库中表的记录映射为对象，以对象的形式展现，可以把对数据库的操作转化为对对象的操作。</p>
<hr>
<h5 id="Hibernate开发步骤"><a href="#Hibernate开发步骤" class="headerlink" title="Hibernate开发步骤"></a>Hibernate开发步骤</h5><p>​    ①创建 Hibernate 配置文件</p>
<p>​    ②创建持久化类</p>
<p>​    ③创建对象-关系映射文件</p>
<p>​    ④通过 Hibernate API 编写访问数据库的代码</p>
<hr>
<h5 id="HibernateTool-For-Eclipse安装"><a href="#HibernateTool-For-Eclipse安装" class="headerlink" title="HibernateTool For Eclipse安装"></a>HibernateTool For Eclipse安装</h5><p>​    <a href="http://download.jboss.org/jbosstools/oxygen/stable/updates/" target="_blank" rel="noopener">Install Software 链接</a></p>
<p>​    <a href="https://tools.jboss.org/downloads/" target="_blank" rel="noopener">JBoss官网</a></p>
<p>​    <a href="http://hibernate.org/tools/" target="_blank" rel="noopener">Hibernate Tools 官网</a></p>
<hr>
<h5 id="Configuration-类"><a href="#Configuration-类" class="headerlink" title="Configuration 类"></a>Configuration 类</h5><p>​    (1) <strong>Configuration 类负责管理 Hibernate 的配置信息</strong>，包括如下内容：</p>
<p>​        ① <strong>Hibernate运行的底层信息</strong>：数据库的URL，用户名，密码，JDBC 驱动类，数据库 Dialect（方言），数        据库连接池等（对应 <code>hibernate.cfg.xml</code> 文件）</p>
<p>​        ② <strong>持久化类与数据表的映射关系</strong>（<code>*.hbm.xml</code>文件）</p>
<p>​    (2) <strong>创建 Configuration 的两种方式</strong></p>
<p>​        ①属性文件（<code>hibernate.properties</code>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration();</span><br></pre></td></tr></table></figure>

<p>​        ②XML文件（<code>hibernate.cfg.xml</code>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Configuration configuration  = <span class="keyword">new</span> Configuration().configure();</span><br></pre></td></tr></table></figure>

<p>​        注：Configuration的configure()方法还支持带参数的访问</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"example.xml"</span>);</span><br><span class="line">Configuration configuration  = <span class="keyword">new</span> Configuration().configure(file);</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="SessionFactory接口"><a href="#SessionFactory接口" class="headerlink" title="SessionFactory接口"></a>SessionFactory接口</h5><p>​    (1) 针对单个数据库映射关系经过编译后的内存镜像，是线程安全的</p>
<p>​    (2) <strong>SessionFactory</strong>对象一旦构造完毕，即被赋予特定的配置信息</p>
<p>​    (3) <strong>SessionFactory</strong>是生成<strong>Session</strong>的工厂</p>
<p>​    (4) 构造<strong>SessionFactory</strong>很消耗资源，一般情况下一个应用中只初始化一个<strong>SessionFactory</strong>对象</p>
<p>​    (5) <strong>Hibernate 4</strong>新增了一个<strong>ServiceRegistry</strong>接口，所有基于<strong>Hibernate</strong>的配置或者服务都必须统一向这个 ServiceRegistry 注册后才能生效</p>
<p>​    (6) <strong>Hibernate 4</strong>中创建<strong>SessionFactory</strong>的步骤</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Configuration对象</span></span><br><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取ServiceRegistry对象</span></span><br><span class="line">ServiceRegistry serviceRegistry = <span class="keyword">new</span> ServiceRegistryBuilder().applySettings(configuration.getProperties()).buildServiceRegistry();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建SessionFactory对象</span></span><br><span class="line">SessionFactory sessionFactory = configuration.buildSessionFactory(serviceRegistry);</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="Session接口"><a href="#Session接口" class="headerlink" title="Session接口"></a>Session接口</h5><ul>
<li>Session 是应用程序与数据库之间交互操作的一个<strong>单线程对象</strong>，是 Hibernate 运作的中心，所有持久化对象必须在 Session 的管理下才可以进行持久化操作。此对象的生命周期很短。Session 对象有一个一级缓存，显式执行 flush() 之前，所有的持久层操作的数据都缓存在 Session 对象处。相当于 JDBC 中的Connection，实际上是对Connection的封装。</li>
<li>Session接口是Hibernate向应用程序提供的操纵数据库的最主要的接口，它提供了基本的<strong>保存，更新，删除和加载</strong> Java 对象的方法。Session具有一个缓存，位于缓存中的对象称为持久化对象，它和数据库中的相关记录对应。Session能够在某些时间点，按照缓存中对象的变化来执行相关的SQL语句，来同步更新数据库，这一过程被称为刷新缓存（flush）。站在持久化的角度，Hibernate把对象分为四种状态，分别是<strong>持久化状态、临时状态、游离状态、删除状态</strong>等。Session的特定方法能够将对象从一个状态转换到另外一个状态。</li>
</ul>
<hr>
<h5 id="hibernate-cfg-xml配置文件解释"><a href="#hibernate-cfg-xml配置文件解释" class="headerlink" title="hibernate.cfg.xml配置文件解释"></a>hibernate.cfg.xml配置文件解释</h5><p>(1) <strong>hbm2ddl.auto</strong></p>
<p>​    有四个取值：</p>
<p>​        ①create</p>
<p>​            会根据<code>*.hbm.xml</code>文件来生成数据表，但是每次运行都会删除上一次的表，重新生成表，哪怕第二次没            有任何改变</p>
<p>​        ②create-drop</p>
<p>​            会根据<code>*.hbm.xml</code>文件来生成数据表，但是SessionFactory一关闭，生成的数据表就自动删除</p>
<p>​        ③update（<strong>最常用</strong>）</p>
<p>​            会根据<code>*.hbm.xml</code>文件来生成数据表，但是若 <code>.hbm.xml</code>文件中对应的数据表与数据库中对应的数据表            结构不同才会更新数据表，但不会删除已有的行和列</p>
<p>​        ④validate</p>
<p>​            会和数据库中的表进行比较，若<code>*.hbm.xml</code>文件中的列在数据表中不存在，则抛出异常，但不会做任何            修改</p>
<p>(2) <strong>format_sql</strong></p>
<p>​    是否将SQL转化为格式良好的SQL（即格式化SQL），取值true|false</p>
<p>(3) <strong>show_sql</strong></p>
<p>​    是否在控制台将SQL语句打印出来，取值true|false</p>
<p>(4) <strong>dialect</strong></p>
<p>​    使用怎样的数据库方言，取值见<code>hibernate\project\etc\hibernate.properties</code>文件中</p>
<p>(5) <strong>connection.autocommit</strong></p>
<p>​    是否自动提交事务，取值true|false</p>
<hr>
<h5 id="flush缓存"><a href="#flush缓存" class="headerlink" title="flush缓存"></a>flush缓存</h5><ul>
<li>flush：Session按照缓存中对象的属性变化来同步更新数据库</li>
<li>默认情况下Session在以下时间点刷新缓存：</li>
</ul>
<p>​        ①显式调用Session的flush()方法</p>
<p>​        ②当应用程序调用Transaction的commit()方法时，该方法会先刷新缓存，然后再向数据库提交事务</p>
<p>​        ③当应用程序执行一些查询（HQL，Criteria）操作时，如果缓存中持久化对象的属性已经发生了变化，会        先刷新缓存，以保证查询结果能够反映持久化对象的最新状态</p>
<ul>
<li><strong>flush缓存的例外情况</strong>：如果对象使用native生成器生成OID，那么当调用Session的save()方法保存对象时，会立即执行向该数据库插入该实体的INSERT语句</li>
<li><strong>commit()和flush()方法的区别</strong>：flush()方法执行一系列SQL语句，但不提交事务；commit()方法先调用flush()方法，然后提交事务，提交事务意味着对数据库操作永久保存下来</li>
<li>若希望改变flush()方法的默认刷新时间点，可以通过Session的<strong>setFlushMode()</strong>方法显式设定刷新的时间点：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">模式</th>
<th align="center">各种查询方法</th>
<th align="center">Transaction的commit()方法</th>
<th align="center">Session的flush()方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">FlushMode.AUTO(默认模式)</td>
<td align="center">刷新缓存</td>
<td align="center">刷新缓存</td>
<td align="center">刷新缓存</td>
</tr>
<tr>
<td align="center">FlushMode.COMMIT</td>
<td align="center">不刷新缓存</td>
<td align="center">刷新缓存</td>
<td align="center">刷新缓存</td>
</tr>
<tr>
<td align="center">FlushMode.NEVER</td>
<td align="center">不刷新缓存</td>
<td align="center">不刷新缓存</td>
<td align="center">刷新缓存</td>
</tr>
</tbody></table>
<hr>
<h5 id="对象的三种状态"><a href="#对象的三种状态" class="headerlink" title="对象的三种状态"></a>对象的三种状态</h5><p>​    <strong>(1) Transient 瞬时状态</strong>：在数据库中没数据，跟Session不相关，没存过</p>
<p>​    使用new操作符初始化的对象不是立刻就持久的。它们的状态是瞬时的，也就是说它们没有任何跟数据库表相关联的行为，只要应用不再去引用这些对象（不再被任何其他对象所引用），它们的状态就会丢失，并由垃圾回收机制回收。</p>
<p>​    <strong>(2) Persistenet 持久化状态</strong>：在数据库中有记录，Session中也有记录，自动更新</p>
<p>​    持久化实例时任何具有数据库标识的实例，它由持久化管理器Session统一管理，持久化实例是在事务中进行操作的，它们的状态在事务结束时同数据库进行同步，当事务提交时，通过执行SQL的INSERT、UPDATE、DELETE语句把内存中的状态同步到数据库中。</p>
<p>​    <strong>(3) Detached 游离态</strong>：在数据库中有记录，但是在Session中没有，需手动同步</p>
<p>​    Session关闭后，持久化对象就变成了游离对象，游离表示这个对象不能再和数据库保持同步，它们不再受Hibernate管理。</p>
<p><strong>Plus：三种状态的区分</strong></p>
<p>​    Transient对象：随时可能被垃圾回收器回收（在数据库中没有与之对应的记录，因为是new初始化），没有纳入Session的管理，而执行save()方法后，就变为Persistent对象。<strong>内存中一个对象，没有ID，缓存中也没有</strong></p>
<p>​    Persistent对象：在数据库中存在对应的记录，纳入Session管理，在清理缓存（脏数据检查）的时候，会和数据库同步。<strong>内存中有，缓存中也有，数据库中有（ID）</strong></p>
<p>​    Detached对象：可能被垃圾回收器回收掉（数据库中存在对应的记录，只是没有任何对象引用它是指Session引用），没有纳入Session的管理。<strong>内存有，缓存没有，数据库有（ID）</strong></p>
<hr>
<h5 id="Hibernate主键生成策略"><a href="#Hibernate主键生成策略" class="headerlink" title="Hibernate主键生成策略"></a>Hibernate主键生成策略</h5><p>​    ①<strong>increment</strong>：适用于代理主键，由Hibernate自动以递增方式生成</p>
<p>​    ②<strong>identity</strong>：适用于代理主键，由底层数据库生成标识符</p>
<p>​    ③<strong>sequence</strong>：适用于代理主键，Hibernate根据底层数据库的序列生成标识符，这要求底层数据库支持序列</p>
<p>​    ④<strong>hilo</strong>：适用于代理主键，Hibernate分局high/low算法生成标识符</p>
<p>​    ⑤<strong>seqhilo</strong>：适用于代理主键，使用一个high/low算法来高效的生成long，short或者int类型的标识符</p>
<p>​    ⑥<strong>native</strong>：适用于代理主键，根据底层数据库自动生成标识符，自动选择identity，sequence或hilo</p>
<p>​    ⑦<strong>uuid.hex</strong>：适用于代理主键，Hibernate采用128位的UUID算法生成标识符</p>
<p>​    ⑧<strong>uuid.string</strong>：适用于代理主键，UUID被编码成一个16位字符长的字符串</p>
<p>​    ⑨<strong>assigned</strong>：适用于自然主键，由Java应用程序负责生成标识符</p>
<p>​    ⑩<strong>foreign</strong>：适用于代理主键，使用另外一个相关联的对象的标识符（外键）</p>
<p>​    <strong><em>注：常用identity和native方式</em></strong></p>
<hr>
<h5 id="refresh-方法与clear-方法"><a href="#refresh-方法与clear-方法" class="headerlink" title="refresh()方法与clear()方法"></a>refresh()方法与clear()方法</h5><p>​    refresh()方法是强制将Session中的对象与数据表中的保持一致（发送一条SELECT语句）。</p>
<p>​    clear()方法会将Session中缓存的所有的对象清空。</p>
<hr>
<h5 id="Hibernate-的-get-方法和-load-方法的区别"><a href="#Hibernate-的-get-方法和-load-方法的区别" class="headerlink" title="Hibernate 的 get() 方法和 load() 方法的区别"></a>Hibernate 的 get() 方法和 load() 方法的区别</h5><ul>
<li>执行 <strong>get()</strong> 方法，会立即加载对象（即立即查询）</li>
<li>执行 <strong>load()</strong> 方法，若不使用该对象，则不会立即执行查询，而返回一个代理对象（即延迟加载）</li>
<li>若数据表中没有对应的记录，<strong>Session</strong>没关，<strong>get()</strong> 方法返回 <strong>null</strong> ，<strong>load()</strong> 方法抛出异常（需要使用对象时，不使用对象不抛异常）</li>
<li><strong>load()</strong> 方法可能会抛出懒加载异常（<code>LazyInitiakizationException</code>），在需要初始化代理对象之前已经关闭了<strong>Session</strong>对象时会出现这种情况</li>
</ul>
<hr>
<h5 id="Hibernate-的-update-方法"><a href="#Hibernate-的-update-方法" class="headerlink" title="Hibernate 的 update() 方法"></a>Hibernate 的 update() 方法</h5><ul>
<li>更新一个游离对象时需要显式调用 <strong>update()</strong> 方法（会将一个游离对象变为持久化对象），无论游离对象和数据表中是否一致都会发送<strong>UPDATE</strong>语句</li>
<li>在 <code>*.hbm.xml</code> 文件中 <strong>class</strong> 节点设置 <strong>select-before-update</strong> 属性为 <strong>true</strong> （通常不需要设置，除非有特殊的触发器）</li>
<li>若数据表中没有对应的记录，但也调用了 <strong>update()</strong> 方法，则会抛出异常</li>
</ul>
<hr>
<h5 id="Hibernate-的-saveOrUpdate-方法"><a href="#Hibernate-的-saveOrUpdate-方法" class="headerlink" title="Hibernate 的 saveOrUpdate() 方法"></a>Hibernate 的 saveOrUpdate() 方法</h5><ul>
<li>判定为临时对象的标准<ul>
<li>Java 对象的 OID 为 null</li>
<li><code>*.hbm.xml</code> 文件中为 id 设置了 <code>unsaved-value</code> 属性，并且 Java 对象的 OID 取值与这个 <code>unsaved-value</code> 属性相匹配</li>
</ul>
</li>
</ul>
<hr>
<h5 id="Hibernate-的-delete-方法"><a href="#Hibernate-的-delete-方法" class="headerlink" title="Hibernate 的 delete() 方法"></a>Hibernate 的 delete() 方法</h5><ul>
<li>计划执行一条 <strong>DELETE</strong>语句</li>
<li>将对象从 <strong>Session</strong> 缓存中删除，该对象进入删除状态</li>
<li><code>hibernate.cfg.xml</code> 文件中有一个 <code>hibernate.user_identifier_rollback</code> 属性，默认为 <strong>false</strong> ，可以将其置为 <strong>true</strong> 从而使 <strong>delete()</strong> 方法在删除对象使将对象的 <strong>OID</strong> 置为 <strong>null</strong>，从而将其变成临时对象</li>
</ul>
<hr>
<h5 id="Hibernate-的-evict-方法"><a href="#Hibernate-的-evict-方法" class="headerlink" title="Hibernate 的 evict() 方法"></a>Hibernate 的 evict() 方法</h5><ul>
<li>从 <strong>Session</strong> 缓存中将指定的持久化对象移除</li>
</ul>
<hr>
<h5 id="Hibernate-配置文件"><a href="#Hibernate-配置文件" class="headerlink" title="Hibernate 配置文件"></a>Hibernate 配置文件</h5><ul>
<li>每个 Hibernate 配置文件都对应一个 Configuration 对象</li>
<li>Hibernate 配置文件有两种选项<ul>
<li><code>hibernate.properties</code></li>
<li><code>hibernate.cfg.xml</code></li>
</ul>
</li>
</ul>
<hr>
<h5 id="JDBC-连接属性"><a href="#JDBC-连接属性" class="headerlink" title="JDBC 连接属性"></a>JDBC 连接属性</h5><ul>
<li><code>connection.url</code> : 数据库 URL</li>
<li><code>connection.name</code> : 数据库用户名</li>
<li><code>connection.password</code> : 数据库用户密码</li>
<li><code>connection.driver class</code> : 数据库 JDBC 驱动</li>
<li><code>dialect</code> : 配置数据库的方言，根据底层的数据库不同产生不同的 SQL 语句， Hibernate 会针对数据库的特性在访问时进行优化</li>
</ul>
<hr>
<h5 id="C3P0-数据库连接池属性"><a href="#C3P0-数据库连接池属性" class="headerlink" title="C3P0 数据库连接池属性"></a>C3P0 数据库连接池属性</h5><ul>
<li><code>hibernate.c3p0.max_size</code> : 数据库连接池的最大连接数</li>
<li><code>hibernate.c3p0.min_size</code> : 数据库连接池的最小连接数</li>
<li><code>hibernate.c3p0.timeout</code> : 数据库连接池中连接对象在多长时间没有使用过后，就应该被销毁</li>
<li><code>hibernate.c3p0.max_statements</code> : 缓存 Statement 对象的数量</li>
<li><code>hibernate.c3p0.idle_text_period</code> : 表示连接池<strong>检测线程</strong>多长时间检测一次池内的所有连接对象是否超时，连接池本身不会把自己从连接池中移除，而是专门有一个线程按照一定的时间间隔来做这件事，这个线程通过比较连接对象最后一次使用时间和当前时间的时间差来和 <code>timeout</code> 做对比，进而决定是否销毁这个连接对象</li>
<li><code>hibernate.c3p0.acquire_increment</code> : 当数据库连接池中的连接耗尽时，同一时刻获取多少个数据库连接</li>
</ul>
<hr>
<h5 id="在-Hibernate-中使用-C3P0-数据源"><a href="#在-Hibernate-中使用-C3P0-数据源" class="headerlink" title="在 Hibernate 中使用 C3P0 数据源"></a>在 Hibernate 中使用 C3P0 数据源</h5><p>​    ① 导入 jar 包（位于 <code>hibernate\lib\optional\c3p0</code> 路径下）</p>
<p>​    ② 加入配置</p>
<hr>
<h5 id="hibernate-mapping"><a href="#hibernate-mapping" class="headerlink" title="hibernate-mapping"></a>hibernate-mapping</h5><ul>
<li>hibernate-mapping 是 hibernate 映射文件的根元素，它有以下属性：<ul>
<li>schema : 指定所映射的数据库 schema 的名称，若指定该属性，则表明会自动添加该 schema 前缀</li>
<li>catalog : 指定所映射的数据库 catalog 的名称</li>
<li>default-cascade (默认为 none ) : 设置 Hibernate 默认的级联风格，若配置 Java 属性，集合映射时没有指定 cascade 属性，则 hibernate 将采用此处指定的级联风格</li>
<li>default-access (默认为 property ) : 指定 Hibernate 的默认的属性访问策略，默认值为 property ，即使用 getter/setter 方法来访问属性，若指定 access ，则 Hibernate 会忽略 getter/setter 方法，而通过反射访问成员变量</li>
<li>default-lazy (默认为 true ) : 设置 Hibernate 默认的延迟加载策略，该属性的默认值为 true，即启用延迟加载策略，若配置 Java 属性映射，集合映射时没有指定 lazy 属性，则 Hibernate 将采用此处指定的延迟加载策略</li>
<li>auto-import (默认为 true ) : 指定是否可以在查询语言中使用非全限定的类名（仅限于本映射文件中的类）</li>
<li>package (可选) : 指定一个包前缀，如果在映射文档中没有指定一个限定的类名，则使用这个作为包名</li>
</ul>
</li>
</ul>
<hr>
<h5 id="class"><a href="#class" class="headerlink" title="class"></a>class</h5><ul>
<li>class 元素用于指定类和表的映射，它有以下属性：<ul>
<li>name : 指定该持久化类映射的持久化类的类名</li>
<li>table : 指定该持久化类映射的表名，Hibernate <strong>默认以持久化类的类名作为表名</strong></li>
<li>dynamic-insert : 若设置为 true ，则表示当保存一个对象时，会动态生成 insert 语句，insert 语句中仅包含所有取值不为 null 的字段，默认为 false</li>
<li>dynamic-update : 若设置为 true ，则表示当更新一个对象时，会动态生成 update 语句，update 语句中仅包含所有取值需要更新的字段，默认值为 false</li>
<li>select-before-update : 设置 Hibernate 在更新某个持久化对象之前是否需要先执行一次查询，默认值为 false </li>
<li>batch-size : 指定根据 OID 来抓取实例时每批抓取的实例数</li>
<li>lazy : 指定是否使用延迟加载</li>
<li>mutable : 若设置为 true，则表示所有的 &lt;porperty&gt; 元素的 update 属性为 false ，表示整个实例都不能被更新，默认为 true</li>
<li>discriminator-value : 指定区分不同子类的值，当使用 &lt;subclass/&gt; 元素来定义持久化类的继承关系时需要使用该属性</li>
</ul>
</li>
</ul>
<hr>
<h5 id="映射对象标识符"><a href="#映射对象标识符" class="headerlink" title="映射对象标识符"></a>映射对象标识符</h5><ul>
<li>Hibernate 使用对象标识符 ( OID ) 来建立内存中的对象和数据表中记录的对应关系，对象的 OID 和数据表中的主键对应，Hibernate 通过标识符生成器来为主键赋值</li>
<li>Hibernate 推荐在数据表中使用代理主键 ( 即不具备业务含义的字段 ) ，代理主键通常为整数类型，因为能节省空间</li>
<li>Hibernate 提供了标识符生成器接口 : IdentifierGenerator ，并提供了各种内置实现</li>
</ul>
<hr>
<h5 id="id"><a href="#id" class="headerlink" title="id"></a>id</h5><ul>
<li>设定持久化类的 OID 和表的主键的映射，有以下属性<ul>
<li>name : 标识持久化类 OID 的属性名</li>
<li>column : 设置标识属性所映射的数据表的列名（主键字段的名字）</li>
<li>unsaved-value : 若设定了该属性，Hibernate 会通过比较持久化类的 OID 值和该属性值来区分当前持久化类对象是否为临时对象</li>
<li>type : 指定 Hibernate 映射类型，Hibernate 映射类型是 Java 类型与 SQL 类型的桥梁，如果没有为某个属性显式设定映射类型，Hibernate 会运用反射机制先识别出持久化类的特定属性的 Java 类型，然后自动使用与之对应的默认的 Hibernate 映射类型</li>
<li>Java 的基本数据类型和包装类型对应相同的 Hibernate 映射类型，基本数据类型无法表达 null，所以对于持久化类的 OID 推荐使用包装类型</li>
</ul>
</li>
</ul>
<hr>
<h5 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h5><ul>
<li>设定持久化类设定标识符生成器，有一个属性：<ul>
<li>class : 指定使用的标识符生成器全限定类名或其缩写名( 一般为缩写名 )</li>
</ul>
</li>
</ul>
<hr>
<h5 id="主键生成策略"><a href="#主键生成策略" class="headerlink" title="主键生成策略"></a>主键生成策略</h5><ul>
<li><p>increment</p>
<ul>
<li>increment 生成器由 Hibernate 以递增的方式为代理主键赋值</li>
<li>Hibernate 会先读取数据表中主键的最大值，然后在接下来向表中插入新记录的时候，就在读取到的这个最大值的基础上递增，增量为1</li>
<li>适用范围<ul>
<li>由于 increment 生成标识符机制不依赖于底层数据库系统，因此它适用于所有的数据库系统</li>
<li>适用于只有单个 Hibernate 应用进程访问同一个数据库的场合，在集群环境下不推荐使用它（在多线程环境下可能会出现脏数据）</li>
<li>OID 必须为 long ，int ，或者 short 类型，如果把 OID 定义为 byte 类型，在运行时会抛出异常</li>
</ul>
</li>
</ul>
</li>
<li><p>identity</p>
<ul>
<li>identity 标识符生成器由底层数据库来负责生成标识符，它要求底层数据库把主键定义为自动增长字段类型</li>
<li>适用范围<ul>
<li>由于 identity 生成标识符的机制依赖于底层数据库系统，因此，要求底层数据库系统必须支持自动增长字段类型，支持自动增长字段类型的数据库包括：DB2, MySQL, MSSQL Server, Sybase 等</li>
<li>OID 必须为 long， int， 或者 short 类型，如果把 OID 定义为 byte 类型，在运行时会抛出异常</li>
</ul>
</li>
</ul>
</li>
<li><p>sequence</p>
<ul>
<li><p>sequence 标识符生成器利用底层数据库提供的序列来生成标识符</p>
</li>
<li><p>要在 &lt;generator&gt; 标签中注明使用的序列是谁</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"sequence"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定的序列名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"sequence"</span>&gt;</span>test_seq<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Hibernate 在持久化一个对象时，先从底层数据库的 test_seq 序列中获得一个唯一的标识号，再把它作为主键值</p>
</li>
<li><p>适用范围</p>
<ul>
<li>由于 sequence 生成标识符的机制依赖于底层数据库系统的序列，因此，要求底层数据库必须支持序列，支持序列的数据库包括：DB2，Oracle 等</li>
<li>OID 必须为 long， int， 或者 short 类型，如果把 OID 定义为 byte 类型，在运行时会抛出异常</li>
</ul>
</li>
</ul>
</li>
<li><p>hilo</p>
<ul>
<li><p>hilo 标识符生成器是由 Hibernate 按照一种 high/low 算法来生成标识符，它从数据库的特定表的字段中获取 high 的值</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"hilo"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"table"</span>&gt;</span>HI_TABLE<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"column"</span>&gt;</span>NEXT_VALUE<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"max_lo"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Hibernate 在持久化一个对象时，由 Hibernate 负责生成主键值，hilo 标识符生成器在生成标识符时，需要读取并修改 HI_TABLE 表中的 NEXT_VALUE 值</p>
</li>
<li><p>适用范围</p>
<ul>
<li>由于 hilo 生成标识符机制不依赖于底层数据库系统，因此它适合于所有的数据库系统</li>
<li>OID 必须为 long， int， 或者 short 类型，如果把 OID 定义为 byte 类型，在运行时会抛出异常</li>
</ul>
</li>
</ul>
</li>
<li><p>native</p>
<ul>
<li>native 标识符生成器依据底层数据库对自动生成标识符的支持能力，来选择适用 identity，sequence，或 hilo 标识符生成器</li>
<li>适用范围<ul>
<li>由于 native 能根据底层数据库系统的类型，自动选择合适的标识符生成器，因此很适合于跨数据库平台开发</li>
<li>OID 必须为 long， int， 或者 short 类型，如果把 OID 定义为 byte 类型，在运行时会抛出异常</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="property"><a href="#property" class="headerlink" title="property"></a>property</h5><ul>
<li><p>property 元素用于指定类的属性和表的字段的映射，它有以下属性</p>
<ul>
<li><p>name : 指定该持久化类的属性的名字</p>
</li>
<li><p>column : 指定与类的属性映射的表的字段名，如果没有设置该属性，Hibernate 则会直接适用类的属性名作为字段名</p>
</li>
<li><p>type : 指定 Hibernate 映射类型，Hibernate 映射类型是 Java 类型与 SQL 类型的桥梁，如果没有为某个属性显式设定映射类型，Hibernate 会运用反射机制先识别出持久化类的特定属性的 Java 类型，然后自动使用与之对应的默认的 Hibernate 映射类型</p>
</li>
<li><p>not-null : 若该属性值为 true，则表明不允许为 null，默认为 false</p>
</li>
<li><p>access : 指定 Hibernate 的默认的属性访问策略，默认值为 property，即 使用 getter/setter 方法来访问属性，若指定为 field，则 Hibernate 会忽略 getter/setter 方法，而通过反射机制来访问成员变量</p>
</li>
<li><p>unique : 设置是否为该属性所映射的数据列添加 unique 约束</p>
</li>
<li><p>update : 设置该列值是否可以被修改，默认为 true</p>
</li>
<li><p>index : 指定一个字符串的索引名称，当系统需要 Hibernate 自动建表时，用于为该属性所映射的数据列创建索引，从而加快该数据列的查询</p>
</li>
<li><p>length : 指定该属性所映射数据列的字段的长度</p>
</li>
<li><p>scale : 指定该属性所映射数据列的小数位数，对 double，float，decimal 等类型的数据列有效</p>
</li>
<li><p>formula : 设置一个 SQL 表达式，Hibernate 将根据它来计算出派生属性的值</p>
<ul>
<li><p>派生属性：并不是持久化类的所有属性都直接和表的字段匹配，持久化类的有些属性的值必须在运行时通过计算才能得出来，这类属性称为派生属性</p>
</li>
<li><p>formula = “(SQL表达式)” 的英文括号不能少</p>
</li>
<li><p>SQL 表达式中的列名和表名都应该和数据库对应，而不是和持久化对象的属性对应</p>
</li>
<li><p>如果需要在 formula 属性中使用参数，这直接使用 WHERE cur.id = id 形式，其中 id 就是参数，和当前持久化对象的 id 属性对应的列的 id 值将作为参数传入</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 字段名为 test, 表名为 News, test 字段由 title 字段和 author 字段拼接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"test"</span> <span class="attr">formula</span>=<span class="string">"(SELECT concat(title, ': ' author) FROM News news WHERE news.id = id)"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="Java-时间和日期类型的-Hibernate-映射"><a href="#Java-时间和日期类型的-Hibernate-映射" class="headerlink" title="Java 时间和日期类型的 Hibernate 映射"></a>Java 时间和日期类型的 Hibernate 映射</h5><ul>
<li>持久化类中将成员变量类型设置为 java.util.Date 类型</li>
<li><code>*.hbm.xml</code> 文件中在 property 中设置 type 为 Hibernate 映射类型即可</li>
</ul>
<table>
<thead>
<tr>
<th align="center">Hibernate映射类型</th>
<th align="center">Java类型</th>
<th align="center">标准SQL类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">date</td>
<td align="center">java.util.Date/java.sql.Date</td>
<td align="center">DATE</td>
<td align="center">yyyy-MM-dd</td>
</tr>
<tr>
<td align="center">time</td>
<td align="center">java.util.Date/java.sql.Time</td>
<td align="center">TIME</td>
<td align="center">hh:mm:ss</td>
</tr>
<tr>
<td align="center">timestamp</td>
<td align="center">java.util.Date/java.sql.Timestamp</td>
<td align="center">TIMESTAMP</td>
<td align="center">yyyymmddhhmmss</td>
</tr>
<tr>
<td align="center">calendar</td>
<td align="center">java.util.Calendar</td>
<td align="center">TIMESTAMP</td>
<td align="center">yyyymmddhhmmss</td>
</tr>
<tr>
<td align="center">calendar_date</td>
<td align="center">hexo djava.util.Calendar</td>
<td align="center">DATE</td>
<td align="center">yyyy-MM-dd</td>
</tr>
</tbody></table>
<hr>
<h5 id="Java-大对象类型的-Hibernate-映射"><a href="#Java-大对象类型的-Hibernate-映射" class="headerlink" title="Java 大对象类型的 Hibernate 映射"></a>Java 大对象类型的 Hibernate 映射</h5><ul>
<li><p>长字符串可直接使用 java.lang.String 类型表示</p>
</li>
<li><p>字节数组 byte[] 可用于存放图片或文件的二进制数据</p>
</li>
<li><p>JDBC API 中还提供了 java.sql.Clob 和 java.sql.Blob 类型，它们分别表示标准 SQL 中的 CLOB 和 BLOB 类型</p>
</li>
<li><p>MySQL 不支持标准 SQL 的 CLOB 类型，在 MySQL 中，用 TEXT ，MEDIUMTEST 和 LONGTEXT 类型来表示长度超过 255 的长文本数据</p>
</li>
<li><p>在持久化类中，二进制大对象可以声明为 byte[] 类型数组或者 java.sql.Blob 类型，字符串可以声明为 java.lang.String 或者 java.sql.Clob 类型</p>
</li>
<li><p>如果想精确映射 SQL 类型，可以在 &lt;column&gt; 标签中使用 sql-type 属性，sql-type 属性的取值为当前数据库所支持的 SQL 类型</p>
</li>
<li><p>保存二进制大对象需要一个 InputStream 来读取图片或文件</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"图片/文件路径"</span>);</span><br><span class="line">Blob image = Hibernate.getLobCreator(session).createBlob(inputStream, inputStream.available());</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h5 id="映射组成关系"><a href="#映射组成关系" class="headerlink" title="映射组成关系"></a>映射组成关系</h5><ul>
<li><p>Hibernate 把持久化类的属性分为两种</p>
<ul>
<li>value type( 值类型 ) : 没有 OID ，不能被单独持久化，生命周期依赖于所属的持久化类的对象的生命周期</li>
<li>entity type( 实体类型 ) : 有 OID ，可以被单独持久化，有独立的生命周期</li>
</ul>
</li>
<li><p>Hibernate 使用 &lt;component&gt; 元素来映射组成关系</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 以 Worker 和 Pay 为例， 工人有工资，工资为工人的一部分 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在这里表示 Pay 是 Worker 类的一个组成部分 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在 Hibernate 中称为组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">name</span>=<span class="string">"pay"</span> <span class="attr">class</span>=<span class="string">"Pay"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- parent 元素指定组件属性所属的整体类 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用 parent 元素的前提是在 Pay 中有一个属性为 Worker 的引用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span> <span class="attr">name</span>=<span class="string">"Worker"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"payId"</span> <span class="attr">column</span>=<span class="string">"pay_id"</span> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"payName"</span> <span class="attr">column</span>=<span class="string">"pay_name"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h5 id="单向-n-对-1-关联关系"><a href="#单向-n-对-1-关联关系" class="headerlink" title="单向 n 对 1 关联关系"></a>单向 n 对 1 关联关系</h5><ul>
<li><p>使用 many-to-one 来映射多对一的关联关系，以添加外键的形式来描述多对一的关系</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- n 端映射文件中需要加入 1 端的配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">"customer"</span> <span class="attr">class</span>=<span class="string">"Customer"</span> <span class="attr">column</span>=<span class="string">"customer_id"</span>&gt;</span><span class="tag">&lt;/<span class="name">many-to-one</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>name : n 端关联 1 端的属性的名字</li>
<li>class : 1 端的属性对应的类名</li>
<li>column : 1 端在 n 端的外键的名字</li>
</ul>
</li>
</ul>
<hr>
<h5 id="四个地方会出现懒加载"><a href="#四个地方会出现懒加载" class="headerlink" title="四个地方会出现懒加载"></a>四个地方会出现懒加载</h5><ul>
<li>Session.load() 方法<ul>
<li>如果在 Session 关闭之后再查询此对象会出现懒加载异常，可以在 Session 关闭之前初始化一下查询出来的代理对象 : <code>Hibernate.initialize(object);</code> 来解决这个问题</li>
</ul>
</li>
<li>one-to-one 关联关系</li>
<li>many-to-one 关联关系<ul>
<li>n 对 1 时无论查询哪一端都是默认懒加载的查询，如果不需要懒加载，则要修改映射文件</li>
</ul>
</li>
<li>one-to-many 关联关系</li>
</ul>
<hr>
<h5 id="双向-n-对-1-关联关系"><a href="#双向-n-对-1-关联关系" class="headerlink" title="双向 n 对 1 关联关系"></a>双向 n 对 1 关联关系</h5><ul>
<li><p>在 单向 n 对 1 的基础上在 1 端的类中加上 n 端的集合作为一个属性</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以 Customer 和 Order 为例</span></span><br><span class="line"><span class="comment">// Customer 为 1 端类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Order 为 n 端类</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 1 端的映射文件中加入上面那个集合的映射</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- name 为集合名, table 为 n 端的表名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"orders"</span> <span class="attr">table</span>=<span class="string">"Orders"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- key 为 外键 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">"customer_id"</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 映射类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">"Order"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>&lt;set&gt; 元素的 inverse 属性</p>
<ul>
<li>在 Hibernate 中通过 inverse 属性来决定由双向关联的哪一端来维护表和表之间的关系，<code>inverse = false</code> 的为主动方，<code>inverse = true</code> 的为被动方，由主动方负责维护关联关系</li>
<li>在没有设置 inverse 属性的情况下（即默认情况），两边都维护关联关系</li>
<li>在 1 对 n 关系中，将 n 方设为主动方有助于改善性能</li>
</ul>
</li>
<li><p>&lt;set&gt; 元素的 cascade 属性</p>
<ul>
<li>在对象-关系映射文件中，用于映射持久化类之间关联关系的元素，<strong>&lt;set&gt; &lt;many-to-one&gt; &lt;one-to-one&gt;</strong> 等标签都有一个 cascade 属性，它用于指定如何操纵与当前对象关联的其他对象</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">cascade 属性值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">none</td>
<td align="center">当 Session 操纵当前对象时，忽略其他关联的对象。( <strong>cascade 属性默认值</strong>)</td>
</tr>
<tr>
<td align="center">save-update</td>
<td align="center">当通过 Session 的 save()、update()、saveOrUpdate() 等方法来保存或更新当前对象时，级联保存所有关联的新建的临时对象，并且级联更新所有的游离对象</td>
</tr>
<tr>
<td align="center">persist</td>
<td align="center">当通过 Session 的 persist() 方法来保存当前对象时，会级联保存所有关联的新建的临时对象</td>
</tr>
<tr>
<td align="center">delete</td>
<td align="center">当通过 Session 的 delete() 方法删除当前对象时，会级联删除所有关联的对象</td>
</tr>
<tr>
<td align="center">lock</td>
<td align="center">当通过 Session 的 lock() 方法把当前游离对象添加到 Session 缓存中时，会把所有关联的游离对象也添加到 Session 缓存中</td>
</tr>
<tr>
<td align="center">replicate</td>
<td align="center">当通过 Session 的 replicate() 方法复制当前对象时，会级联复制所有的关联的对象</td>
</tr>
<tr>
<td align="center">evict</td>
<td align="center">当通过 Session 的 evict() 方法从 Session缓存中清除当前对象时，会级联清除所有关联的对象</td>
</tr>
<tr>
<td align="center">refresh</td>
<td align="center">当通过 Session 的 refresh() 方法刷新当前对象时，会级联刷新所有关联的对象，所谓刷新是指读取数据库中相应数据，然后根据数据库中的最新数据去同步更新 Session 缓存中的相应对象</td>
</tr>
<tr>
<td align="center">all</td>
<td align="center">包含 save-update、persist、merge、delete、lock、replicate、evict、refresh等的行为</td>
</tr>
<tr>
<td align="center">delete-orphan</td>
<td align="center">删除所有和当前对象解除关联关系的对象</td>
</tr>
<tr>
<td align="center">merge</td>
<td align="center">当通过 Session 的 merge() 方法来保存当前的对象时，会级联融合所有关联的游离对象</td>
</tr>
<tr>
<td align="center">all-delete-orphan</td>
<td align="center">包含 all 和 delete-orphan 的行为</td>
</tr>
</tbody></table>
<ul>
<li><p>&lt;set&gt; 元素的 order-by 属性</p>
<ul>
<li><p>&lt;set&gt; 元素有一个 order-by 属性，如果设置了该属性，当 Hibernate 通过 select 语句到数据库中检索集合对象时，利用 order-by 子句进行排序</p>
</li>
<li><p>order-by 属性还可以加入 SQL 函数</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- order-by 中放入的是列名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"orders"</span> <span class="attr">inverse</span>=<span class="string">"true"</span> <span class="attr">cascade</span>=<span class="string">"save-update"</span> <span class="attr">order-by</span>=<span class="string">"ORDER_DATE DESC"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">"customer_id"</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">"Order"</span>&gt;</span><span class="tag">&lt;/<span class="name">one-to-many</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<hr>
<h5 id="双向-1-对-1-关联关系"><a href="#双向-1-对-1-关联关系" class="headerlink" title="双向 1 对 1 关联关系"></a>双向 1 对 1 关联关系</h5><ul>
<li><p>按照外键映射 ( 需要使用 unique 约束标记外键 )</p>
<ul>
<li><p>对于基于外键映射的 1 对 1 关联，其外键可以存放至任意一边，在需要存放外键的一端，增加 &lt;many-to-one&gt; 元素，为 &lt;many-to-one&gt; 元素增加 <code>unique=&quot;true&quot;</code> 属性来表示为 1 对 1 关联</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">"manager"</span> <span class="attr">class</span>=<span class="string">"Manager"</span> <span class="attr">column</span>=<span class="string">"MANAGER_ID"</span> <span class="attr">cascade</span>=<span class="string">"all"</span> <span class="attr">unique</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">many-to-one</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>另一端需要使用 &lt;one-to-one&gt; 元素，该元素使用 <code>property-ref</code> 属性指定使用被关联实体主键以外的字段作为关联字段( 即指定引用的外键 )，如果不使用这个属性指定，则会默认使用该表的主键来作为外键进行查询</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">"dept"</span> <span class="attr">class</span>=<span class="string">"Department"</span> <span class="attr">property-ref</span>=<span class="string">"manager"</span>&gt;</span><span class="tag">&lt;/<span class="name">one-to-one</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>按照主键映射</p>
<ul>
<li><p>一端的主键生成器使用 foreign 策略，表明根据 “对方” 的主键来生成自己的主键，自己并不能独立生成主键，&lt;param&gt; 子元素表示指定使用当前持久化类的哪个属性作为 “对方”</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"ID"</span> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用外键方式生成当前表的主键 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"foreign"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- property 属性指定使用当前持久化类的哪一个属性的主键来作为外键 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"property"</span>&gt;</span>manager<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>采用 foreign 主键生成器策略的一端增加 &lt;one-to-one&gt; 元素映射关联属性，其 &lt;one-to-one&gt; 属性还应增加 <code>constrained=&quot;true&quot;</code> 属性，另一端增加 &lt;one-to-one&gt; 元素映射关联属性</p>
</li>
<li><p>constrained ( 约束 ) : 指定为当前持久化类对应的数据库表的主键添加一个外键约束，引用被关联的对象( “对方” ) 所对应的数据库表主键</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">"manager"</span> <span class="attr">class</span>=<span class="string">"Manager"</span> <span class="attr">constrained</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">one-to-one</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<hr>
<h5 id="单向-n-对-n-关联关系"><a href="#单向-n-对-n-关联关系" class="headerlink" title="单向 n 对 n 关联关系"></a>单向 n 对 n 关联关系</h5><ul>
<li><p>( n 对 n 关联必须使用连接表) 需要一张存放有两个或多个持久化类主键的索引表</p>
</li>
<li><p>与 1 对 n 映射类似，必须为 &lt;set&gt; 集合元素添加 &lt;key&gt; 子元素，指定 categories_items 表中参照 categories 表的外键为 category_id ；与 1 对 n 关联映射不同的是，建立 n 对 n 关联时，集合中的元素使用 &lt;many-to-many&gt;，&lt;many-to-many&gt; 子元素的 class 属性指定 items 集合中存放的是 Item 对象， column 属性指定 categories_items 表中参照 items 表的外键为 item_id </p>
<p>  <em>注：categories 表和 items 表分别表示<strong>商品的分类</strong>和<strong>商品</strong>两个实体</em></p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- table 属性用来指定中间表 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"items"</span> <span class="attr">table</span>=<span class="string">"categories_items"</span> <span class="attr">cascade</span>=<span class="string">"save-update"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">"category_id"</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定 n 对 n 的关联关系 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- column 属性用来指定 Set 集合中的持久化类在中间表的外键列名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">many-to-many</span> <span class="attr">class</span>=<span class="string">"Item"</span> <span class="attr">column</span>=<span class="string">"item_id"</span>&gt;</span><span class="tag">&lt;/<span class="name">many-to-many</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h5 id="双向-n-对-n-关联关系"><a href="#双向-n-对-n-关联关系" class="headerlink" title="双向 n 对 n 关联关系"></a>双向 n 对 n 关联关系</h5><ul>
<li>双向 n 对 n 关联需要两端都使用集合属性</li>
<li>双向 n 对 n 关联必须使用连接表</li>
<li>集合属性应增加 key 子元素用以映射外键列，集合元素里还应增加 &lt;many-to-many&gt; 子元素关联实体类</li>
<li>在双向 n 对 n 关联的两边都需要指定连接表的表名及外键列的列名，两个集合元素 &lt;set&gt; 的 table 元素的值必须指定，而且必须相同。&lt;set&gt; 元素的两个子元素：&lt;key&gt; 和 &lt;many-to-many&gt; 都必须指定 column 属性，其中，&lt;key&gt; 和 &lt;many-to-many&gt; 分别指定本持久化类和关联类在连接表中的外键列名，因此两边的 &lt;key&gt; 与 &lt;many-to-many&gt; 的 column 属性交叉相同，也就是说，一边的 &lt;set&gt; 元素的 &lt;key&gt; 的 column 值为 a，&lt;many-to-many&gt; 的 column 为 b；则另一边的 &lt;set&gt; 元素的 &lt;key&gt; 的 column 值为 b，&lt;many-to-many&gt; 的 column 值为 a</li>
<li>对于双向 n 对 n 关联，必须把其中一端的 inverse 设置为 true，否则两端都维护关联关系可能会造成主键冲突</li>
</ul>
<hr>
<h5 id="映射继承关系"><a href="#映射继承关系" class="headerlink" title="映射继承关系"></a>映射继承关系</h5><ul>
<li>Hibernate 支持三种继承映射策略<ul>
<li>使用 subclass 进行映射<ul>
<li>将域模型中的每一个实体对象映射到一个独立的表中，也就是说不用在关系数据模型中考虑域模型中的继承关系和多态</li>
</ul>
</li>
<li>使用 joined-subclass 进行映射<ul>
<li>对于继承关系中的子类使用同一个表，这就需要在数据库中增加额外的区分子类类型的字段</li>
</ul>
</li>
<li>使用 union-subclass 进行映射<ul>
<li>域模型中的每个类映射到一个表，通过关系数据模型中的外键来描述表之间的继承关系。相当于按照域模型的结构来建立数据库中的表，并通过外键来建立表之间的继承关系</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="使用-subclass-元素的继承映射"><a href="#使用-subclass-元素的继承映射" class="headerlink" title="使用 subclass 元素的继承映射"></a>使用 subclass 元素的继承映射</h5><ul>
<li><p>采用 subclass 的继承映射可以实现对于继承关系中父类和子类使用同一张表</p>
</li>
<li><p>因为父类和子类的实例全部保存在同一张表中，因此需要在该表内增加一列，使用该列来区分每行记录到底是哪个类的实例，这一列被称为<strong>辨别者列</strong> （ <em>discriminator</em> ）</p>
</li>
<li><p>在这种映射策略下，使用 subclass 来映射子类，使用 class 或 subclass 的 <code>discriminator-value</code> 属性来指定辨别者列的值</p>
</li>
<li><p>所有子类定义的字段都不能有非空约束。如果为那些字段添加非空约束，那么父类的实例在那些列其实并没有值，这将引起数据库完整性冲突，导致父类的实例无法保存到数据库中</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父类的配置文件 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 鉴别者列 column为该列列名 type为该列的数据类型 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">column</span>=<span class="string">"TYPE"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span><span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>由于父类与子类都使用一张表，所以无论查询父类记录还是查询子类记录，都只需要查询一张表即可</p>
</li>
<li><p>缺点：</p>
<ul>
<li>多出一列鉴别者列</li>
<li>子类独有的字段无法添加非空约束</li>
<li>数据表的字段会随着继承的层次加深而增多</li>
</ul>
</li>
</ul>
<hr>
<h5 id="使用-joined-subclass-元素的继承映射"><a href="#使用-joined-subclass-元素的继承映射" class="headerlink" title="使用 joined-subclass 元素的继承映射"></a>使用 joined-subclass 元素的继承映射</h5><ul>
<li>使用 joined-subclass 元素的继承映射可以实现每个子类一张表</li>
<li>使用这种映射策略时，父类实例保存在父类表中，子类实例由父类表和子类表共同存储。因为子类实例也是一个特殊的父类实例，因此也必然包含了父类实例的属性，于是将子类和父类共有的属性保存在父类表中，子类中增加的属性，保存在子类表中</li>
<li>在这种映射策略下，无须使用鉴别者列，但需要为每个子类使用 key 元素映射共有主键</li>
<li>子类增加的属性可以添加非空约束（因为父类和子类并不在同一张表中）</li>
<li>由于是每个子类一张表，所以在插入数据时会插入多张表，性能会降低</li>
<li>查询父类记录，使用一个左外连接；查询子类记录，使用一个内连接</li>
<li>优点：<ul>
<li>不需要使用鉴别者列</li>
<li>子类独有的字段可以添加非空约束</li>
<li>没有冗余的字段</li>
</ul>
</li>
</ul>
<hr>
<h5 id="使用-union-subclass-元素的继承映射"><a href="#使用-union-subclass-元素的继承映射" class="headerlink" title="使用 union-subclass 元素的继承映射"></a>使用 union-subclass 元素的继承映射</h5><ul>
<li>使用 union-subclass 元素可以实现将每一个实体对象映射到一个独立的表中</li>
<li>子类增加的属性可以有非空约束，即父类实例的数据保存在父类数据表中，而子类实例的数据保存在子类数据表中</li>
<li>子类实例的数据仅保存在子类表中，而在父类表中没有任何记录</li>
<li>在这种映射策略下，子类表的字段会比父类表的映射字段要多，因为字段表的字段等于父类表的字段与子类增加属性的总和</li>
<li>在这种映射策略下，既不需要使用鉴别者列，也不需要使用 key 元素来映射共有主键</li>
<li>使用 union-subclass 映射策略是不可以使用 identity 的主键生成策略的，因为同一类继承层次中所有实体类都需要使用同一个主键种子，即多个持久化实体对应的记录的主键应该是连续的，受此影响，也不该使用 <em>native</em> 生成策略，因为 native 策略会根据数据库来选择使用 <em>identity</em> 或者 <em>sequence</em> 来生成主键</li>
</ul>
<hr>
<h5 id="Hibernate-的检索策略"><a href="#Hibernate-的检索策略" class="headerlink" title="Hibernate 的检索策略"></a>Hibernate 的检索策略</h5><ul>
<li><p>原则：</p>
<ul>
<li>不浪费内存（懒加载）</li>
<li>更高的查询效率（发送尽可能少的 SQL 语句）</li>
</ul>
</li>
<li><p>类级别的检索策略</p>
<ul>
<li><p>类级别可选的检索策略包括<strong>立即检索</strong>和<strong>延迟检索</strong>，默认为延迟检索</p>
<ul>
<li>立即检索：立即加载检索方法指定的对象</li>
<li>延迟检索：延迟加载检索方法指定的对象</li>
</ul>
</li>
<li><p>类级别的检索策略可通过 &lt;class&gt; 元素的 lazy 属性进行设置</p>
</li>
<li><p>如果程序加载一个对象的目的是为了访问他的属性，可以采取立即检索；如果程序加载一个持久化对象仅仅是为了获取他的引用，那么可以采用延迟检索</p>
</li>
<li><p><strong>无论 &lt;class&gt; 元素的 lazy 属性是 true 还是 false，Session 的 <em>get()</em> 方法及 Query 的 <em>list()</em> 方法在类级别总是使用立即检索策略</strong></p>
</li>
<li><p>若 &lt;class&gt; 元素的 lazy 属性为 true 或取默认值，Session 的 <em>load()</em> 方法不会执行查询数据表的 SELECT 语句，仅返回代理类对象的实例，该代理类实例有如下特征：</p>
<ul>
<li>由 Hibernate 在运行时采用 CGLIB 工具动态生成</li>
<li>Hibernate 创建代理类实例时，仅初始化其 OID 属性</li>
<li>在应用程序第一次访问代理类实例的非 OID 属性时，Hibernate 会初始化代理类实例</li>
</ul>
</li>
<li><p>1 对 1 和 n 对 n 的检索策略</p>
<ul>
<li>在映射文件中，用 &lt;set&gt; 元素来配置 1 对 n 关联及 n 对 n 关联关系，&lt;set&gt; 元素有 lazy 和 fetch 属性<ul>
<li>lazy : 主要决定 orders 集合被初始化的时机，即到底是在加载 Customer 对象时就被初始化还是在程序访问 orders 集合时被初始化</li>
<li>fetch : 取值为 select 或 subselect 时，决定初始化 orders 集合的查询语句的形式；若取值为 join，则决定 orders 集合被初始化的时机，默认值为 select</li>
<li>当 fetch 属性为 subselect 时：<ul>
<li>假定 Session 缓存中有 n 个 orders 集合代理类实例没有被初始化，Hibernate 能够通过带子查询的 SELECT 语句，来批量初始化 n 个 orders 集合代理类实例</li>
<li>batch-size 属性将被忽略</li>
<li>子查询中的 SELECT  语句为最初查询 Customers 表的 OID 的 SELECT 语句</li>
</ul>
</li>
<li>当fetch 属性为 join时：<ul>
<li>检索 Customer 对象时，会采用迫切左外连接（通过左外连接加载与检索指定的对象关联的对象，也就是说使用左外连接进行查询并且把集合进行初始化）策略来检索所有关联的 Order 对象</li>
<li>lazy 属性会被忽略</li>
<li>Query 的 <em>list()</em> 方法会忽略映射文件中配置的迫切左外连接检索策略，而依旧采用延迟加载策略</li>
</ul>
</li>
<li>&lt;set&gt; 元素的 batch-size 属性：用来为延迟检索策略或立即检索策略设定批量检索的数量，批量检索能减少 SELECT 语句的数目，提高延迟检索或立即检索的运行性能（代表一次可以初始化多少个集合）</li>
</ul>
</li>
</ul>
</li>
<li><p>延迟检索和增强延迟检索</p>
<ul>
<li>在延迟检索( lazy 属性设为 true 时 )集合属性时，Hibernate 在以下情况下初始化集合代理类实例：<ul>
<li>应用程序第一次访问集合属性：<em>iterator()<em>，</em>size()<em>，</em>isEmpty()<em>，</em>contains()</em> 等方法</li>
<li>通过 <em>Hibernate.initialize()</em> 静态方法显式初始化</li>
</ul>
</li>
<li>增强延迟检索( lazy 属性为 extra ) ：与 <code>lazy=&quot;true&quot;</code> 类似，主要区别是增强延迟检索策略能进一步延迟 Customer 对象的 orders 集合代理实例的初始化时机：<ul>
<li>当程序第一次访问 orders 属性的 <em>iterator()</em> 方法时，会导致 orders 集合代理类实例的初始化</li>
<li>当程序第一次访问 orders 属性的 <em>size()<em>，</em>contains()</em> 和 <em>isEmpty()</em> 方法时，Hibernate 不会初始化 orders 集合类的实例，仅通过特定的 SELECT 语句查询必要的信息，不会检索所有的 Order 对象</li>
</ul>
</li>
</ul>
</li>
<li><p>n 对 1 和 1 对 1 关联的检索策略</p>
<ul>
<li><p>和 &lt;set&gt; 一样，&lt;mant-to-one&gt; 元素也有一个 lazy 属性和 fetch 属性</p>
<table>
<thead>
<tr>
<th align="center">lazy 属性(默认为 proxy )</th>
<th align="center">fetch 属性(默认为 select)</th>
<th align="center">检索 Order 对象时对关联的 Customer 对象使用的检索策略</th>
</tr>
</thead>
<tbody><tr>
<td align="center">proxy</td>
<td align="center">未显式设置（取默认值）</td>
<td align="center">延迟检索</td>
</tr>
<tr>
<td align="center">no-proxy</td>
<td align="center">未显式设置（取默认值）</td>
<td align="center">无代理延迟检索</td>
</tr>
<tr>
<td align="center">FALSE</td>
<td align="center">未显式设置（取默认值）</td>
<td align="center">立即检索</td>
</tr>
<tr>
<td align="center">未显式设置（取默认值）</td>
<td align="center">join</td>
<td align="center">迫切左外连接策略</td>
</tr>
</tbody></table>
</li>
<li><p>若 fetch 属性设为 join ，那么 lazy 属性会被忽略</p>
</li>
<li><p>迫切左外连接检索策略的优点在于比立即检索策略使用的 SELECT 语句更少</p>
</li>
<li><p>无代理延迟检索需要增加持久化类的字节码才能实现</p>
</li>
<li><p>Query 的 <em>list()</em> 方法会忽略映射文件配置的迫切左外连接检索策略，而采用延迟检索策略</p>
</li>
<li><p>如果在关联级别使用了延迟加载或立即加载检索策略，可以设定批量检索大小，以帮助提高延迟检索或立即检索的运行性能</p>
</li>
<li><p>Hibernate 允许在应用程序中覆盖映射文件中设定的检索策略</p>
</li>
<li><p>1 端 &lt;class&gt; 元素可以通过设置 batch-size 属性值来设定一次初始化 1 端代理对象的个数</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="Hibernate-检索方式"><a href="#Hibernate-检索方式" class="headerlink" title="Hibernate 检索方式"></a>Hibernate 检索方式</h5><ul>
<li>Hibernate 提供了以下几种检索对象的方式<ul>
<li>导航对象图检索方式：根据已经加载的对象导航到其他对象</li>
<li>OID 检索方式：按照对象的 OID 来检索对象（主要指 Session 的 <em>get()</em> 方法与 <em>load()</em> 方法）</li>
<li>HQL 检索方式：使用面向对象的 HQL 查询语言（HQL : Hibernate Query Language）</li>
<li>QBC 检索方式：使用 QBC( Query By Criteria ) API 来检索对象，这种 API 封装了基于字符串形式的查询语句，提供了更加面向对象的查询接口</li>
<li>本地 SQL 检索方式：使用本地数据库的 SQL 查询语句</li>
</ul>
</li>
</ul>
<hr>
<h5 id="HQL-检索方式"><a href="#HQL-检索方式" class="headerlink" title="HQL 检索方式"></a>HQL 检索方式</h5><ul>
<li><p>HQL 是面向对象的查询语言，与 SQL 语言类似，在 Hibernate 提供的各种检索方式中，HQL 是使用最广的一种检索方式，有如下功能：</p>
<ul>
<li>在查询语句中设定各种查询条件</li>
<li>支持投影查询，即仅检索出对象的部分属性</li>
<li>支持分页查询</li>
<li>支持连接查询</li>
<li>支持分组查询，允许使用 HAVING 和 GROUP BY 关键字</li>
<li>提供内置聚集函数，如 <em>sum()</em> ，<em>min()<em>，</em>max()</em></li>
<li>支持子查询</li>
<li>支持动态绑定参数</li>
<li>能够调用用户定义的 SQL 函数或标准的 SQL 函数</li>
</ul>
</li>
<li><p>HQL 检索方式包括以下步骤：</p>
<ul>
<li>通过 Session 的 <em>createQuery()</em> 方法创建一个 Query 对象，它包括一个 HQL 查询语句，HQL 查询语句中可以包含命名参数</li>
<li>动态绑定参数</li>
<li>调用 Query 相关方法执行查询语句</li>
</ul>
</li>
<li><p>Query 接口支持<strong>方法链编程风格</strong>，它的 <em>setXxx()</em> 方法返回自身实例而不是 void 类型</p>
</li>
<li><p>HQL 与 SQL 对比：</p>
<ul>
<li>HQL 是面向对象的，Hibernate 负责解析 HQL 查询语句，然后根据 ORM 映射文件中的映射信息将 HQL 查询语句翻译成相应的 SQL 语句，HQL 查询语句中的主体是域模型中的类及类的属性</li>
<li>SQL 查询语句是与关系数据库绑定在一起的，SQL 查询语句中的主体是数据库表及表的字段</li>
</ul>
</li>
<li><p>绑定参数：</p>
<ul>
<li>Hibernate 的参数绑定机制依赖于 JDBC API 中的 PreparedStatement 的预定义 SQL 语句功能</li>
<li>HQL 的参数绑定有两种形式：<ul>
<li>按参数名字绑定：在 HQL 查询语句中定义命名参数，命名参数以 “:” 开头</li>
<li>按参数位置绑定：在 HQL 查询语句中用 “?” 来定义参数位置</li>
</ul>
</li>
<li>相关方法：<ul>
<li><em>setEntity()</em> : 把参数与一个持久化类绑定</li>
<li><em>setParameter()</em> : 绑定任意类型的参数，该方法的第三个参数显式指定 Hibernate 映射类型</li>
</ul>
</li>
</ul>
</li>
<li><p>HQL 采用 ORDER BY 关键字对查询结果排序</p>
</li>
<li><p>分页查询：</p>
<ul>
<li><em>setFirstResult(int firstResult)</em> : 设定从哪一个对象开始检索，参数 firstResult 表示这个对象在查询结果中的索引位置，索引位置的起始值为 0 ，默认情况下，Query 从查询结果中的第一个对象开始检索</li>
<li><em>setMaxResults(int maxResults)</em> : 设定一次最多检索出的对象的数目，在默认情况下，Query 和 Criteria 接口检索出查询结果中所有的对象</li>
</ul>
</li>
<li><p>在映射文件中定义命名查询语句</p>
<ul>
<li><p>Hibernate 允许在映射文件中定义字符串形式的查询语句</p>
</li>
<li><p>&lt;query&gt; 元素用于定义一个 HQL 查询语句，它和 &lt;class&gt; 元素并列</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">query</span> <span class="attr">name</span>=<span class="string">"findNewsByTitle"</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[</span><br><span class="line">    	FROM News n WHERE n.title LIKE :title</span><br><span class="line">    ]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">query</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在程序中通过 Session 的 <em>getNameQuery()</em> 方法获取查询语句对应的 Query 对象</p>
</li>
</ul>
</li>
<li><p>投影查询：查询结果仅包含实体的部分属性，通过 SELECT 关键字实现</p>
<ul>
<li><p>Query 的 <em>list()</em> 方法返回的集合中包含的是数组类型的元素，每个对象数组代表查询结果的一条记录</p>
</li>
<li><p>可以在持久化类中定义一个对象的构造器来包装投影查询返回的记录，使程序能完全运用面向对象的语义来访问查询结果集</p>
</li>
<li><p>可以通过 DISTINCT 关键字来保证查询结果不会返回重复元素</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 返回一个包含 Object[] 的 List */</span></span><br><span class="line"><span class="keyword">SELECT</span> e.email, e.salary, e.dept <span class="keyword">FROM</span> Employee e <span class="keyword">WHERE</span> e.dept = :dept;</span><br><span class="line"><span class="comment">/* 返回一个包含 Employee 对象的 List (前提是 Employee 类中要有这个构造器) */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">new</span> Employee(e.email, e.salary, e.dept) <span class="keyword">FROM</span> Employee e <span class="keyword">WHERE</span> e.dept = :dept;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>报表查询</p>
<ul>
<li>报表查询用于对数据分组和统计，与 SQL 一样，HQL 利用 GROUP BY 关键字对数据分组，用 HAVING 关键字对数据设定约束条件</li>
<li>在 HQL 查询语句中可以调用以下聚集函数：<ul>
<li><em>count()</em></li>
<li><em>min()</em></li>
<li><em>max()</em></li>
<li><em>sum()</em></li>
<li><em>avg()</em></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="HQL-的迫切左外连接"><a href="#HQL-的迫切左外连接" class="headerlink" title="HQL 的迫切左外连接"></a>HQL 的迫切左外连接</h5><ul>
<li><p>迫切左外连接</p>
<ul>
<li><p>LEFT JOIN FETCH 关键字表示迫切左外连接检索策略</p>
</li>
<li><p><em>list()</em> 方法返回的集合中存放实体对象的引用，每个 Department 对象关联的 Employee 集合都被初始化，存放所有关联的 Employee 的实体对象</p>
</li>
<li><p>查询结果中可能会包含重复元素，可以通过一个 HashSet 来过滤重复元素（或者 DISTINCT 关键字）</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* DISTINCT 关键字位置 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> d <span class="keyword">FROM</span> Department d <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="keyword">FETCH</span> d.emps;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>左外连接</p>
<ul>
<li>LEFT JOIN 关键字表示左外连接查询</li>
<li><em>list()</em> 方法返回的集合中存放的是对象数组类型</li>
<li>根据配置文件来决定 Employee 集合的检索策略</li>
<li>如果希望 <em>list()</em> 方法返回的集合中仅包含 Department 对象，可以在 HQL 查询语句中使用 SELECT 关键字</li>
</ul>
</li>
</ul>
<hr>
<h5 id="HQL-的迫切内连接"><a href="#HQL-的迫切内连接" class="headerlink" title="HQL 的迫切内连接"></a>HQL 的迫切内连接</h5><ul>
<li>迫切内连接<ul>
<li>INNER JOIN FETCH 关键字表示迫切内连接，也可以省略 INNER 关键字</li>
<li><em>list()</em> 方法返回的集合中存放 Department 对象的引用，每个 Department 对象的 Employee 集合都被初始化，存放所有关联的 Employee 对象</li>
</ul>
</li>
<li>内连接<ul>
<li>INNER JOIN 关键字表示内连接，也可以省略 INNER 关键字</li>
<li><em>list()</em> 方法的集合中存放的每个元素对应查询结果的一条记录，每个元素都是对象数组类型</li>
<li>如果希望 <em>list()</em> 方法返回的集合仅包含 Department 对象，可以在 HQL 查询语句中使用 SELECT 关键字</li>
</ul>
</li>
<li>与左外连接的区别：不返回左表不符合条件的记录</li>
</ul>
<hr>
<h5 id="关联级别运行时的检索策略"><a href="#关联级别运行时的检索策略" class="headerlink" title="关联级别运行时的检索策略"></a>关联级别运行时的检索策略</h5><ul>
<li>如果在 HQL 中没有显式指定检索策略，将使用映射文件配置的检索策略</li>
<li>HQL 会忽略映射文件中设置的迫切左外连接检索策略，如果希望 HQL 采用迫切左外连接策略，就必须在 HQL 查询语句中显式的指定</li>
<li>若在 HQL 代码中显式指定了检索策略，就会覆盖映射文件中配置的检索策略</li>
</ul>
<hr>
<h5 id="QBC-检索"><a href="#QBC-检索" class="headerlink" title="QBC 检索"></a>QBC 检索</h5><ul>
<li><p>QBC 查询就是通过使用 Hibernate 提供的 Query By Criteria API 来查询对象，这种 API 封装了 SQL 语句的动态拼装，对查询提供了更加面向对象的功能接口</p>
</li>
<li><p>本地 SQL 查询来完善 HQL 不能涵盖所有的查询特性</p>
</li>
<li><p>使用步骤</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 Session 创建一个 Criteria 对象</span></span><br><span class="line">Criteria criteria = session.createCriteria(Employee.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加查询条件</span></span><br><span class="line"><span class="comment">// 在 QBC 中查询条件使用 Criterion 来表示</span></span><br><span class="line"><span class="comment">// Criterion 可以通过 Restrictions 的静态方法获取</span></span><br><span class="line">criteria.add(Restrictions.eq(<span class="string">"email"</span>, <span class="string">"SKUMAR"</span>));</span><br><span class="line">criteria.add(Restrictions.gt(<span class="string">"salary"</span>, <span class="number">5000F</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行查询</span></span><br><span class="line">Employee employee = (Employee) criteria.uniqueResult();</span><br></pre></td></tr></table></figure>
</li>
<li><p>SQL 中的 AND 和 OR</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AND 条件使用 Conjunction 类表示, Conjunction 本身又是一个 Criterion 对象</span></span><br><span class="line"><span class="comment">// 而且 Conjunction 中还可以添加 Criterion</span></span><br><span class="line">Conjunction conjunction = Restrictions.conjunction();</span><br><span class="line">conjunction.add(Restrictions.like(<span class="string">"name"</span>, <span class="string">"a"</span>, MatchMode.ANYWHERE));</span><br><span class="line"></span><br><span class="line"><span class="comment">// OR 条件使用 Disjunction 类表示, 与 Conjunction 类似</span></span><br><span class="line">Disjunction disjunction = Restrictions.disjunction();</span><br><span class="line">disjunction.add(Restrictions.ge(<span class="string">"salary"</span>, <span class="number">6000F</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计查询</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统计查询使用 Projection 类来表示</span></span><br><span class="line">criteria.setProjection(Projections.max(<span class="string">"salary"</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>排序查询</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排序使用 Criteria 的 addOrder()方法</span></span><br><span class="line">criteria.addOrder(Order.asc(<span class="string">"salary"</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>分页查询</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分页查询与 HQL 相同, 都是使用 setFirstResult() 方法与 setMaxResults() 方法</span></span><br><span class="line"><span class="keyword">int</span> pageSize = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> pageNum = <span class="number">4</span>;</span><br><span class="line">criteria.setFirstResult((pageNum - <span class="number">1</span>) * pageSize)</span><br><span class="line">    	.setMaxResults(pageSize)</span><br><span class="line">    	.list();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h5 id="本地-SQL-检索"><a href="#本地-SQL-检索" class="headerlink" title="本地 SQL 检索"></a>本地 SQL 检索</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与 HQL 类似, 都是使用 Session 来获取一个 Query 对象来进行</span></span><br><span class="line">String sql = <span class="string">"INSERT INTO department VALUES(?, ?)"</span>;</span><br><span class="line">Query query = session.createSQLQuery(sql);</span><br><span class="line">query.setInteger(<span class="number">0</span>, <span class="number">80</span>)</span><br><span class="line">     .setString(<span class="number">1</span>, <span class="string">"name"</span>)</span><br><span class="line">     .executeUpdate();</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="Hibernate-缓存"><a href="#Hibernate-缓存" class="headerlink" title="Hibernate 缓存"></a>Hibernate 缓存</h5><ul>
<li><p>Hibernate 提供了两个级别的缓存</p>
<ul>
<li>第一级别的缓存是 Session 级别的缓存，它是属于事务范围的缓存，这一级别的缓存是由 Hibernate 管理的</li>
<li>第二级别的缓存是 SessionFactory 级别的缓存，它是属于进程范围的缓存</li>
</ul>
</li>
<li><p>SessionFactory 的缓存可以分为两类：</p>
<ul>
<li>内置缓存<ul>
<li>Hibernate 自带的，不可卸载的，通常在 Hibernate 的初始化阶段，Hibernate 会把映射元数据和预定义的 SQL 语句放到 SessionFactory 的缓存中，映射元数据是映射文件中数据（<code>*.hbm.xml</code> 中数据）的复制，该内置缓存是只读的</li>
</ul>
</li>
<li>外置缓存（二级缓存）<ul>
<li>一个可配置的缓存插件，在默认情况下，SessionFactory 不会启用这个缓存插件，外置缓存中的数据是数据库数据的复制，外置缓存的物理介质可以是内存也可以是硬盘</li>
</ul>
</li>
</ul>
</li>
<li><p>适合放入二级缓存中的数据：很少被修改的，不是很重要的数据，允许出现偶尔的并发问题的数据</p>
</li>
<li><p>不适合放入二级缓存中的数据：经常被修改的，财务数据（不允许出现并发问题），与其他应用程序共享的数据</p>
</li>
<li><p>二级缓存的并发访问策略</p>
<ul>
<li>两个并发的事务同时访问持久层的缓存的相同数据时，也有可能出现各类并发问题</li>
<li>二级缓存可以设定如下 4 种并发访问策略，每一种访问策略对应一种事务隔离级别：<ul>
<li>非严格读写（ Nonstrict-read-write ）: 不保证缓存与数据库种数据的一致性，提供 Read Uncommited 事务隔离级别，对于极少被修改，而且允许脏读的数据，可以采用本策略</li>
<li>读写型（ Read-write ）: 提供 Read Commited 数据隔离级别，对于经常读但是很少被修改的数据，可以采用这种策略（因为可以防止脏读）</li>
<li>事务型（ Transactional ）: 仅在受管理环境下使用，提供 Repeatable Read 事务隔离级别，对于经常读但很少被修改的的数据，可以采用这种策略（因为可以防止脏读和重复读）</li>
<li>只读型（ Read-Only ）: 提供 Serializable 数据隔离级别，对于从来不会被修改的数据，可以采用这种策略</li>
</ul>
</li>
</ul>
</li>
<li><p>管理 Hibernate 的二级缓存</p>
<ul>
<li><p>Hibernate 的二级缓存是进程或集群范围内的缓存</p>
</li>
<li><p>二级缓存是可配置的插件，Hibernate 允许使用以下缓存插件：</p>
<ul>
<li><p>EHCache : 可作为进程范围内的缓存，存放数据的物理介质可以使用内存或硬盘，对 Hibernate 的查询缓存提供了支持</p>
</li>
<li><p>OpenSymphony OSCache : 可作为进程范围内的缓存，存放数据的物理介质可以使用内存或硬盘，提供了丰富的缓存数据过期策略，对 Hibernate 的查询缓存提供了支持</p>
</li>
<li><p>SwarmCache : 可作为集群范围内的缓存，但不支持 Hibernate 的查询缓存</p>
</li>
<li><p>JBossCache : 可作为集群范围内的缓存，支持 Hibernate 的查询缓存</p>
</li>
<li><p>4 种缓存插件支持的并发访问策略</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Read-Only</th>
<th align="center">Nonstrict-read-write</th>
<th align="center">Read-Write</th>
<th align="center">Transactional</th>
</tr>
</thead>
<tbody><tr>
<td align="center">EHCache</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✗</td>
</tr>
<tr>
<td align="center">OpenSymphony OSCache</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✗</td>
</tr>
<tr>
<td align="center">SwarmCache</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✗</td>
<td align="center">✗</td>
</tr>
<tr>
<td align="center">JBossCache</td>
<td align="center">✓</td>
<td align="center">✗</td>
<td align="center">✗</td>
<td align="center">✓</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
</li>
<li><p>配置进程范围内的二级缓存</p>
<ul>
<li><p>步骤（以 EHCache 为例）</p>
<ul>
<li><p>选择合适的缓存插件 : EHCache（ jar 包和配置文件 ），并编译配置文件（ jar 包路径 : hibernate\lib\optional\ehcache\*.jar, 配置文件路径 : hibernate\project\etc\ehcache.xml）</p>
</li>
<li><p>在 Hibernate 的配置文件中启用二级缓存并指定和 EHCache 对应的缓存适配器</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 启用二级缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cache.use_second_level_cache"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 指定对应的缓存适配器, 如果这个值不对就需要去 jar 包里找正确的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.cache.region.factory_class"</span>&gt;</span>org.hibernate.cache.ehcache.EhCacheRegionFactory<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>选择需要使用二级缓存的持久化类，设置它的二级缓存并发访问策略</p>
<ul>
<li><p>&lt;class&gt; 元素的 cache 子元素表示 Hibernate 会缓存对象的简单属性，但不会缓存集合属性，若希望缓存集合属性中的元素，必须在 &lt;set&gt; 元素中加入 &lt;cache&gt; 子元素</p>
</li>
<li><p>在 Hibernate 配置文件中通过 &lt;class-cache /&gt; 节点配置使用缓存</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class-cache</span> <span class="attr">usage</span>=<span class="string">"read-write"</span> <span class="attr">class</span>=<span class="string">"完整类路径"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>设置持久化类中集合的二级缓存（注意要同时将集合中元素的类也使用二级缓存）</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">collection-cache</span> <span class="attr">usage</span>=<span class="string">"read-write"</span> <span class="attr">class</span>=<span class="string">"完整类路径.集合属性名"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>ehcache.xml 文件解释</p>
<ul>
<li>&lt;diskStore&gt; : 指定一个目录（当 EHCache 把数据写到硬盘上时，就写到这个目录下）</li>
<li>&lt;defaultCache&gt; : 设置缓存的默认数据过期策略</li>
<li>&lt;cache&gt; : 设定具体的命名缓存的数据过期策略，每个命名缓存代表一个缓存区域</li>
<li>缓存区域( region ) : 一个具有名称的缓存块，可以给每一个缓存块设置不同的缓存策略，如果没有设置任何的缓存区域，则所有被缓存的对象，都将使用默认的缓存策略</li>
<li>Hibernate 在不同的缓存区域保存不同的类/集合<ul>
<li>对于类而言，区域的名称是类名，如 com.beiran.Customer</li>
<li>对于集合而言，区域的名称是类名加属性名，如 com.beiran.Customer.orders</li>
</ul>
</li>
</ul>
</li>
<li><p>查询缓存</p>
<ul>
<li><p>默认情况下设置的二级缓存对 HQL 和 QBC 查询是无效的</p>
</li>
<li><p>对于经常使用的查询语句，如果启用了查询缓存，当第一次执行查询语句时，Hibernate 会把查询结果存放在查询缓存中，以后再次执行该查询语句时，只需从缓存中获得查询结果，从而提高查询性能</p>
</li>
<li><p>查询缓存适用于以下场合：</p>
<ul>
<li>应用程序运行时经常使用查询语句</li>
<li>很少对与查询语句检索到的数据进行插入、删除和更新操作</li>
</ul>
</li>
<li><p>启用查询缓存的步骤：</p>
<ul>
<li><p>配置二级缓存（因为查询缓存依赖于二级缓存）</p>
</li>
<li><p>在 Hibernate 配置文件中启用查询缓存</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置文件中启用查询缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cache.use_query_cache"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于希望启用查询缓存的查询语句调用 Query 的 <em>setCacheable()</em> 方法</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>时间戳缓存区域</p>
<ul>
<li>时间戳缓存区域存放了对于查询结果相关的表进行插入、更新或者删除操作的时间戳，Hibernate 通过时间戳缓存区域来判断缓存的查询结果是否过期<ul>
<li>T1 时刻执行查询操作，把查询结果存放在 QueryCache 区域，记录该区域时间戳为 T1</li>
<li>T2 时刻对查询结果相关的表进行更新，Hibernate 把 T2 时刻存放在 UpdateTimestampCache 区域</li>
<li>T3 时刻执行查询结果前，先比较 QueryCache 区域的时间戳和 UpdateTimestampCache  区域的时间戳，若 T2 &gt; T1 ，那么就丢弃原先存放在 QueryCache 区域的查询结果，重新到数据库中查询数据，再把结果存放到 QueryCache 区域；若 T2 &lt; T1 ，直接从 QueryCache 中获取查询结果</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="Query-接口的-iterate-方法"><a href="#Query-接口的-iterate-方法" class="headerlink" title="Query 接口的 iterate() 方法"></a>Query 接口的 <em>iterate()</em> 方法</h5><ul>
<li>同 <em>list()</em> 方法一样也能执行查询操作</li>
<li><em>list()</em> 方法执行的 SQL 语句包含实体类对应的数据表的所有字段</li>
<li><em>iterate()</em> 方法执行的 SQL 语句仅包含实体类对应的数据表的 ID 字段</li>
<li>当遍历访问结果集时，该方法先到 Session 缓存及二级缓存中查看是否存在特定 OID 的对象，如果存在，就直接返回该对象，如果不存在就通过相应的 SELECT 语句去数据库中加载特定的实体对象</li>
<li>大多数情况下应该使用 <em>list()</em> 方法来执行查询，<em>iterate()</em> 方法仅适用于以下场合可以稍微提升一点查询的性能：<ul>
<li>要查询的数据表中包含大量字段</li>
<li>启用了二级缓存，并且二级缓存中可能已经包含了待查询的对象 </li>
</ul>
</li>
</ul>
<hr>
<h5 id="管理-Session"><a href="#管理-Session" class="headerlink" title="管理 Session"></a>管理 Session</h5><ul>
<li>Hibernate 自身提供了三种管理 Session 对象的方法<ul>
<li>Session 对象的生命周期与本地线程绑定</li>
<li>Session 对象的生命周期与 JTA 事务绑定</li>
<li>Hibernate 委托程序管理 Session 对象的生命周期</li>
</ul>
</li>
<li>在 Hibernate 的配置文件中，<code>hibernate.current_session_context_class</code> 属性用于指定 Session 管理方式，可选值有：<ul>
<li>thread : Session 对象的生命周期与本地线程绑定</li>
<li>jta : Session 对象的生命周期与 JTA 事务绑定</li>
<li>managed : Hibernate 委托程序来管理 Session 对象的生命周期</li>
</ul>
</li>
<li>Hibernate 按以下规则将 Session 与本地线程绑定<ul>
<li>当一个线程（ threadA ）第一次调用 SessionFactory 对象的 <em>getCurrentSession()</em> 方法时，该方法会创建一个新的 Session对象（ SessionA ），把该对象与 threadA 绑定，然后将 SessionA 返回</li>
<li>当 threadA 再次调用 SessionFactory 对象的 <em>getCurrentSession()</em> 方法时，该方法会将 SessionA 对象返回</li>
<li>当 threadA 提交 SessionA 对象关联的事务时，Hibernate 会自动 flush SessionA 对象的缓存，然后提交事务，关闭 SessionA 对象，当 threadA 撤销 SessionA 对象关联的事务时，也会自动关闭 SessionA 对象</li>
<li>当 threadA 再次调用 SessionFactory 对象的 <em>getCurrentSession()</em> 方法时，该方法又会创建一个新的 Session对象（ SessionB ），并把该对象与 threadA 绑定，然后将 SessionB 返回</li>
</ul>
</li>
</ul>
<hr>
<h5 id="批量处理数据"><a href="#批量处理数据" class="headerlink" title="批量处理数据"></a>批量处理数据</h5><ul>
<li><p>通常指在一个事务中处理大量的插入、更新、删除操作</p>
</li>
<li><p>通过 Session</p>
<ul>
<li><p>Session 的 <em>save()</em> 以及 <em>update()</em> 方法都会把处理的对象存放在自己的缓存中，如果通过一个 Session 对象来处理大量持久化对象，应该及时从缓存中清空已处理完毕并且不会再访问的对象，具体做法通常是再处理完一个对象或小批量对象后，立即调用 <em>flush()</em> 方法刷新缓存，然后再调用 <em>clear()</em> 方法清空缓存</p>
</li>
<li><p>有以下约束：</p>
<ul>
<li>需要在 Hibernate 配置文件中设置 JDBC 单次批处理的数目，应保证每次向数据库发送批量的 SQL 语句数目与 batch_size 属性一致</li>
<li>若对象采用 “identity” 标识符生成器，则 Hibernate 无法在 JDBC 层进行批量插入操作</li>
<li>进行批量操作时，建议关闭二级缓存</li>
</ul>
</li>
<li><p>使用可滚动的结果集 <code>org.hibernate.ScrollableResults</code>，该对象实际上并不包含任何对象，只包含用于在线定位记录的游标，只有当程序遍历访问 ScrollableResults 对象的特定元素时才会到数据库中加载相应的对象</p>
</li>
<li><p><code>org.hibernate.ScrollableResults</code> 对象由 Query 的 <em>scroll()</em> 方法返回</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScrollableResults sr = session.createQuery(<span class="string">"FROM Department"</span>).scroll();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>通过 HQL</p>
<ul>
<li>HQL 只支持 INSERT INTO … SELECT ( 子查询 ) 形式的插入语句，但不支持 INSERT INTO … VALUES 形式的插入语句，所以不能用 HQL 进行批量插入操作</li>
</ul>
</li>
<li><p>通过 StatelessSession（ 无状态 Session ）</p>
<ul>
<li>StatelessSession 与 Session 的区别：<ul>
<li>StatelessSession 没有缓存，通过 StatelessSession 来加载、保存或更新后的对象处于游离态</li>
<li>StatelessSession 不会与 Hibernate 的二级缓存交互</li>
<li>当调用 StatelessSession 的 <em>save()</em> 、<em>update()</em> 、<em>delete()</em> 方法时，这些方法会立即执行相应的 SQL 语句，而不会仅计划执行一条 SQL 语句</li>
<li>StatelessSession 不会进行脏数据检查，因此修改了对象的属性后，还需要调用 StatelessSession 的 <em>update()</em> 方法来更新数据库中数据</li>
<li>StatelessSession 不会对关联的对象进行任何级联操作</li>
<li>通过同一个 StatelessSession 对象两次加载的 OID 相同的对象，得到的两个对象内存地址不同</li>
<li>StatelessSession 所做的操作可以被 Interceptor 拦截到，但是会被 Hibernate 的事件处理系统忽略掉</li>
</ul>
</li>
</ul>
</li>
<li><p>通过 JDBC API</p>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/复习/" rel="tag"># 复习</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/10/23/SpringMVC/" rel="next" title>
                <i class="fa fa-chevron-left"></i> 
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/head.jpg" alt="beiranc">
            
              <p class="site-author-name" itemprop="name">beiranc</p>
              <p class="site-description motion-element" itemprop="description">你在想peach</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/beiranc" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1429123035@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://plus.google.com/lintsky" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://www.zhihu.com/people/chen-jun-jie-50-22" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-book"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#ORM的思想"><span class="nav-number">1.</span> <span class="nav-text">ORM的思想</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Hibernate开发步骤"><span class="nav-number">2.</span> <span class="nav-text">Hibernate开发步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HibernateTool-For-Eclipse安装"><span class="nav-number">3.</span> <span class="nav-text">HibernateTool For Eclipse安装</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Configuration-类"><span class="nav-number">4.</span> <span class="nav-text">Configuration 类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SessionFactory接口"><span class="nav-number">5.</span> <span class="nav-text">SessionFactory接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Session接口"><span class="nav-number">6.</span> <span class="nav-text">Session接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#hibernate-cfg-xml配置文件解释"><span class="nav-number">7.</span> <span class="nav-text">hibernate.cfg.xml配置文件解释</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#flush缓存"><span class="nav-number">8.</span> <span class="nav-text">flush缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#对象的三种状态"><span class="nav-number">9.</span> <span class="nav-text">对象的三种状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Hibernate主键生成策略"><span class="nav-number">10.</span> <span class="nav-text">Hibernate主键生成策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#refresh-方法与clear-方法"><span class="nav-number">11.</span> <span class="nav-text">refresh()方法与clear()方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Hibernate-的-get-方法和-load-方法的区别"><span class="nav-number">12.</span> <span class="nav-text">Hibernate 的 get() 方法和 load() 方法的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Hibernate-的-update-方法"><span class="nav-number">13.</span> <span class="nav-text">Hibernate 的 update() 方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Hibernate-的-saveOrUpdate-方法"><span class="nav-number">14.</span> <span class="nav-text">Hibernate 的 saveOrUpdate() 方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Hibernate-的-delete-方法"><span class="nav-number">15.</span> <span class="nav-text">Hibernate 的 delete() 方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Hibernate-的-evict-方法"><span class="nav-number">16.</span> <span class="nav-text">Hibernate 的 evict() 方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Hibernate-配置文件"><span class="nav-number">17.</span> <span class="nav-text">Hibernate 配置文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JDBC-连接属性"><span class="nav-number">18.</span> <span class="nav-text">JDBC 连接属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C3P0-数据库连接池属性"><span class="nav-number">19.</span> <span class="nav-text">C3P0 数据库连接池属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#在-Hibernate-中使用-C3P0-数据源"><span class="nav-number">20.</span> <span class="nav-text">在 Hibernate 中使用 C3P0 数据源</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#hibernate-mapping"><span class="nav-number">21.</span> <span class="nav-text">hibernate-mapping</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#class"><span class="nav-number">22.</span> <span class="nav-text">class</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#映射对象标识符"><span class="nav-number">23.</span> <span class="nav-text">映射对象标识符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#id"><span class="nav-number">24.</span> <span class="nav-text">id</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#generator"><span class="nav-number">25.</span> <span class="nav-text">generator</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#主键生成策略"><span class="nav-number">26.</span> <span class="nav-text">主键生成策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#property"><span class="nav-number">27.</span> <span class="nav-text">property</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Java-时间和日期类型的-Hibernate-映射"><span class="nav-number">28.</span> <span class="nav-text">Java 时间和日期类型的 Hibernate 映射</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Java-大对象类型的-Hibernate-映射"><span class="nav-number">29.</span> <span class="nav-text">Java 大对象类型的 Hibernate 映射</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#映射组成关系"><span class="nav-number">30.</span> <span class="nav-text">映射组成关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#单向-n-对-1-关联关系"><span class="nav-number">31.</span> <span class="nav-text">单向 n 对 1 关联关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#四个地方会出现懒加载"><span class="nav-number">32.</span> <span class="nav-text">四个地方会出现懒加载</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#双向-n-对-1-关联关系"><span class="nav-number">33.</span> <span class="nav-text">双向 n 对 1 关联关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#双向-1-对-1-关联关系"><span class="nav-number">34.</span> <span class="nav-text">双向 1 对 1 关联关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#单向-n-对-n-关联关系"><span class="nav-number">35.</span> <span class="nav-text">单向 n 对 n 关联关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#双向-n-对-n-关联关系"><span class="nav-number">36.</span> <span class="nav-text">双向 n 对 n 关联关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#映射继承关系"><span class="nav-number">37.</span> <span class="nav-text">映射继承关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用-subclass-元素的继承映射"><span class="nav-number">38.</span> <span class="nav-text">使用 subclass 元素的继承映射</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用-joined-subclass-元素的继承映射"><span class="nav-number">39.</span> <span class="nav-text">使用 joined-subclass 元素的继承映射</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用-union-subclass-元素的继承映射"><span class="nav-number">40.</span> <span class="nav-text">使用 union-subclass 元素的继承映射</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Hibernate-的检索策略"><span class="nav-number">41.</span> <span class="nav-text">Hibernate 的检索策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Hibernate-检索方式"><span class="nav-number">42.</span> <span class="nav-text">Hibernate 检索方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HQL-检索方式"><span class="nav-number">43.</span> <span class="nav-text">HQL 检索方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HQL-的迫切左外连接"><span class="nav-number">44.</span> <span class="nav-text">HQL 的迫切左外连接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HQL-的迫切内连接"><span class="nav-number">45.</span> <span class="nav-text">HQL 的迫切内连接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#关联级别运行时的检索策略"><span class="nav-number">46.</span> <span class="nav-text">关联级别运行时的检索策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#QBC-检索"><span class="nav-number">47.</span> <span class="nav-text">QBC 检索</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#本地-SQL-检索"><span class="nav-number">48.</span> <span class="nav-text">本地 SQL 检索</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Hibernate-缓存"><span class="nav-number">49.</span> <span class="nav-text">Hibernate 缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Query-接口的-iterate-方法"><span class="nav-number">50.</span> <span class="nav-text">Query 接口的 iterate() 方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#管理-Session"><span class="nav-number">51.</span> <span class="nav-text">管理 Session</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#批量处理数据"><span class="nav-number">52.</span> <span class="nav-text">批量处理数据</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">beiranc</span>

  
</div>








  <div class="footer-custom">Hosted by <a target="_blank" href="https://pages.github.com">GitHub Pages</a></div>


        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
