<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Archlinux 安装过程记录</title>
    <url>/Linux/Archlinux-%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="安装系统过程"><a href="#安装系统过程" class="headerlink" title="安装系统过程"></a>安装系统过程</h3><a id="more"></a>

<blockquote>
<p><strong>强烈建议在每次安装前都去 <a href="https://wiki.archlinux.org/index.php/Installation_guide">Archlinux Wiki Installation Guide</a> 查看是否有什么变化。</strong></p>
</blockquote>
<h4 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h4><ol>
<li>访问 <a href="https://www.archlinux.org/download">Archlinux Download</a> 链接下载所需镜像（一般为 ISO 格式），在使用镜像制作工具（推荐 Rufus）制作镜像之前建议先验证所下载文件的签名，尤其是从 HTTP 镜像源下载的文件。</li>
<li>制作镜像（推荐 <a href="https://rufus.ie/">Rufus</a>）</li>
</ol>
<h4 id="启动到-Live-环境"><a href="#启动到-Live-环境" class="headerlink" title="启动到 Live 环境"></a>启动到 Live 环境</h4><ol>
<li>Asus X550VX 为开机按 F2 进入 BIOS，接着在 Boot 中选择带有 Arch 安装文件的媒介启动</li>
<li>默认的 Shell 是 zsh，会以 root 身份登入</li>
</ol>
<h4 id="验证启动模式"><a href="#验证启动模式" class="headerlink" title="验证启动模式"></a>验证启动模式</h4><ol>
<li><p>目前一般启动模式都为 GPT+UEFI</p>
</li>
<li><p>可以使用如下命令验证启动模式：若命令没有错误地显示了目录，则系统以 UEFI 模式启动。若目录不存在，系统则可能为 BIOS 模式或 CSM 模式启动（详见 Arch Wiki）。</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ls /sys/firmware/efi/efivars</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="连网"><a href="#连网" class="headerlink" title="连网"></a>连网</h4><ol>
<li><p>Archlinux 的安装需要连网下载相关文件</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 以下为使用 Wifi 的情况</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> iwctl</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> device list （列出所有网卡）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> station wlan0/wlan1... scan （使用哪块网卡扫描）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> station wlan0/wlan1... get-networks （列出所有可用网络）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> station wlan0/wlan1... connect SSID （连接到网络，SSID 为网络名）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入密码</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> quit （退出 iwctl）</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="更新系统时间"><a href="#更新系统时间" class="headerlink" title="更新系统时间"></a>更新系统时间</h4><ol>
<li><p>使用 <code>timedatectl</code> 来确保系统时间是准确的</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> timedatectl set-ntp <span class="literal">true</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 timedatectl staus 来检查服务状态</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="建立硬盘分区"><a href="#建立硬盘分区" class="headerlink" title="建立硬盘分区"></a>建立硬盘分区</h4><ol>
<li><p>硬盘若已被系统识别，则会显示为一个块设备（如 <code>/dev/sda</code>, <code>/dev/sdb</code> 等），可以使用 <code>fdisk</code> 命令进行查看</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> fdisk -l</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>cfdisk</code> 来对硬盘进行分区</p>
</li>
<li><p>对于一个 Archlinux 系统来说，必须要有的挂载点有：</p>
<ul>
<li>一个根分区（即 <code>/mnt</code> 分区）</li>
<li>一个 EFI 系统分区（即 <code>/mnt/boot</code> 或是 <code>/mnt/efi</code>，如果是双系统则可以直接使用 Windows 的 EFI 分区，但是要<strong>注意千万不要对其进行格式化操作</strong>，一般 Windows 的 EFI 分区都为 100MB，大多数情况下是够用的，但如果需要安装 GRUB 主题的话是不够用的，推荐扩容到 512MB）</li>
<li>[SWAP] （需大于 512 MB）</li>
</ul>
</li>
<li><p>分区方案（假设是一块 500GB 的 SSD，识别为 /dev/sda）</p>
<table>
<thead>
<tr>
<th>挂载点</th>
<th>分区</th>
<th>分区类型</th>
<th>大小</th>
</tr>
</thead>
<tbody><tr>
<td>/mnt/boot</td>
<td>/dev/sdb2（挂载到 Windows 的 EFI 分区上）</td>
<td>EFI 系统分区</td>
<td>512 MB</td>
</tr>
<tr>
<td>/mnt</td>
<td>/dev/sda1</td>
<td>Linux x86_64 根目录（/）</td>
<td>150 GB</td>
</tr>
<tr>
<td>[SWAP]</td>
<td>/dev/sda2</td>
<td>Linux Swap</td>
<td>8 GB</td>
</tr>
<tr>
<td>/mnt/home</td>
<td>/dev/sda3</td>
<td>Linux File System</td>
<td>剩余空间</td>
</tr>
</tbody></table>
</li>
<li><p>格式化分区</p>
<p> 当分区建立完毕后，需要使用适当的文件系统进行格式化</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Ext4 文件系统</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkfs.ext4 /dev/sda1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkfs.ext4 /dev/sda3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Swap 分区</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkswap /dev/sda2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> swapon /dev/sda2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>挂载分区</p>
<p> 将根分区挂载到 <code>/mnt</code></p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mount /dev/sda1 /mnt</span></span><br></pre></td></tr></table></figure>

<p> 然后使用 <code>mkdir</code> 命令创建其他剩余的挂载点并挂载</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mkdir /mnt/home</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdir /mnt/boot</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mount /dev/sda3 /mnt/home</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mount /dev/sd2 /mnt/boot （注意挂载到 Windows EFI 分区处）</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ol>
<li><p>选择镜像，由于在国内，所以需要手动添加国内的镜像源 <a href="https://www.archlinux.org/mirrorlist/all/https">Archlinux All Https Mirrorlist</a>。修改 <code>/etc/pacman.d/mirrorlist</code> 文件，添加即可</p>
</li>
<li><p>安装软件包</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pacstrap /mnt base linux-lts linux-firmware networkmanager vim</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="Chroot-环境下配置系统"><a href="#Chroot-环境下配置系统" class="headerlink" title="Chroot 环境下配置系统"></a>Chroot 环境下配置系统</h4><ol>
<li><p>Fstab</p>
<p> 用以下命令生成 fstab 文件（<code>-U</code> 参数设置 UUID，<code>-L</code> 参数设置卷标）</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat /mnt/etc/fstab （检查生成的 fstab 文件是否正确）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Chroot</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> arch-chroot /mnt</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>时区</p>
<p> 设置时区</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span></span><br></pre></td></tr></table></figure>

<p> 运行 <code>hwclock</code> 以生成 <code>/etc/adjtime</code></p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> hwclock --systohc</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>本地化</p>
<p> 需要修改的文件有：<code>locale.gen</code> 与 <code>locale.conf</code></p>
<p> 编辑 <code>/etc/locale.gen</code> ，然后移除需要的地区前的注释符号（移除 <code>en_US.UTF-8</code> 与 <code>zh_CN.UTF-8</code> 前的注释）</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> locale-gen （生成 locale 信息）</span></span><br></pre></td></tr></table></figure>

<p> 创建 <code>/etc/locale.conf</code> 文件，并编辑设定 <code>LANG</code> 变量</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> LANG=en_US.UTF-8</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>网络配置</p>
<p> 创建 <code>/etc/hostname</code> 文件，并添加如下内容：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> beiran</span></span><br></pre></td></tr></table></figure>

<p> 添加对应的信息到 <code>/etc/hosts</code> 中：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 127.0.0.1 localhost</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ::1 localhost</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 127.0.0.1 beiran.localdomain beiran</span></span><br></pre></td></tr></table></figure>

<p> 若有公网 IP，则将 <code>127.0.0.1</code> 更换为公网 IP</p>
</li>
<li><p>Initramfs</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mkinitcpio -P</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Root 密码</p>
<p> 设置 Root 密码：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> passwd</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>更新微码（intel-ucode）</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pacman -S intel-ucode</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 Grub</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pacman -S grub efibootmgr os-prober （os-prober 是因为双系统）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> grub-install --efi-directory=/boot --bootloader-id=Archlinux</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> grub-mkconfig -o /boot/grub/grub.cfg</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装其他的基础包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pacman -S openssh wget curl dialog wpa_supplicant ntfs-3g dnsutils</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置图形化环境</p>
<p>首先确定显卡型号：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> lspci | grep -E <span class="string">&quot;VGA|3D&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>安装对应驱动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pacman -S alsa-utils （声卡）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> pacman -S xf86-video-vesa （Intel 集显）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> pacman -S nvidia-lts nvidia-utils nvidia-settings （Nvidia 独显，因为内核装的 linux-lts 所以独显驱动也装的 nvidia-lts）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> pacman -S xf86-video-vmware</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> pacman -S xf86-input-synaptics （触摸板驱动）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> pacman -S bluez-utils bluez （蓝牙）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>相关配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> systemctl <span class="built_in">enable</span> NetworkManager.service</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl <span class="built_in">enable</span> bluetooth.service</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> nmcli 的使用方法</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> nmcli dev wifi list （查询 wifi 列表）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> nmcli device wifi connect <span class="string">&quot;SSID&quot;</span> password <span class="string">&quot;PASSWORD&quot;</span>（连接 wifi）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装显示管理器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这里选择使用 LightDM</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> pacman -S lightdm lightdm-deepin-greeter numlockx</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改 LightDM 配置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> vim /etc/lightdm/lightdm.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> greeter-session=lightdm-deepin-greeter</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> greeter-setup-script=/usr/bin/numlockx on</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改 /etc/pacman.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 Color 选项前的注释去掉</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl <span class="built_in">enable</span> lightdm</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> pacman -S haveged</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl <span class="built_in">enable</span> haveged</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 Deepin Desktop</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pacman -S deepin deepin-extra zssh lrzsz archlinux-wallpaper</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> useradd -m -G wheel beiran</span></span><br></pre></td></tr></table></figure>

<p>设置密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> passwd beiran</span></span><br></pre></td></tr></table></figure>

<p>修改 <code>sudo</code> 设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pacman -S sudo</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> vim /etc/sudoers</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加一行：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> beiran ALL=(ALL) ALL</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装字体</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pacman -S wqy-zenhei wqy-bitmapfont adobe-source-code-pro-fonts adobe-source-han-serif-cn-fonts adobe-source-han-sans-cn-fonts noto-fonts noto-fonts-extra noto-fonts-emoji noto-fonts-cjk ttf-dejavu</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 Fcitx 输入法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pacman -S fcitx-googlepinyin fcitx-mozc fcitx-im fcitx-skin-material</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以修改 ~/.config/fcitx/conf/fcitx-classic-ui.conf 中的 SkinType 参数来启用 material 皮肤</span></span><br></pre></td></tr></table></figure>

<p>配置 Fcitx：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 全局设置修改 /etc/environment</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> GTK_IM_MODULE=fcitx</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> QT_IM_MODULE=fcitx</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> XMODIFIERS=@im=fcitx</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 非全局设置则新建 ~/.pam_environment</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者 ~/.xprofile</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h4><ol>
<li><p>退出 Chroot 环境</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">exit</span> （退出 Chroot 环境）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> umount -R /mnt （卸载被挂载的分区）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> reboot</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 移除安装介质（U盘）</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h4><ol>
<li><p>使用非 <code>root</code> 用户登录</p>
</li>
<li><p>生成默认文件夹</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sudo pacman -S xdg-user-dirs</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> xdg-user-dirs-update --force</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 <code>zsh</code></p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sudo pacman -S zsh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑 ~/.zshrc 文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ZSH_THEME=<span class="string">&quot;ys&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> plugins=(git web-search zsh-autosuggestions zsh-synta-highlighting)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换 zsh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> chsh -s /bin/zsh</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 <code>Shadowsocks-libev</code></p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sudo pacman -S shadowsocks-libev simple-obfs</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo mkdir /etc/shadowsocks</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo vim /etc/shadowsocks/config.json（将自己的配置文件复制进去）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl <span class="built_in">enable</span> shadowsocks-libev@config.service</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl start shadowsocks-libev@config.service</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 <code>pfetch</code></p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> wget https://github.com/dylanaraps/pfetch/archive/master.zip</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> pfetch-master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo install pfetch /user/<span class="built_in">local</span>/bin</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<hr>
<h3 id="软件安装过程"><a href="#软件安装过程" class="headerlink" title="软件安装过程"></a>软件安装过程</h3><h4 id="添加-Archlinuxcn-源"><a href="#添加-Archlinuxcn-源" class="headerlink" title="添加 Archlinuxcn 源"></a>添加 Archlinuxcn 源</h4><ol>
<li><p>编辑 <code>/etc/pacman.conf</code> 文件</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加 Archlinuxcn 源</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> [archlinuxcn]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> SigLevel = Optional TrustAll</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Server = https://mirrors.bfsu.edu.cn/archlinuxcn/<span class="variable">$arch</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Server = https://mirrors.cqu.edu.cn/archlinuxcn/<span class="variable">$arch</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Server = https://mirrors.dgut.edu.cn/archlinuxcn/<span class="variable">$arch</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Server = https://mirrors.neusoft.edu.cn/archlinuxcn/<span class="variable">$arch</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 <code>archlinux-keyring</code></p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sudo pacman -S archlinuxcn-keyring</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo pacman -Syu</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Mysql 5.7.30 相关配置</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装完成后首先初始化数据库，这一步如果没出错的话会生成一个初始密码</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo mysqld --initialize --user=mysql</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果出现错误，尝试删除 /var/lib/mysql 目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo rm -rf /var/lib/mysql</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后连接到 Mysql</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mysql -u root -p</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入之前的初始密码，连接成功后修改 root 用户的密码以及允许远程连接</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="string">&#x27;123456&#x27;</span>;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> UPDATE user SET Host=<span class="string">&#x27;%&#x27;</span> WHERE user=<span class="string">&#x27;root&#x27;</span>;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> FLUSH PRIVILEGES;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>IntelliJ-IDEA-CE 相关配置</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Archlinux</tag>
        <tag>安装过程</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven</title>
    <url>/Maven/Maven/</url>
    <content><![CDATA[<h5 id="Maven-是一个-Java-项目的自动化构建工具"><a href="#Maven-是一个-Java-项目的自动化构建工具" class="headerlink" title="Maven 是一个 Java 项目的自动化构建工具"></a><a href="https://maven.apache.org/">Maven</a> 是一个 Java 项目的自动化构建工具<a id="more"></a></h5><hr>
<h5 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h5><ul>
<li>清理：将之前编译得到的旧的 class 字节码删除，为下一次编译做准备</li>
<li>编译：将 Java 源码编译成 class 字节码</li>
<li>测试：自动调用 Junit 执行测试</li>
<li>报告：测试的结果</li>
<li>打包：Web 工程生成 war 包，Java 工程生成 jar 包</li>
<li>安装：将打包生成的文件复制到仓库中的指定位置</li>
<li>部署：将 Web 工程生成的 war 包复制到 Web 容器的指定目录中</li>
</ul>
<hr>
<h5 id="安装-Maven（见官网-Maven-Install）"><a href="#安装-Maven（见官网-Maven-Install）" class="headerlink" title="安装 Maven（见官网 Maven Install）"></a>安装 Maven（见官网 <a href="https://maven.apache.org/install.html">Maven Install</a>）</h5><hr>
<h5 id="Maven-的核心概念"><a href="#Maven-的核心概念" class="headerlink" title="Maven 的核心概念"></a>Maven 的核心概念</h5><ul>
<li><p><a href="https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html">约定的目录结构</a></p>
</li>
<li><p><a href="https://maven.apache.org/guides/introduction/introduction-to-the-pom.html">POM</a></p>
</li>
<li><p>坐标</p>
<ul>
<li>使用下面三个向量在仓库中唯一定位一个 Maven 工程<ul>
<li>groupid : 公司或组织域名倒序 + 项目名</li>
<li>artifactid : 模块名</li>
<li>version : 版本</li>
</ul>
</li>
</ul>
</li>
<li><p><a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html">依赖</a></p>
<ul>
<li><p>Maven 解析依赖信息时会到本地仓库中查找被依赖的 jar 包。对于自己开发的 Maven 工程，使用 <code>mvn install</code> 命令安装后才能被别的工程引用（这一步的目的是在本地仓库中生成相应文件）</p>
</li>
<li><p>依赖的范围</p>
<ul>
<li><p>dependency 标签中的 scope 标签设置的就是依赖的范围</p>
</li>
<li><p>可选值如下：</p>
<ul>
<li>compile（默认）<ul>
<li>对主程序是否有效：有效</li>
<li>对测试程序是否有效：有效</li>
<li>是否参与打包：参与</li>
<li>是否参与部署：参与</li>
</ul>
</li>
<li>provided<ul>
<li>对主程序是否有效：有效</li>
<li>对测试程序是否有效：有效</li>
<li>是否参与打包：不参与</li>
<li>是否参与部署：不参与</li>
</ul>
</li>
<li>test<ul>
<li>对主程序是否有效：无效</li>
<li>对测试程序是否有效：有效</li>
<li>是否参与打包：不参与</li>
<li>是否参与部署：不参与</li>
</ul>
</li>
<li>system</li>
<li>import</li>
<li>runtime</li>
</ul>
<p><img src="image-20200115025641639.png" alt="image-20200115025641639"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>仓库</p>
<ul>
<li><p>本地仓库</p>
</li>
<li><p>远程仓库</p>
<ul>
<li>私服：架设在当前局域网环境下，为当前局域网范围内的所有 Maven 工程服务</li>
<li>中央仓库：架设在 Internet 上，为全世界所有 Maven 工程服务</li>
<li>中央仓库的镜像：架设在各大洲，为中央仓库分担流量，减轻中央仓库压力，同时更快的响应用户请求</li>
</ul>
<p><img src="image-20200115022433670.png" alt="image-20200115022433670"></p>
</li>
</ul>
</li>
<li><p>生命周期/插件/目标</p>
<ul>
<li>Maven 生命周期定义了各个构建环节的执行顺序，有了这个顺序清单，Maven 才可以自动化的执行构建命令</li>
<li>Maven 有三套相互独立的生命周期，分别是：<ul>
<li>Clean Lifecycle : 在进行真正的构建之前进行一些清理工作<ul>
<li>Clean Lifecycle 一共包含三个阶段：<ul>
<li>pre-clean : 执行一些需要在 clean 之前完成的工作</li>
<li>clean : 移除所有上一次构建生成的文件</li>
<li>post-clean : 执行一些需要在 clean 之后立即完成的工作</li>
</ul>
</li>
</ul>
</li>
<li>Default Lifecycle : 构建的核心部分，编译、测试、打包、安装、部署等<ul>
<li>Default Lifecycle 中比较重要的阶段：<ul>
<li>validate</li>
<li>generate-sources</li>
<li>process-sources</li>
<li>generate-resources</li>
<li>process-resources : 复制并处理资源文件至目标目录，准备打包</li>
<li>compile : 编译项目的源码</li>
<li>process-classes</li>
<li>generate-test-sources</li>
<li>process-test-sources</li>
<li>generate-test-resources</li>
<li>process-test-resources : 复制并处理资源文件至目标测试目录</li>
<li>test-compile : 编译测试源码</li>
<li>process-test-classes</li>
<li>test : 使用单元测试框架运行测试，这些测试代码不会被打包或者部署</li>
<li>prepare-package</li>
<li>package : 接受编译好的代码并打包成可发布的格式。如 JAR、WAR 等</li>
<li>pre-integration-test</li>
<li>integration-test</li>
<li>post-integration-test</li>
<li>verify</li>
<li>install : 将包安装到本地仓库</li>
<li>deploy : 将最终的包复制到远程仓库</li>
</ul>
</li>
</ul>
</li>
<li>Site Lifecycle : 生成项目报告，站点，发布站点<ul>
<li>Site Lifecycle 一共包含四个阶段：<ul>
<li>pre-site : 执行一些需要在生成站点文档之前完成的工作</li>
<li>site(常用) : 生成项目的站点文档</li>
<li>post-site : 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</li>
<li>site-deploy(常用) : 将生成的站点文档部署到特定的服务器上</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>Maven 在运行任何一个阶段的时候，它前面的所有阶段都会被执行</strong>，这是 Maven 能够自动执行构建过程的重要原因</li>
<li>生命周期的各个阶段仅仅定义了要执行的任务是什么，各个阶段和插件的目标是对应的，相似的目标由特定的插件来完成</li>
</ul>
</li>
<li><p>继承</p>
<ul>
<li><p>原因：由于 test 范围不能传递，所以必然会分散在各个模块中，很容易造成版本不一致</p>
</li>
<li><p>解决方案：将相同的依赖（不能传递的）版本统一提取到 parent 中，在 子工程声明该依赖时不指定版本，以 parent 的为准。注意：配置继承之后需要先 install parent </p>
</li>
<li><p>配置方式：</p>
<ul>
<li><p>创建一个 Maven 工程作为 parent，注意：打包的方式为 pom</p>
</li>
<li><p>在子工程中声明对 parent 的引用</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 以当前工程的 pom.xml 文件为基准的 parent 中 pom.xml 文件的相对路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span><span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将子工程的坐标中与 parent 坐标中重复的内容删除</p>
</li>
<li><p>在 parent 中统一管理不能传递的依赖</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">denpendency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span><span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">denpendency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在子工程中删除不能传递的依赖的版本号部分</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>聚合</p>
<ul>
<li><p>作用：一键安装各个模块</p>
</li>
<li><p>配置方式：</p>
<ul>
<li><p>指定一个总的工程，在这个工程中配置各个参与聚合的模块</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定各个子工程的相对路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span><span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="常用-Maven-命令"><a href="#常用-Maven-命令" class="headerlink" title="常用 Maven 命令"></a>常用 Maven 命令</h5><ul>
<li>注：执行与构建过程相关的命令时，必须进入 pom.xml 所在目录</li>
<li><code>mvn clean</code> : 清理</li>
<li><code>mvn compile</code> : 编译主程序</li>
<li><code>mvn test-compile</code> : 编译测试程序</li>
<li><code>mvn test</code> : 执行测试</li>
<li><code>mvn package</code> : 打包</li>
<li><code>mvn install</code> : 安装</li>
<li><code>mvn site</code> : 生成站点</li>
</ul>
<hr>
<h5 id="本地仓库默认位置"><a href="#本地仓库默认位置" class="headerlink" title="本地仓库默认位置"></a>本地仓库默认位置</h5><ul>
<li><code>$&#123;user.home&#125;/.m2/repository</code> （例如 Windows 下为 C:\Users\用户名\.m2\repository）。如需修改本地仓库位置，则需要到 Maven 安装目录下的 conf\settings.xml 文件中找到 localRepository 标签内容即可</li>
</ul>
<hr>
<h5 id="Eclipse-设置"><a href="#Eclipse-设置" class="headerlink" title="Eclipse 设置"></a>Eclipse 设置</h5><ul>
<li>Installations : 更改为自己安装的 Maven 目录（不建议使用 Eclipse 自带的）</li>
<li>User Settings : 更改本地仓库的位置</li>
</ul>
<hr>
<h5 id="依赖的传递性"><a href="#依赖的传递性" class="headerlink" title="依赖的传递性"></a>依赖的传递性</h5><ul>
<li>可以传递的依赖不必在每个模块工程中都重复声明，在底层工程中依赖一次即可</li>
<li>在 compile/test/provided 三个范围中只有 compile 范围可以传递</li>
</ul>
<hr>
<h5 id="依赖的排除"><a href="#依赖的排除" class="headerlink" title="依赖的排除"></a>依赖的排除</h5><ul>
<li>需要设置依赖排除的场合：排除掉不希望加入工程中的 jar 包</li>
<li>设置方式：某个 dependency 标签中加入 exclusions 标签，在 exclusions 标签中填入需要排除的依赖的 groupId 以及 artifactId 即可</li>
</ul>
<hr>
<h5 id="依赖的原则"><a href="#依赖的原则" class="headerlink" title="依赖的原则"></a>依赖的原则</h5><ul>
<li>作用：解决模块工程之间的 jar 包冲突问题</li>
<li>路径最短优先原则</li>
<li>路径长度相同时先声明者优先（先声明指的是路径相同的两个 dependency 标签的声明顺序）</li>
</ul>
<hr>
<h5 id="统一管理依赖的版本"><a href="#统一管理依赖的版本" class="headerlink" title="统一管理依赖的版本"></a>统一管理依赖的版本</h5><ul>
<li><p>配置方式：</p>
<ul>
<li><p>使用 properties 标签，在 properties 标签内自定义一个标签统一声明版本号（ properties 标签不限于统一版本号的使用 ）</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defined.version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">defined.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在需要统一版本的位置，使用 <code>$&#123;自定义标签&#125;</code> 来引用声明的版本号</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;defined.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<hr>
<h5 id="自动部署"><a href="#自动部署" class="headerlink" title="自动部署"></a>自动部署</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- pom.xml 文件中 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置构建过程中的特殊设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 工程最终名字 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置构建过程中需要使用的插件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.cargo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cargo-maven2-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 针对插件进行的配置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 配置容器的位置 --&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">container</span>&gt;</span></span><br><span class="line">                	<span class="tag">&lt;<span class="name">containerId</span>&gt;</span>tomcat9x<span class="tag">&lt;/<span class="name">containerId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">home</span>&gt;</span>/usr/share/tomcat9<span class="tag">&lt;/<span class="name">home</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">container</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                	<span class="tag">&lt;<span class="name">type</span>&gt;</span>existing<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">home</span>&gt;</span>/usr/share/tomcat9<span class="tag">&lt;/<span class="name">home</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 若 Tomcat 端口为默认值则不需要指定端口 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">                    	<span class="tag">&lt;<span class="name">cargo.servlet.port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">cargo.servlet.port</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置插件在什么情况下执行 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                	<span class="tag">&lt;<span class="name">id</span>&gt;</span>cargo-run<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 生命周期的阶段 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>install<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 插件的目标 --&gt;</span></span><br><span class="line">                    	<span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data JPA</title>
    <url>/JPA/Spring-Data-JPA/</url>
    <content><![CDATA[<h5 id="Spring-Data-概述"><a href="#Spring-Data-概述" class="headerlink" title="Spring Data 概述"></a>Spring Data 概述<a id="more"></a></h5><ol>
<li><a href="https://spring.io/projects/spring-data">Spring Data</a> 是 Spring 的一个子项目，用于简化数据库访问，支持 NoSQL 与 关系型数据库。其主要目标是使数据库的访问变得方便快捷</li>
</ol>
<hr>
<h5 id="Spring-Data-JPA-概述"><a href="#Spring-Data-JPA-概述" class="headerlink" title="Spring Data JPA 概述"></a>Spring Data JPA 概述</h5><ol>
<li>Spring Data JPA：致力于减少 DAO 层的开发量，开发者只须声明持久层的接口即可</li>
<li>Spring Data JPA 做的便是规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑</li>
</ol>
<hr>
<h5 id="Spring-Data-JPA-开发步骤"><a href="#Spring-Data-JPA-开发步骤" class="headerlink" title="Spring Data JPA 开发步骤"></a>Spring Data JPA 开发步骤</h5><ol>
<li><p>配置 Spring 整合 JPA（见 JPA ）</p>
</li>
<li><p>在 Spring 配置文件中配置 Spring Data，让 Spring 为声明的接口创建代理对象。配置了 &lt;jpa:repositories&gt; 后，Spring 初始化容器时将会扫描其 base-package 属性指定的包及其子包，为继承 Repository 接口或其子接口的接口创建代理对象，并将代理对象注入 Spring IOC 容器，业务层便可通过 Spring 自动封装的特性来直接使用该对象</p>
<ul>
<li><p>需导入 Spring Data Commons 和 Spring Data JPA 这两个主要模块</p>
</li>
<li><p>配置 Spring Data</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jpa:repositories</span> <span class="attr">base-package</span>=<span class="string">&quot;beiran.dao&quot;</span> <span class="attr">entity-manager-factory-ref</span>=<span class="string">&quot;entityManagerFactory&quot;</span> <span class="attr">transaction-manager-ref</span>=<span class="string">&quot;jpaTransactionManager&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">jpa:repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>声明持久层的接口，该接口继承 Repository 接口，Repository 是一个标记型接口，不包含任何方法，如需必要，Spring Data 可实现 Repository 的其他子接口，其中定义了一些常用的 CRUD 及分页相关的方法</p>
</li>
<li><p>在接口中声明需要的方法，Spring Data 将根据给定的策略来为其生成实现代码</p>
</li>
</ol>
<hr>
<h5 id="Repository-接口"><a href="#Repository-接口" class="headerlink" title="Repository 接口"></a>Repository 接口</h5><ol>
<li><p>Repository 接口是 Spring Data 的一个核心接口，它不提供任何方法，开发者需要在自己定义的接口声明需要的方法（声明的方法需要遵循规范）</p>
</li>
<li><p>可以在持久层接口上使用 @RepositoryDefinition 注解，并为其指定 domainClass（指定实体类） 和 idClass（指定该实体类的主键类型） 属性，这是与继承 Repository 接口等价的一种方式</p>
</li>
<li><p>基础的 Repository 接口提供了最基本的数据访问功能，它的几个子接口则扩展了一些功能</p>
<ul>
<li><p>Repository：仅仅是一个标记，表明任何继承它的接口均为持久层接口类</p>
</li>
<li><p>CrudRepository：继承 Repository，实现了一组 CRUD 相关的方法</p>
</li>
<li><p>PagingAndSortingRepository：继承 CrudRepository，实现了一组分页和排序相关的方法</p>
</li>
<li><p>JpaRepository：继承 PagingAndSortingRepository，实现一组 JPA 规范相关的方法</p>
</li>
<li><p>自定义的 XxxRepository 需要继承 JpaRepository，这样的 XxxRepository 接口就具备了通用的数据访问控制层的能力</p>
</li>
<li><p>JpaSpecificationExecutor：不属于 Repository 的子接口，实现一组 JPA Criteria 查询相关的方法</p>
<p><img src="image-20200218181937666.png" alt="image-20200218181937666"></p>
</li>
</ul>
</li>
</ol>
<hr>
<h5 id="Spring-Data-JPA-方法定义规范"><a href="#Spring-Data-JPA-方法定义规范" class="headerlink" title="Spring Data JPA 方法定义规范"></a>Spring Data JPA 方法定义规范</h5><ol>
<li><p>简单条件查询：查询某一个实体或者集合</p>
</li>
<li><p>按照 Spring Data JPA 的规范，查询方法以 find | read | get 开头，涉及条件查询时，条件的属性用条件关键字连接，要注意的是：条件属性以首字母大写，支持属性的级联查询，若当前类有符合条件的属性，则优先使用，而不使用级联属性，若需要使用级联属性，则属性之间使用 “_” 进行连接</p>
</li>
<li><p><a href="https://docs.spring.io/spring-data/jpa/docs/2.2.4.RELEASE/reference/html/#jpa.query-methods.query-creation">支持的关键字</a></p>
<table>
<thead>
<tr>
<th>Keyword</th>
<th>Sample</th>
<th>JPQL snippet</th>
</tr>
</thead>
<tbody><tr>
<td>And</td>
<td>findByLastnameAndFirstname</td>
<td>… where x.lastname = ?1 and x.firstname = ?2</td>
</tr>
<tr>
<td>Or</td>
<td>findByLastnameOrFirstname</td>
<td>… where x.lastname = ?1 or x.firstname = ?2</td>
</tr>
<tr>
<td><code>Is</code>, <code>Equals</code></td>
<td><code>findByFirstname</code>, <code>findByFirstnameIs</code>, <code>findByFirstNameEquals</code></td>
<td>… where x.firstname = ?1</td>
</tr>
<tr>
<td>Between</td>
<td>findByStartDateBetween</td>
<td>… where x.startDate between ?1 and ?2</td>
</tr>
<tr>
<td>LessThan</td>
<td>findByAgeLessThan</td>
<td>… where x.age &lt; ?1</td>
</tr>
<tr>
<td>LessThanEqual</td>
<td>findByAgeLessThanEqual</td>
<td>… where x.age &lt;= ?1</td>
</tr>
<tr>
<td>GreaterThan</td>
<td>findByAgeGreaterThan</td>
<td>… where x.age &gt; ?1</td>
</tr>
<tr>
<td>GreaterThanEqual</td>
<td>findByAgeGreaterThanEqual</td>
<td>… where x.age &gt;= ?1</td>
</tr>
<tr>
<td>After</td>
<td>findByStartDateAfter</td>
<td>… where x.startDate &gt; ?1</td>
</tr>
<tr>
<td>Before</td>
<td>findByStartDateBefore</td>
<td>… where x.startDate &lt; ?1</td>
</tr>
<tr>
<td><code>IsNull</code>, <code>Null</code></td>
<td>findByAge(Is)Null</td>
<td>… where x.age is null</td>
</tr>
<tr>
<td><code>IsNotNull</code>, <code>NotNull</code></td>
<td>findByAge(Is)NotNull</td>
<td>… where x.age not null</td>
</tr>
<tr>
<td>Like</td>
<td>findByFirstnameLike</td>
<td>… where x.firstname like ?1</td>
</tr>
<tr>
<td>NotLike</td>
<td>findByFirstnameNotLike</td>
<td>… where x.firstname not like ?1</td>
</tr>
<tr>
<td>StartingWith</td>
<td>findByFirstnameStartingWith</td>
<td><code>… where x.firstname like ?1</code> (parameter bound with appended <code>%</code>)</td>
</tr>
<tr>
<td>EndingWith</td>
<td>findByFirstnameEndingWith</td>
<td><code>… where x.firstname like ?1</code> (parameter bound with prepended <code>%</code>)</td>
</tr>
<tr>
<td>Containing</td>
<td>findByFirstnameContaining</td>
<td><code>… where x.firstname like ?1</code> (parameter bound wrapped in <code>%</code>)</td>
</tr>
<tr>
<td>OrderBy</td>
<td>findByAgeOrderByLastnameDesc</td>
<td>… where x.age = ?1 order by x.lastname desc</td>
</tr>
<tr>
<td>Not</td>
<td>findByLastnameNot</td>
<td>… where x.lastname &lt;&gt; ?1</td>
</tr>
<tr>
<td>In</td>
<td>findByAgeIn(Collection ages)</td>
<td>… where x.age in ?1</td>
</tr>
<tr>
<td>NotIn</td>
<td>findByAgeNotIn(Collection&lt;Age&gt; ages)</td>
<td>… where x.age not in ?1</td>
</tr>
<tr>
<td>True</td>
<td>findByActiveTrue()</td>
<td>… where x.active = true</td>
</tr>
<tr>
<td>False</td>
<td>findByActiveFalse()</td>
<td>… where x.active = false</td>
</tr>
<tr>
<td>IgnoreCase</td>
<td>findByFirstnameIgnoreCase</td>
<td>… where UPPER(x.firstame) = UPPER(?1)</td>
</tr>
</tbody></table>
</li>
</ol>
<hr>
<h5 id="查询方法解析流程"><a href="#查询方法解析流程" class="headerlink" title="查询方法解析流程"></a>查询方法解析流程</h5><ul>
<li>假如创建一个查询：findByUserDepUuid()，则框架在解析该方法时，首先剔除 findBy，然后对剩下的属性进行解析，假设查询实体为 Doc<ul>
<li>先判断 userDepUuid（根据 POJO 规范，首字母变小写）是否为查询实体的一个属性，如果是，则表示根据该属性进行查询。如果没有该属性，则进行下一步</li>
<li>从右往左截取地一个大写字母开头的字符串（此处为 Uuid ），然后检查剩下的字符串是否为查询实体的一个属性，如果是，则表示根据该属性进行查询，如果没有该属性，则重复本步骤，继续从右往左截取。最后假设 user 为查询实体的一个属性</li>
<li>接着处理剩下部分（ DepUuid ），先判断 user 所对应的类型是否有 depUuid 属性，如果有，则表示该方法最终是根据 “Doc.user.depUuid” 的取值进行查询，否则继续按照上一步的规则从右往左截取，最终表示根据 “Doc.user.dep.uuid” 的值进行查询</li>
<li>可能会存在一种特殊情况，假设 Doc 包含一个 user 的属性，也有一个 userDep 属性，此时会存在混淆。可以明确在属性之间加上 “_” 以显式表达意图</li>
</ul>
</li>
<li>还可以直接在方法的参数上加入分页或者排序的参数<ul>
<li>Page&lt;User&gt; findByName(String name, Pageable pageable)</li>
<li>List&lt;User&gt; findByName(String name, Sort sort)</li>
</ul>
</li>
</ul>
<hr>
<h5 id="使用-Query-注解"><a href="#使用-Query-注解" class="headerlink" title="使用 @Query 注解"></a>使用 @Query 注解</h5><ol>
<li>可以声明在 Repository 方法中，摆脱像命名查询那样的约束，将查询直接在相应的接口方法中声明，结构更清晰</li>
<li>索引参数<ul>
<li>形如 <code>?X</code>，索引值从 1 开始，查询中 <code>?X</code> 个数需要与方法定义的参数个数相一致，切顺序也需要一致</li>
</ul>
</li>
<li>命名参数<ul>
<li>形如 <code>:named</code>，可以定义好参数名，赋值时采用 @Param(“参数名”)，顺序无需一致</li>
</ul>
</li>
<li>若 @Query 注解中有 LIKE 关键字，则后面的参数可以直接加 <code>%</code>，这样在传递参数值时就可以不加</li>
<li>也可以使用 @Query 注解来指定本地查询，需要设置 nativeQuery 属性为 true</li>
</ol>
<hr>
<h5 id="Modifying-注解和事务"><a href="#Modifying-注解和事务" class="headerlink" title="@Modifying 注解和事务"></a>@Modifying 注解和事务</h5><ol>
<li>@Query 与 @Modifying 两个注解一起声明，可以自定义更新操作，当只涉及某些字段更新时最常用</li>
<li>方法的返回值应该是 int，表示更新语句所影响的行数</li>
<li>在调用的地方必须添加事务，没有事务无法正常执行</li>
<li>Spring Data 提供了默认的事务处理方式，即所有的查询均声明为只读事务</li>
<li>对于自定义的方法，如需改变 Spring Data 提供的事务默认方式，可以在方法上添加 @Transactional 注解</li>
<li>进行多个 Repository 操作时，也应该使它们在同一个事务中处理，按照 MVC 的思想，这部分属于 Service 层，因此，需要在 Service 层实现对多个 Repository 的调用，并在相应方法上声明事务</li>
</ol>
<hr>
<h5 id="CrudRepository-接口"><a href="#CrudRepository-接口" class="headerlink" title="CrudRepository 接口"></a>CrudRepository 接口</h5><ol>
<li>CrudRepository 接口提供了最基本的对实体类的增删改查操作<ul>
<li>&lt;S extends T&gt; S save(S entity)：保存单个实体</li>
<li>&lt;S extends T&gt; Iterable&lt;S&gt; saveAll(Iterable&lt;S&gt; entities)：保存集合（批量保存）</li>
<li>Optional&lt;T&gt; findById(ID id)：根据 id 查找实体</li>
<li>boolean existsById(ID id)：根据 id 判断实体是否存在</li>
<li>Iterable&lt;T&gt; findAll()：查询所有的实体（不建议使用）</li>
<li>Iterable&lt;T&gt; findAllById(Iterable&lt;ID&gt; ids)：根据给定的 id 集合查询实体</li>
<li>long count()：查询实体数量</li>
<li>void deleteById(ID id)：根据 id 删除实体</li>
<li>void delete(T entity)：删除一个实体</li>
<li>void deleteAll(Iterable&lt;? extends T&gt; entities)：删除给定实体集合</li>
<li>void deleteAll()：删除所有实体（不建议使用）</li>
</ul>
</li>
</ol>
<hr>
<h5 id="PagingAndSortingRepository-接口"><a href="#PagingAndSortingRepository-接口" class="headerlink" title="PagingAndSortingRepository 接口"></a>PagingAndSortingRepository 接口</h5><ol>
<li>该接口在 CrudRepository 接口的基础上提供了分页与排序的功能<ul>
<li>Iterable&lt;T&gt; findAll(Sort sort)：排序</li>
<li>Page&lt;T&gt; findAll(Pageable pageable)：分页（包含排序）</li>
</ul>
</li>
<li>Pageable 接口通常使用其实现类 PageRequest，其中封装了分页需要的信息。Sort 类封装了排序的信息。Sort 类构造器中的 Order 指的是具体针对某一个属性进行升序排序还是降序排序</li>
</ol>
<hr>
<h5 id="JpaRepository-接口"><a href="#JpaRepository-接口" class="headerlink" title="JpaRepository 接口"></a>JpaRepository 接口</h5><ol>
<li>该接口在 PagingAndSortingRepository 接口的基础上提供了 JPA 的相关功能<ul>
<li>void flush()：刷新缓存</li>
<li>&lt;S extends T&gt; S saveAndFlush(S entity)：类似于 JPA 的 merge() 方法</li>
<li>void deleteInBatch(Iterable&lt;T&gt; entities)：删除一个实体集合</li>
</ul>
</li>
</ol>
<hr>
<h5 id="JpaSpecificationExecutor-接口"><a href="#JpaSpecificationExecutor-接口" class="headerlink" title="JpaSpecificationExecutor 接口"></a>JpaSpecificationExecutor 接口</h5><ol>
<li><p>实现一组 JPA Criteria 查询相关的方法</p>
<p> <img src="JpaSpecificationExecutor_Function.png" alt="JpaSpecificationExecutor_Function"></p>
</li>
<li><p>Specification：封装 JPA Criteria 的查询条件，通常使用匿名内部类的方式来创建该接口的对象</p>
<ul>
<li>Predicate toPredicate(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder criteriaBuilder)<ul>
<li>root：代表查询的实体类</li>
<li>query：可以从中得到 Root 对象，即告知 JPA Criteria 查询要查询哪一个实体类，也可以用来添加查询条件，还可以结合 EntityManager 对象得到最终查询的 TypedQuery 对象</li>
<li>criteriaBuilder：用于创建 Criteria 相关对象的工厂，可以从中获取到 Predicate 对象</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h5 id="自定义-Repository-方法"><a href="#自定义-Repository-方法" class="headerlink" title="自定义 Repository 方法"></a>自定义 Repository 方法</h5><ol>
<li>为某一个 Repository 接口上添加自定义方法<ul>
<li>定义一个接口，声明自定义的方法</li>
<li>提供该自定义接口的实现类（并实现自定义接口中的方法），类名需要在自定义接口的名字的基础上加上 Impl</li>
<li>在 XxxRepository 接口上继承自定义的接口即可</li>
<li>注：默认情况下，Spring Data 会在 base-package 中查找 “自定义接口名Impl” 作为实现类，也可以通过 repository-impl-postfix 声明后缀</li>
</ul>
</li>
<li>为所有的 Repository 接口都添加自定义方法<ul>
<li>声明一个接口，在该接口中声明需要自定义的方法，且该接口需要继承 Spring Data 的 Repository 接口</li>
<li>提供上一步的接口的实现类，且继承 SimpleJpaRepository，并提供方法的实现</li>
<li>定义 JpaRepositoryFactoryBean 的实现类，使其生成第一步定义的接口实现类的对象</li>
<li>修改 &lt;jpa:repositories&gt; 节点的 factory-class 属性，使其指向自定义的 JpaRepositoryFactoryBean 的实现类的全类名</li>
<li>注意：全局的扩展实现类不要使用 Impl 作为后缀名。或者为全局扩展接口添加 @NoRepositoryBean 注解让 Spring Data 不认为它是一个 Repository</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>Spring Data</tag>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 注解驱动开发</title>
    <url>/Spring/Spring-%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h5 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器<a id="more"></a></h5><ol>
<li><h6 id="AnnotationConfigApplicationContext"><a href="#AnnotationConfigApplicationContext" class="headerlink" title="AnnotationConfigApplicationContext"></a>AnnotationConfigApplicationContext</h6><ul>
<li>配置类<ul>
<li>使用 @Configuration 注解修饰的类，作用等同于 Spring 的 Bean 配置文件</li>
</ul>
</li>
<li>包扫描<ul>
<li>使用 @ComponentScan 注解修饰配置类</li>
</ul>
</li>
</ul>
</li>
<li><h6 id="组件添加"><a href="#组件添加" class="headerlink" title="组件添加"></a>组件添加</h6><ul>
<li>@ComponentScan<ul>
<li>作用：扫描给定包中使用 @Controller、@Repository、@Service、@Component 等注解修饰的类，并将其注入 IOC 容器中（适用于自己编写的类）</li>
<li>value 属性和 basepackages 属性作用相同，都是指定要扫描的包</li>
<li>excludeFilters 属性指定一个 Filter 数组，这个 Filter 数组中指定的为按照什么规则排除哪些组件</li>
<li>includeFilters 属性指定一个 Filter 数组，这个 Filter 数组中指定的为只需要包含什么组件</li>
<li>useDefaultFilters 属性可以禁用默认的 Filter 来使 includeFilters 生效</li>
<li>过滤类型<ul>
<li>FilterType.ANNOTATION（默认）：按照注解</li>
<li>FilterType.ASSIGNABLE_TYPE：按照给定类型</li>
<li>FilterType.ASPECTJ：按照 AspectJ 表达式</li>
<li>FilterType.REGEX：按照正则表达式</li>
<li>FilterType.CUSTOM：按照自定义规则<ul>
<li>自定义规则需要使用 TypeFilter 接口并重写其中的 boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) 方法。match 方法的 metadataReader 参数为读取到的当前正在扫描的类的信息，metadataReaderFactory 参数为一个可以获取其他类信息的工厂</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>@Bean<ul>
<li>作用：向 IOC 容器中注册一个 Bean，类型为返回值的类型，id 默认使用方法名作为 id。若需要修改 id，可以修改方法名或者使用 @Bean 注解中的 value 属性（可用于导入第三方包内的类）</li>
<li>可以自定义初始化和销毁方法</li>
<li>初始化的其他方式<ul>
<li>InitializingBean 接口（初始化设置值之后）</li>
<li>DisposableBean 接口（销毁）</li>
<li>JSR250<ul>
<li>@PostConstruct：在 Bean 创建完成并且属性赋值完成，来执行初始化方法</li>
<li>@PreDestroy：在 IOC 容器销毁 Bean 之前通知进行清理</li>
</ul>
</li>
</ul>
</li>
<li>BeanPostProcessor 接口<ul>
<li>Bean 初始化前调用 postProcessBeforeInitialization 方法</li>
<li>Bean 初始化后调用 postProcessAfterInitialization 方法</li>
<li>原理：在调用 populateBean() 给 Bean 进行属性赋值之后开始初始化 Bean，初始化 Bean 首先遍历 IOC 容器中所有的 BeanPostProcessor 并执行其 postProcessBeforeInitialization() 方法（一旦某个 postProcessBeforeInitialization() 方法 返回 null，则在此之后的 BeanPostProcessor 不会被执行），然后执行自定义初始化方法，初始化完成后再执行 BeanPostProcessor 的 postProcessAfterInitialization() 方法</li>
</ul>
</li>
</ul>
</li>
<li>@Configuration<ul>
<li>作用：指定配置类</li>
</ul>
</li>
<li>@Component<ul>
<li>作用：声明一个基本组件</li>
<li>@Service、@Controller、@Repository 实际上与 @Component 注解没有区别，只是为了区分才将它们分离出来</li>
</ul>
</li>
<li>@Service<ul>
<li>作用：声明一个 Service 层组件</li>
</ul>
</li>
<li>@Controller<ul>
<li>作用：声明一个 Controller 层组件</li>
</ul>
</li>
<li>@Repository<ul>
<li>作用：声明一个 DAO 层组件</li>
</ul>
</li>
<li>@Conditional<ul>
<li>作用：按照一定的条件进行判断，满足条件才将 Bean 注入到 IOC 容器中</li>
<li>自定义的规则需要实现 org.springframework.context.annotation.Condition 接口。其中 match() 方法中的 ConditionContext 参数为判断条件能使用的上下文（环境），AnnotatedTypeMetadata 参数为注解信息</li>
<li>若 @Conditional 注解修饰类，则只有满足条件时这个类中配置的所有 Bean 才会注入到 IOC 容器中</li>
</ul>
</li>
<li>@Primary<ul>
<li>作用：让 Spring 在自动装配时默认首先使用 @Primary 注解修饰的 Bean</li>
</ul>
</li>
<li>@Lazy<ul>
<li>懒加载：不在 IOC 容器启动时创建对象，而是在第一次从 IOC 容器中获取 Bean 的时候才去创建对象并初始化</li>
<li>singleton 作用域的组件默认是在 IOC 容器启动时就创建对象，为了节省资源，可以使用懒加载的方式创建 singleton 作用域的 Bean</li>
</ul>
</li>
<li>@Scope<ul>
<li>作用：设置组件的作用域</li>
<li>取值<ul>
<li>prototype：多实例。只有在从 IOC 容器中获取对象时才创建</li>
<li>singleton（默认）：单实例。IOC 容器一启动就将对象注入至 IOC 容器中</li>
<li>request：同一次请求创建一个实例</li>
<li>session：同一个 session 创建一个实例</li>
</ul>
</li>
</ul>
</li>
<li>@Import<ul>
<li>作用：快速地向 IOC 容器中导入组件，id 默认为组件的全类名</li>
<li>也可以通过实现 ImportSelector 或 ImportBeanDefinitionRegistrar 接口来导入组件</li>
<li>ImportBeanDefinitionRegistrar 接口中的 registerBeanDefinitions 方法中的 AnnotationMetadata 参数为当前类的注解信息，BeanDefinitionRegistry 则为 Bean 定义的注册类，可用于自定义注册 Bean</li>
</ul>
</li>
<li>ImportSelector<ul>
<li>实现 ImportSelector 接口可以快速的导入多个组件，其中的 selectImports 方法的返回值为要导入到 IOC 容器中的组件的全类名，AnnotationMetadata 参数为当前标注 @Import 注解的类的所有注解信息</li>
</ul>
</li>
<li>工厂模式<ul>
<li>FactoryBean<ul>
<li>实现 FactoryBean 接口可以自定义的创建一个 Bean，其中 FactoryBean 向 IOC 容器中注入的默认为 getObject() 方法返回的实例</li>
<li>使用 &amp;beanName 获取 Factory 本身</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><h6 id="组件赋值"><a href="#组件赋值" class="headerlink" title="组件赋值"></a>组件赋值</h6><ul>
<li><p>@Value</p>
<ul>
<li>作用：为 Bean 属性赋值</li>
<li>支持的格式<ul>
<li>基本数值</li>
<li>SpEL</li>
<li>取出配置文件中的值（使用 ${}）</li>
</ul>
</li>
</ul>
</li>
<li><p>@Autowired</p>
<ul>
<li>作用：自动装配，默认优先按照类型去 IOC 容器中去找相应的组件（ byType ），若有多个类型相同的组件，则按照属性的名称组为组件的 id 去 IOC 容器中查找（ byName ），若 IOC 容器中没有这个 Bean 则会抛出异常（可以设置 required 属性）</li>
<li>原理：通过 AutowiredAnnotationBeanPostProcessor 进行自动装配</li>
<li>@Qualifier<ul>
<li>作用：明确指定需要装配的组件的 id，而不是使用属性名</li>
</ul>
</li>
<li>其他方式<ul>
<li>@Resources（ JSR250 ）<ul>
<li>作用同 @Autowired 注解，不同的是默认使用名称查找（ byName ），可以通过指定 name 属性来指定装配的 Bean</li>
</ul>
</li>
<li>@Inject（ JSR330，需要导入 javax.inject ）</li>
</ul>
</li>
<li>注：使用@Lookup 注解可以解决在一个单例 Bean 中引用一个原型 Bean 时，该原型 Bean 变相变成单例 Bean 的问题，还有一种解决方法就是在单例 Bean 中重复从 IOC 容器中获取原型 Bean</li>
</ul>
</li>
<li><p>@PropertySource</p>
<ul>
<li>作用：加载外部配置文件（配置文件中的值都会被加载到运行时环境中）</li>
</ul>
</li>
<li><p>@PropertySources</p>
<ul>
<li>作用：加载多个外部配置文件</li>
</ul>
</li>
<li><p>@Profile</p>
<ul>
<li><p>作用：Spring 提供的可以根据当前环境，动态的激活和切换一系列组件的功能。@Profile 注解可以指定组件在哪个环境下才能被注入到 IOC 容器中，不指定，则任何环境下都可以注册这个组件</p>
</li>
<li><p>默认为 default 环境</p>
</li>
<li><p>使用 Environment 设置需要激活的环境</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个 ApplicationContext(需要使用无参构造器)</span></span><br><span class="line">AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 设置需要激活的环境</span></span><br><span class="line">applicationContext.getEnvironment().setActiveProfiles(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;dev&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 注册配置类</span></span><br><span class="line">applicationContext.register(MainConfig.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 刷新容器</span></span><br><span class="line">applicationContext.refresh();</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用命令行动态参数：在虚拟机参数位置加载 -Dspring.profiles.active=test</p>
</li>
</ul>
</li>
</ul>
</li>
<li><h6 id="组件注入"><a href="#组件注入" class="headerlink" title="组件注入"></a>组件注入</h6><ul>
<li>方法参数<ul>
<li>@Bean 注解 + 方法参数，参数从容器中获取</li>
</ul>
</li>
<li>构造器注入<ul>
<li>使用 @Autowired 注解修饰构造器。如果组件只有一个有参构造器，这个有参构造器的 @Autowired 注解可以省略，参数位置的组件还是可以自动从 IOC 容器中获取</li>
</ul>
</li>
<li>xxxAware 接口<ul>
<li>自定义组件想要使用 Spring IOC 容器底层的一些组件，需要实现 xxxAware 接口</li>
<li>例如 ApplicationContextAware 接口，它使用 ApplicationContextAwareProcessor 后置处理器来将 ApplicationContext 注入到实现 ApplicationContextAware 接口的组件中</li>
</ul>
</li>
</ul>
</li>
<li><h6 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h6><ul>
<li>AOP 是指在程序运行期间动态的将某段代码切入到指定方法指定位置进行运行的编程方式，本质是动态代理</li>
</ul>
</li>
</ol>
<ul>
<li><p>@EnableAspectJAutoProxy</p>
<pre><code>  - 作用：开启基于注解的 AOP 模式，等同于配置文件的 \&lt;aop:aspectj-autoproxy\&gt;\&lt;/aop:aspectj-autoproxy\&gt;</code></pre>
<ul>
<li><p>@Before/@After/@AfterReturning/@AfterThrowing/@Around（用法见 Spring ）</p>
</li>
<li><p>@Pointcut（用法见 Spring ）</p>
</li>
<li><p>使用 Spring AOP 的步骤</p>
<ul>
<li>将业务逻辑组件和切面类都加入到容器中，告诉 Spring 哪个是切面类（使用 @Aspect 注解修饰的类）</li>
<li>在切面类上的每个通知方法上标注通知注解，告诉 Spring 何时何地运行（切入点表达式）</li>
<li>开启基于注解的 AOP 模式（ @EnableAspectJAutoproxy ）</li>
</ul>
</li>
<li><p>@EnableAspectJAutoProxy 注解原理</p>
<ul>
<li><p>使用 @Import 注解将 AspectJAutoProxyRegistrar 配置类注入 IOC 容器，然后通过 AspectJAutoProxyRegistrar 调用 AopConfigUtils 来注册代理生成器  AnnotationAwareAspectJAutoProxyCreator</p>
<blockquote>
<p><a href="https://juejin.im/post/5bf8a505f265da61682b0918#heading-16">@AspectJ 注解运行机制详解</a></p>
<p><a href="https://www.javadoop.com/post/spring-ioc">Spring IOC 容器源码分析</a></p>
<p><a href="https://www.javadoop.com/post/spring-aop-source">Spring AOP 源码解析</a></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="6">
<li><h6 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h6><ul>
<li>@EnableTransactionManagement<ul>
<li>作用：开启基于注解的事务管理功能</li>
</ul>
</li>
<li>@Transactional<ul>
<li>作用：为标注的方法或者类添加事务（标注在类上仅作用于该类的所有 public 方法）</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h5 id="扩展原理"><a href="#扩展原理" class="headerlink" title="扩展原理"></a>扩展原理</h5><ol>
<li><h6 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h6><ul>
<li>Spring 容器标准初始化之后执行（ BeanPostProcessor 之前），此时 Bean 还未创建</li>
<li>Spring 容器初始化两大步<ul>
<li>加载保存和读取所有 Bean 配置</li>
<li>按照之前的配置创建 Bean</li>
</ul>
</li>
</ul>
</li>
<li><h6 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a>BeanDefinitionRegistryPostProcessor</h6><ul>
<li>BeanFactoryPostProcessor 子类，可自定义添加 Bean 定义</li>
<li>BeanDefinetionRegistry<ul>
<li>BeanDefinetionBuilder</li>
</ul>
</li>
</ul>
</li>
<li><h6 id="ApplicationListner"><a href="#ApplicationListner" class="headerlink" title="ApplicationListner"></a>ApplicationListner</h6><ul>
<li>@EventListener</li>
</ul>
</li>
<li><h6 id="Spring-容器创建过程"><a href="#Spring-容器创建过程" class="headerlink" title="Spring 容器创建过程"></a>Spring 容器创建过程</h6></li>
</ol>
<hr>
<h5 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h5><ol>
<li><h6 id="Servlet-3-0"><a href="#Servlet-3-0" class="headerlink" title="Servlet 3.0"></a>Servlet 3.0</h6><ul>
<li>ServletContainerInitializer</li>
<li>Registration<ul>
<li>ServletRegistration</li>
<li>FilterRegistration</li>
</ul>
</li>
</ul>
</li>
<li><h6 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h6><ul>
<li>Servlet 3.0 异步处理<ul>
<li>在Servlet 3.0之前，Servlet采用Thread-Per-Request的方式处理请求。<br>  即每一次Http请求都由某一个线程从头到尾负责处理。如果一个请求需要进行IO操作，比如访问数据库、调用第三方服务接口等，那么其所对应的线程将同步地等待IO操作完成， 而IO操作是非常慢的，所以此时的线程并不能及时地释放回线程池以供后续使用，在并发量越来越大的情况下，这将带来严重的性能问题。即便是像Spring、Struts这样的高层框架也脱离不了这样的桎梏，因为他们都是建立在Servlet之上的。为了解决这样的问题，Servlet 3.0引入了异步处理，然后在Servlet 3.1中又引入了非阻塞IO来进一步增强异步处理的性能。</li>
</ul>
</li>
<li>返回 Callable</li>
<li>返回 DeferredResult</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>みんなの日本語（七）</title>
    <url>/%E6%97%A5%E8%AF%AD/%E3%81%BF%E3%82%93%E3%81%AA%E3%81%AE%E6%97%A5%E6%9C%AC%E8%AA%9E%EF%BC%88%E4%B8%83%EF%BC%89/</url>
    <content><![CDATA[<center><strong><span style="font-size: 22px;">文法记录与总结</span></strong></center>

<h4 id="第四十一课"><a href="#第四十一课" class="headerlink" title="第四十一课"></a>第四十一课</h4><a id="more"></a>

<ol>
<li><p><strong>授受表达方式</strong></p>
<p> 本课学习反映<strong>给予者和接受者之间关系</strong>的授受表达方式。</p>
<ul>
<li><p><strong>名词1（人） + に + 名词2 + をいただきます（表示 “<em>从上司 / 长辈那获得了某物</em>”）</strong></p>
<p>  <strong>说话人从上司或长辈（名词1）那里接受物品（名词2）</strong>时，不用「もらいます」，而是使用其谦逊语「いただきます」。</p>
<p>  例如：「私は社長にお土産をいただきました。」我得到了社长赠送的礼品。</p>
</li>
<li><p><strong>[私に] 名词 + をくださいます（表示 “<em>上司 / 长辈给我某物</em>”）</strong></p>
<p>  <strong>上司或长辈给予说话人物品</strong>时，不用「くれます」，而是使用其尊敬语「くださいます」。</p>
<p>  <strong><em>注意：接受者是说话人的家属时也可以使用「くださいます」和「いただきます」。</em></strong></p>
<p>  例如：「社長が私にお土産をくださいました。」社长送了礼物给我。</p>
</li>
<li><p><strong>名词1 + に + 名词2 + を + { やります / あげます / さしあげます }（表示 “<em>我给部下 / 晚辈某物</em>”）</strong></p>
<p>  说话人给部下、晚辈以及动植物（名词1）物品（名词2）时，使用「やります / あげます」。</p>
<p>  <strong><em>注意：部下 / 晚辈等一般可以使用「あげます」或 「やります」；而动植物则使用「やります」；上司 / 长辈等则使用「さしあげます」（不过这个也不常用）。</em></strong></p>
<p>  例如：「私は猫に魚をやりました。」我给猫喂了鱼。</p>
</li>
</ul>
</li>
<li><p><strong>行为的授受</strong></p>
<p> 表示行为的授受时，使用「いただきます（もらいます 的自谦体）」「くださいます（くれます 的尊敬语）」「やります」。</p>
<ul>
<li><p><strong>动词 て形 + いただきます（表示 “<em>请长辈 / 上司为我做某事</em>”）</strong></p>
<p>  例如：「私は課長に手紙の間違いを直していただきました。」我请科长给我改了信上的错误。</p>
</li>
<li><p><strong>动词 て形 + くださいます（表示 “<em>上司 / 长辈给我做某事</em>”）</strong></p>
<p>  例如：「部長の奥さんが [私に] お茶を教えてくださいました。」部长的夫人教我茶道了。</p>
</li>
<li><p><strong>动词 て形 + やります/あげます（表示 “我给部下 / 晚辈做某事。”）</strong></p>
<p>  例如：「私は息子に紙飛行機を作ってやりました / あげました。」我给孩子做了架纸飞机。</p>
</li>
</ul>
</li>
<li><p><strong>动词 て形 + <span style="color: red;">くださいませんか</span></strong></p>
<p> 这是比「〜てください」<strong>更为礼貌</strong>的请求表达方式。但是比「〜ていただけませんか」的礼貌程度低一些。</p>
<p> <strong><em>也就是说从礼貌的程度来说，「〜いただけませんか」最高，「〜てください」最低，「〜でくださいませんか」处于两者之间，即中等。</em></strong></p>
<p> 例如：</p>
<p> 「コピー機の使い方を教え<span style="color: red;">てくださいませんか</span>。」能教我一下复印机的用法吗？</p>
<p> 「コピー機の使い方を教え<span style="color: red;">ていただけませんか</span>。」能请您教我一下复印机的用法吗？</p>
</li>
<li><p><strong>名词 + <span style="color: red;">に</span> + 动词</strong></p>
<p> 助词「に」可以表示 “<strong>作为······的证明”、“作为······的纪念</strong>” 的意思。</p>
<p> 例如：「田中さんが結婚祝いにこのお皿をくださいました。」田中送给了我这个盘子作为结婚纪念品。</p>
</li>
</ol>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>本课在之前所学的授受动词的基础上增加了<strong>授受对象</strong>的说明，如若是长辈、上司等则应当使用自谦体或谦逊语，以及学习了一个中等礼貌程度表示 “请某人做某事” 的表达方式。</p>
<hr>
<h4 id="第四十二课"><a href="#第四十二课" class="headerlink" title="第四十二课"></a>第四十二课</h4><ol>
<li><p><strong>{ 动词字典形 / 名词 <span style="color: red;">の</span> } + ために、〜（表示 “<em>为了～</em>”）</strong></p>
<p> 「ために」<strong>表示目的</strong>。「名词 のために」也可以表示 “<strong>为了某种利益</strong>” 的意思。</p>
<p> <strong><em>「〜ように」与「ために」的区别：</em></strong></p>
<ul>
<li>「〜ように」之前要使用<strong>非意志动词的字典形或动词的否定形</strong>。表示以<strong>能接近做某一件事的水平</strong>而做某事。</li>
<li>「ために」之前使用<strong>意志动词的字典形</strong>。表示自己<strong>有意识地</strong>以某一件事为目的，为了实现这一目的而做某事。</li>
</ul>
<p> <strong><em>注意：「なります」既有意志动词也有非意志动词的用法。</em></strong></p>
<p> 例如：「新しいパソコンを買うために、貯金しています。」为了能买新电脑，正在存钱。</p>
<p> <strong><em>注意：非意志动词大概包括以下几类：</em></strong></p>
<ul>
<li>自然现象。例如「雨が降ります」</li>
<li>植物成长变化。例如「花が咲きます」</li>
<li>生理现象。例如「生まれます」</li>
<li>心理活动。例如「びっくりします」「驚きます」</li>
<li>可能动词。例如「見えます」</li>
<li>物理变化。例如「壊れます」</li>
</ul>
</li>
<li><p><strong>{ 动词字典形 の / 名词 } + に〜</strong></p>
<p> 这个句型与「使います」「いいです」「便利です」「役に立ちます」「時間 / お金 [が] かかります」等一起使用，表示<strong>用途和目的</strong>。</p>
<p> 例如：「この鋏は花を切るのに使います。」这把剪刀是用来剪花的。</p>
</li>
<li><p><strong>数量词 + { は / も }</strong></p>
<p> 助词「は」接在数量词之后，表示<strong>说话人所估算的最小限度</strong>。</p>
<p> 助词「も」接在数量词之后，表示<strong>说话人觉得那个数量很大</strong>。</p>
<p> 例如：</p>
<p> 「私はボーナスの半分は貯金するつもりです。」我打算把奖金的一半存起来。</p>
<p> ······「えっ、半分も貯金するんですか。」啊，一半都存起来？</p>
</li>
<li><p><strong><span style="color: red;">〜によって</span></strong></p>
<p> 表示<strong>创造和发现</strong>的动词（例如「書く」「発明する」「発見する」等）用作被动时，行为者不使用助词「に」来表示，而是<strong>使用「〜によって」来表示</strong>。</p>
<p> 例如：「源氏物語は紫式部によって書かれました。」源氏物语是紫式部写的。</p>
</li>
</ol>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>本课学习了一个表示目的的语法以及助词「に」的表示用途和目的的用法，需要注意的是「ために」与「〜ように」的区别。</p>
<hr>
<h4 id="第四十三课"><a href="#第四十三课" class="headerlink" title="第四十三课"></a>第四十三课</h4><ol>
<li><p><strong>〜そうです（表示 “<em>看起来好像······</em>”，即 「様態」）</strong></p>
<ul>
<li><p><span style="color: red;">动词 ます形 + そうです</span></p>
<p>  表示<strong>有将要发生某动作或变化的征兆</strong>。可以和<strong>表示动作或变化发生时期的副词</strong>「今にも」「もうすぐ」「これから」等一起使用。</p>
<p>  例如：「今にも雨が降りそうです。」好像马上就要下雨了。</p>
</li>
<li><p><span style="color: red;">{ い 形容词（～<s>い</s>） / な 形容词（<s>だ</s>） } + そうです</span></p>
<p>  表示<strong>没有实际加以确认</strong>，而<strong>只是从外观上就其性质进行推测</strong>。</p>
<p>  例如：「彼女は頭がよさそうです。」她好像很聪明。</p>
<p>  <strong><em>注意：表示他人的感情时，不能直接使用表示感情的形容词（如「嬉しい」「悲しい」「寂しい」等），而要在后面接续「そうです」，使用这种从外观上进行推测的说法。</em></strong></p>
<p>  例如：</p>
<p>  「嬉しそうですね。」你看起来很高兴啊。</p>
<p>  ······「ええ、実は昨日結婚を申し込まれたんです。」是啊，其实昨天有人向我求婚了。</p>
<p>  <strong><em>注意：特殊的：「いい」=&gt; 「よさ」；「ない」=&gt;「なさ」。</em></strong></p>
</li>
</ul>
</li>
<li><p><strong>动词 て形 + 来ます</strong></p>
<ul>
<li><p><span style="color: red;">动词 て形 + 来ます</span></p>
<p>  这个句型表示 ”<strong>去某个场所，做了某件事之后再返回来</strong>“ 的意思。</p>
<p>  进行「动词 て形」的动作的场所要用 助词「で」来表示，但是如果将某场所作为物品出处（即起点）时，需要使用「から」来表示。</p>
<p>  与「から」一起使用的动词有「取って来ます」「持って来ます」「運んで来ます」等。</p>
<p>  例如：</p>
<p>  「スーパーで牛乳を買って来ます。」去超市买牛奶回来。</p>
<p>  「台所からコップを取って来ます。」去厨房拿个杯子来。</p>
</li>
<li><p><span style="color: red;">名词（场所） + へ行って来ます</span></p>
<p>  表示去某处之后再回来的意思，<strong>在不需要特意说明要在去的地方做些什么事时使用</strong>。</p>
<p>  例如：「郵便局へ行って来ます。」我去趟邮局就回来。</p>
</li>
<li><p><span style="color: red;">出かけて来ます</span></p>
<p>  表示去某处之后再回来的意思，<strong>在不需要特意说明所去的地方以及去的目的时使用</strong>。</p>
<p>  例如：「ちょっと出かけて来ます。」我出去一下就回来。</p>
</li>
</ul>
</li>
<li><p><strong>动词 て形 + くれませんか</strong></p>
<p> 这个表达方式<strong>适合对自己的同辈以及晚辈、下级</strong>使用。比「〜てください」更为礼貌，但是没有「〜てくださいませんか」和「〜ていただけませんか」的礼貌程度高。</p>
<p> 例如：</p>
<p> 「コンビニへ行って来ます。」我去趟便利店就回来。</p>
<p> ······「じゃ、お弁当を買って来てくれませんか。」那能帮我买个便当回来吗。</p>
<p> 目前为止<strong>礼貌程度由高到低</strong>的表达方式：</p>
<ul>
<li>〜ていただけませんか</li>
<li>〜てくださいませんか</li>
<li>〜てくれませんか</li>
<li>〜てください</li>
</ul>
</li>
</ol>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p>本课新学了一种表示请做某事的表达方式，并且学习了「〜そうです」的表示 ”看起来好像······“ 的用法，以及「〜て来ます」的用法。</p>
<hr>
<h4 id="第四十四课"><a href="#第四十四课" class="headerlink" title="第四十四课"></a>第四十四课</h4><ol>
<li><p><strong>{ 动词 ます形 / い 形容词（～<s>い</s>） / な 形容词 [<s>な</s>] } + すぎます</strong></p>
<p> 表示<strong>某种行为或状态的程度超过了限度</strong>。一般这种行为或状态<strong>并不让人感觉良好</strong>。</p>
<p> <strong><em>注意：「〜すぎます」作为 II 类动词活用。形容词的变化可以简单记为「形容词词干 + すぎます」。</em></strong></p>
<p> 例如：「いくら好きでも、飲みすぎると、体に悪いですよ。」不管多爱喝酒，喝得太多的话，对身体也没有好处。</p>
</li>
<li><p><strong>动词 ます形 + { やすいです / にくいです }</strong></p>
<ul>
<li><p>若为<strong>表示意志的动词</strong>时，后接「〜やすい」表示那个<strong>动作很容易</strong>，后接「〜にくい」表示那个<strong>动作很难</strong>。</p>
<p>  例如：「このパソコンは使いやすいです。」这台电脑很好用。</p>
</li>
<li><p>若为<strong>非意志动词</strong>时，后接「〜やすい」表示那个<strong>动作很容易发生</strong>，后接「〜にくい」表示那个<strong>动作很难发生</strong>。</p>
<p>  例如：「雨の日は洗濯物が乾きにくいです。」下雨天洗东西不容易干。</p>
</li>
</ul>
<p> <strong><em>注意：「〜やすい」「〜にくい」的活用同「イ 形容词」。</em></strong></p>
</li>
<li><p><strong>名词1 + を + { い 形容词（～<s>い</s> =&gt; 〜く） / な 形容词 [<s>な</s>] =&gt; ～に / 名词2 に } + します</strong></p>
<p> 之前学过的<span style="color: red;">「〜く / 〜になる」</span>表示主体自身发生变化，而<span style="color: red;">「〜く / 〜にする」</span>则表示某人使某对象（名词1）发生变化。</p>
<p> 例如：「音を大きくします。」把声音调大。</p>
</li>
<li><p><strong>名词 + <span style="color: red;">に</span> + します</strong></p>
<p> <strong>表示选择和决定</strong>。</p>
<p> 例如：「会議は明日にします。」会议明天开。</p>
</li>
</ol>
<h5 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h5><p>本课学习了超过限度的表达方式「〜すぎます」以及「〜やすい / 〜にくい」的使用方式。需要注意的是「〜やすい / 〜にくい」有两种意思，并且实际上都很微妙。还有就是「〜く / 〜になる」与「〜く / 〜にする」的区别。</p>
<hr>
<h4 id="第四十五课"><a href="#第四十五课" class="headerlink" title="第四十五课"></a>第四十五课</h4><ol>
<li><p><strong>{ 动词字典形 / 动词 ない形 / 动词 た形 / い 形容词（～い） / な 形容词 な / 名词 の } + 場合は、〜</strong></p>
<p> 由于「場合」是一个名词，所以<strong>接续方法与名词一致</strong>。<strong>「～場合」是假设发生某种状况的表达方式，后续句子表示其对策或该状况发生后会带来的结果</strong>。</p>
<p> 例如：「会議に間に合わない場合は、連絡してください。」如果赶不上开会的话，请联系一下。</p>
</li>
<li><p><strong>{ 动词普通形 / い 形容词普通形 / な 形容词普通形（〜<s>だ</s> =&gt; 〜な） / 名词普通形 （〜<s>だ</s> =&gt; 〜な） } + のに、〜</strong></p>
<p> 「〜のに」表示<strong>后半句所述的事情与前半句中原本预想的不同</strong>。常用来表示<strong>不满或意外</strong>的心情。可以理解为是一种逆接。这里的接续实际上是「の」的接续，比如前面学过的「〜ので」「〜のだ（口语为「〜んだ」）」。</p>
<p> <strong><em>注意：表达的心情不一定是不好的心情。</em></strong></p>
<p> 例如：</p>
<p> 「冬なのに、桜が咲いています。」明明是冬天，樱花却开着。</p>
<p> 「約束をしたのに、彼女は来ませんでした。」事先约好了，可她却没来。</p>
<p> <strong><em>注意两个区别：</em></strong></p>
<ul>
<li><p>「〜のに」和「〜が」</p>
<p>  「〜が」给人一种只是在<strong>平淡地叙述一件事情的感觉</strong>，无法像「〜のに」那样<strong>表达说话人意外或不满的心情</strong>。</p>
</li>
<li><p>「〜のに」和「〜ても」</p>
<p>  「〜ても」用于表示一种<strong>假设</strong>，假设前句所说的事发生了，然后怎么怎么样，而「〜のに」表达的是<strong>说话人对已经发生的事情的一种意外或不满的心情</strong>。</p>
</li>
</ul>
</li>
</ol>
<h5 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h5><p>本课学了两个句型，第一个句型需要注意的是由于「場合」是名词，所以前面的接续只要名词能接的都可以接；第二个句型需要注意的是对表示不满或者意外心情的事情是已经发生过的。</p>
]]></content>
      <categories>
        <category>日语</category>
      </categories>
      <tags>
        <tag>日语</tag>
        <tag>语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>みんなの日本語（三）</title>
    <url>/%E6%97%A5%E8%AF%AD/%E3%81%BF%E3%82%93%E3%81%AA%E3%81%AE%E6%97%A5%E6%9C%AC%E8%AA%9E%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<center><strong><span style="font-size: 22px;">文法记录与总结</span></strong></center>

<h4 id="第二十一课"><a href="#第二十一课" class="headerlink" title="第二十一课"></a>第二十一课</h4><a id="more"></a>

<ol>
<li><p><strong>普通形 + <span style="color: red;">と</span> + 思います（表示 “<em>我想······</em>”）</strong></p>
<p> 思考、判断的内容用<strong>助词「と」</strong>来表示。</p>
<ul>
<li><p><strong>表示推测</strong></p>
<p>  例如：「明日雨が降ると思います。」我想明天会下雨。</p>
<p>  当推测的内容为否定时，将助词「と」前的句子变为否定形即可。</p>
<p>  例如：「明日雨が降らないと思います。」我想明天不下雨。</p>
</li>
<li><p><strong>阐述意见</strong></p>
<p>  例如：「上海は物価が高いと思います。」我觉得上海的物价很高。</p>
<p>  在对别人的意见表示同意时可以使用：</p>
<p>  「私もそう思います。」我也觉得。</p>
</li>
<li><p><strong>「〜についてどう思いますか。」</strong></p>
<p>  在征询对方对某一事物的意见时，使用这个句型。</p>
<p>  <strong><em>注意：「どう」的后面不需要加助词「と」！</em></strong></p>
<p>  例如：</p>
<p>  「新しい空港についてどう思いますか。」你觉得新机场怎么样？</p>
<p>  ······「きれいですが、ちょっと交通が不便だと思います。」很漂亮，但是交通有点不太方便。</p>
</li>
</ul>
</li>
<li><p><strong>{ 普通形 / “句子” } + <span style="color: red;">と</span> + 言います（表示 “<em>说······</em>”）</strong></p>
<p> 这个句型用于引用别人说的话，引用的说的内容使用<strong>助词「と」</strong>来表示。用法有直接引用与间接引用两种。</p>
<ul>
<li><p>直接引用</p>
<p>  直接引用时，直接将引用的话照搬过来即可。书写时注意将其使用「」括起来。</p>
<p>  例如：「寝る前に、「お休みなさい」と言います。」睡觉前说 “晚安”。</p>
</li>
<li><p>间接引用</p>
<p>  引用的人将引用的内容加以概括之后再说出来时，在助词「と」的前面使用普通形。引用部分的时态不受主句时态影响。另外，<strong>说话的对象用助词「に」</strong>来表示。</p>
<p>  例如：</p>
<p>  「ミラーさんは上海へ出張すると言いました。」米勒说他下星期去上海出差。</p>
<p>  「姉に留学したいと言いました。」我对姐姐说了想去留学。</p>
</li>
</ul>
</li>
<li><p><strong>{ 动词 / い 形容词 / な 形容词 / 名词 } 普通形 + でしょう？（表示 “<em>······吧？</em>”）</strong></p>
<p> <strong>在想要得到听话人同意，进行询问或确认时</strong>使用这个句型，「でしょう」用升调的语气。</p>
<p> 「でしょう」的前面使用普通形。</p>
<p> <strong><em>注意：名词与「な 形容词」使用去掉「だ」的形式。</em></strong></p>
<p> 例如：</p>
<p> 「明日パーティーに行くでしょう？」明天你要去参加晚会对吧？</p>
<p> ······「ええ、行きます。」对，要去。</p>
</li>
<li><p><strong>名词1 （场所）+ <span style="color: red;">で</span> + 名词2 + <span style="color: red;">が</span> + あります</strong></p>
<p> 当名词2 是<strong>晚会</strong>、<strong>音乐会</strong>、<strong>节庆活动</strong>或<strong>事件</strong>、<strong>灾害</strong>、<strong>变故</strong>等时，「あります」表示<strong>举行</strong>、<strong>发生</strong>的意思。</p>
<p> 例如：「大阪で天神祭があります。」在大阪举办天神祭。</p>
</li>
<li><p><strong>名词（场面）+ <span style="color: red;">で</span></strong></p>
<p> 事情发生的场所用<strong>助词「で」</strong>表示。</p>
<p> 例如：「ディズニーランドで彼女にプレゼントをあげました。」在迪士尼乐园送了礼物给女朋友。</p>
</li>
<li><p><strong>名词 + <span style="color: red;">でも</span> + 动词</strong></p>
<p> 在劝诱或建议某事时，提出某一示例但不限于这一示例时，用<strong>助词「でも」</strong>。</p>
<p> 例如：「ちょっとビールでも飲みませんか。」喝点啤酒什么的吗？</p>
</li>
<li><p><strong>动词 ない 形 + <span style="color: red;">ないと</span>······</strong></p>
<p> 这个句型的原型为「动词ない形 ないと いけません」，省略了「いけません」。「动词ない形 ないと いけません」的意思与「动词ない形 なければ なりません」大致相同。</p>
<p> 例如：「もう帰らないと······」再不回去就······</p>
</li>
</ol>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>本课主要学习的是对普通形用法的扩展。</p>
<hr>
<h4 id="第二十二课"><a href="#第二十二课" class="headerlink" title="第二十二课"></a>第二十二课</h4><ol>
<li><p><strong>名词修饰句节</strong></p>
<p> 用来修饰名词的词汇或者句节等都放在<strong>被修饰的名词之前</strong>。</p>
<ul>
<li><p>用来修饰名词的句节中的<strong>动词、形容词和名词使用普通形</strong>。<strong>「な 形容词」使用「〜な」，名词用「〜の」</strong>。</p>
<p>  例如：</p>
<p>  「東京へ行く人」去东京的人</p>
<p>  「東京へ行かない人」不去东京的人</p>
<p>  「東京へ行った人」去了东京的人</p>
<p>  「東京へ行かなかった人」没去东京的人</p>
</li>
<li><p>用来修饰名词的句节可以使用如下各种句型。</p>
<p>  「これは私が<span style="color: red;">住んでいたうち</span>です。」这是我住过的房子。</p>
<p>  「私が<span style="color: red;">住んでいたうち</span>は古いです。」我住过的房子很旧。</p>
<p>  「リンさんが<span style="color: red;">住んでいたうち</span>を買いました。」买下来林住过的房子。</p>
<p>  「私はリンさんが<span style="color: red;">住んでいたうち</span>が嫌いです。」我讨厌林住过的房子。</p>
<p>  「私が<span style="color: red;">住んでいたうち</span>に猫がいました。」我住过的房子里有过一只猫。</p>
<p>  「リンさんが<span style="color: red;">住んでいたうち</span>へ行ったことがあります。」我去过林住过的房子。</p>
</li>
<li><p>用来修饰名词的句节中的主语使用<strong>助词「が」</strong>来表示。</p>
<p>  例如：「これ<span style="color: red;">は</span>私<span style="color: red;">が</span>作ったケーキです。」这是我做的蛋糕。</p>
</li>
</ul>
</li>
<li><p><strong>动词字典形 + { 時間 / 約束 / 用事 }</strong></p>
<p> 在说明做某件事的时间以及约定、事情的内容时，把要做的事情和要说明的内容变为字典形放在「時間」「約束」「用事」等名词之前。</p>
<p> 例如：「私は友達と映画を見る約束があります。」我和朋友约好去看电影。</p>
</li>
<li><p><strong>动词 ます形 + ましょうか（表示 “<em>······吧</em>”）</strong></p>
<p> 之前学过的「ましょうか」的用法为说话人提出要为对方做某事。</p>
<p> 本课所学的用法为，说话人提议听话人和自己一起去做某事。</p>
<p> 例如：「明日公園へ行きましょうか。」明天一起去公园吧。</p>
</li>
</ol>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>本课的主要重点是使用句节来修饰名词，以及在「時間」「約束」「用事」这三个名词前若需要说明做某件事的时间、约定、事情的内容时，将要做的事和要说明的内容变为字典形放在它们之前。</p>
<hr>
<h4 id="第二十三课"><a href="#第二十三课" class="headerlink" title="第二十三课"></a>第二十三课</h4><ol>
<li><p><strong>{ <span style="color: red;">动词字典形</span> / <span style="color: red;">动词ない形 ない</span> / <span style="color: red;">い形容词（～い）</span> / <span style="color: red;">な形容词（～な）</span> / <span style="color: red;">名词の</span> } + とき、～（主句）（表示 “<em>······时、······的时候</em>”）</strong></p>
<p> 「とき」表示其后面接续的主句所表示的<strong>状态</strong>、<strong>动作</strong>以及<strong>现象成立的时间</strong>。「とき」前面内容的形态与它们修饰名词时的形态相同。<strong>修饰「とき」的句节的时态不受主句时态的影响</strong>。</p>
<p> 例如：「図書館で本を借りるとき、カードが要ります。」在图书馆借书的时候，需要借书卡。</p>
</li>
<li><p><strong>{ 动词字典形 / 动词た形 } + とき、～（主句）（表示 “<em>······时、······的时候</em>”）</strong></p>
<p> 「とき」前面的动词是<strong>字典形</strong>时，表示主句的动作<strong>先于</strong>「〜とき」发生。</p>
<p> 「とき」前面的动词是<strong>た形</strong>时，表示主句的动作<strong>后于</strong>「〜とき」发生。</p>
<p> 例如：</p>
<p> 「パリへ行くとき、鞄を買いました。」去巴黎时，买了个包。</p>
<p> 「パリへ行ったとき、鞄を買いました。」去巴黎时，在那儿买了个包。</p>
<p> 第一句中，买包是在到巴黎之前，也就是说实在去巴黎的路上的某个地方买的；而第二句中，包是在到达巴黎之后，也就是说是在巴黎买的。</p>
</li>
<li><p><strong>动词字典形 + <span style="color: red;">と</span>、～（主句）（表示 “<em>一······就······</em>”）</strong></p>
<p> 「と」表示<strong>「と」之前的动作或事态只要一发生</strong>，<strong>「と」后面的主句中所表示状态、动作、现象、事态就必然会跟着发生</strong>。</p>
<p> 例如：</p>
<p> 「このボタンを押すと、お釣りがでます。」一按这个按钮，找的零钱就会出来。</p>
</li>
<li><p><strong>名词 + が + 形容词</strong></p>
<p> 之前学过当把自己的五官（如眼睛、耳朵等）所感受到的某种现象直接说出来或客观地传达某件事情时，主语用<strong>助词「が」</strong>来表示。<strong>这不单适用于动词句，同样适用于形容词句</strong>。</p>
<p> 例如：「音が小さいです。」声音很小。</p>
</li>
<li><p><strong>名词 + を + 移动动词</strong></p>
<p> 与「散歩します」「渡ります」「歩きます」等<strong>移动动词</strong>一起使用的助词「を」表示<strong>人或物通过的场所</strong>。</p>
<p> 例如：「交差点を右へ曲がります。」十字路口右拐。</p>
</li>
</ol>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p>本课主要学习的为「とき」的用法。</p>
<hr>
<h4 id="第二十四课（重要）"><a href="#第二十四课（重要）" class="headerlink" title="第二十四课（重要）"></a>第二十四课（<span style="color: red;">重要</span>）</h4><ol>
<li><p><strong>くれます</strong></p>
<p> 之前所学的「あげます」，在给予时并不能给 “我（即说话人）”，如果需要表达这一意思则需要使用「くれます」。<strong>也就是说「くれます」表示的是别人给我（或给我方）这个含义</strong>。</p>
<p> 例如：「彼女は妹にお菓子をくれました。」女朋友给我妹妹点心了。</p>
</li>
<li><p><strong>动词 て形 + { <span style="color: red;">あげます</span> / <span style="color: red;">もらいます</span> / <span style="color: red;">くれます</span> }（<span style="color: red;">重点</span>）</strong></p>
<p> 「あげます」「もらいます」「くれます」用于<strong>交换、互赠物品</strong>时。</p>
<ul>
<li><p><strong>动词 て形 + あげます（表示 “<em>为某人（通常是别人）做某事</em>”）</strong></p>
<p>  这个句型用于表示某一行为使对方受益。<strong>主语为实施这一行为的人</strong>。</p>
<p>  例如：「私は松本さんにケータイを貸してあげました。」我把手机借给了松本。</p>
<p>  <strong><em>注：当自己的行为使上司、长辈等受益时，使用这个句型会给人强加于人的印象。所以当在提出做使上司、长辈等受益的行为时，要使用「ます形ましょうか」来缓和语气。但是在实际使用时，基本上不对上司或长辈使用这个句型，所以只需了解即可。</em></strong></p>
</li>
<li><p><strong>动词 て形 + もらいます（表示 “<em>请某人为我做某事</em>”）</strong></p>
<p>  <strong>本句型的主语为行为的接受者</strong>。表示说话人感到自己因那一行为而受益的心情。当主语为「私」的时候可以省略。</p>
<p>  例如：「私は山田さんに図書館の電話番号を教えてもらいました。」我请山田告诉了我图书馆的电话号码。</p>
</li>
<li><p><strong>动词 て形 + くれます（表示 “<em>某人主动为我做某事</em>”）</strong></p>
<p>  <strong>本句型的主语为行为的实施者</strong>。表示说话人感到自己因那一行为而受益的心情。行为的接受者（使用助词「に」表示）如果是「私」时可以省略。</p>
<p>  例如：「母は[私に]セーターを送ってくれました。」妈妈给我寄来了毛衣。</p>
<p>  <strong>注：「〜てあげます」「〜てくれます」中表示受益人的助词与不使用这两个句型时用的助词相同。</strong></p>
<p>  例如：</p>
<p>  「<span style="color: red;">私の引っ越しを</span>手伝います。」</p>
<p>  「<span style="color: red;">私の引っ越しを</span>手伝ってくれます。」帮我搬家。</p>
</li>
</ul>
</li>
<li><p><strong>名词1 + <span style="color: red;">は</span> + 名词2 + <span style="color: red;">が</span> + 动词</strong></p>
<p> 「このワインは彼女がくれました。」这葡萄酒是女朋友送的。</p>
<p> 在上面这句话中，宾语「このワインは」作为主题。「彼女」为<strong>主语</strong>，使<strong>用助词「が」</strong>来表示。</p>
</li>
</ol>
<h5 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h5><p>本课主要学习的为「あげます」「もらいます」「くれます」等句型的用法。</p>
<hr>
<h4 id="第二十五课"><a href="#第二十五课" class="headerlink" title="第二十五课"></a>第二十五课</h4><ol>
<li><p><strong><span style="color: red;">普通形过去 ら</span>、～（主句）（表示 “<em>如果······的话</em>”）</strong></p>
<p> 动词、形容词、名词的普通形的过去时接「ら」，表示<strong>假定条件</strong>，后面接的<strong>主句</strong>表示<strong>在这个假定条件下所成立的内容</strong>。主句可以是说话人的<strong>意志</strong>、<strong>愿望</strong>、<strong>劝诱</strong>、<strong>委托</strong>、<strong>请求</strong>等。</p>
<p> <strong><em>注：「〜と」后面的接的主句不能使用表示意志、愿望、委托、请求等的表达方式。因为「〜と」后面接的主句表示状态、动作、现象、事态的必然发生。</em></strong></p>
<p> 例如：「お金があったら、旅行します。」如果有钱的话，就去旅行。</p>
</li>
<li><p><strong><span style="color: red;">动词 た形 ら</span>、～（主句）（表示 “<em>如果······了，就······</em>”）</strong></p>
<p> <strong>在知道某一情况将会达成时</strong>，用这个句型来表示<strong>在前面的情况达成后</strong>，后面的<strong>主句所表示的动作、事态也将成立</strong>。</p>
<p> 例如：「１０時になったら、出かけましょう。」到10点就出发吧。</p>
</li>
<li><p><strong>{ <span style="color: red;">动词 て形</span> / <span style="color: red;">动词 ない形 なくて</span> / <span style="color: red;">い 形容词（<s>い</s> -&gt; 〜くて）</span> / <span style="color: red;">な 形容词（[<s>な</s>] -&gt; 〜で）</span> / <span style="color: red;">名词 で</span> } + <span style="color: red;">も</span>、～（主句）（表示 “<em>即使······也······</em>”）</strong></p>
<p> 表示<strong>逆接的假定条件</strong>。「て 形 も」后的主句表示<strong>在前句（即从属句）的条件下</strong>，<strong>通常会预料到的事情没有发生，或者发生了与预期相反的事情</strong>。</p>
<p> <span style="color: red;">「い 形容词」：去掉「い」加「くて」。</span></p>
<p> <span style="color: red;">「な 形容词」：直接加「で」。</span></p>
<p> <span style="color: red;">「名词」：直接加「で」。</span></p>
<p> 例如：「日曜日でも、働きます。」即使是周日也要工作。</p>
</li>
<li><p><strong><span style="color: red;">もし</span></strong></p>
<p> 「もし」和「〜たら」一起使用时，表示这个句子为条件句。<strong>「もし」用于强调说话人的假定语气</strong>。</p>
<p> 例如：「もし１億円あったら、色々な国を旅行したいです。」如果有一亿日元的话，我想去很多国家旅行。</p>
</li>
<li><p><strong>从属句中的主语</strong></p>
<p> 之前学过的表示前提行为 / 准备动作的句型「〜てから」中的主语使用助词「が」来表示，与「〜てから」「〜とき」「〜まえに」等句型一样，在「〜たら」「〜ても」中，从属句的主语也使用<strong>助词「が」</strong>来表示。</p>
<p> 例如：「友達が約束の時間に来なかったら、どうしますか。」要是朋友在约好的时间没来怎么办？</p>
</li>
</ol>
<h5 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h5><p>本课主要学习的为与假定条件相关的句型。</p>
]]></content>
      <categories>
        <category>日语</category>
      </categories>
      <tags>
        <tag>日语</tag>
        <tag>语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>みんなの日本語（六）</title>
    <url>/%E6%97%A5%E8%AF%AD/%E3%81%BF%E3%82%93%E3%81%AA%E3%81%AE%E6%97%A5%E6%9C%AC%E8%AA%9E%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    <content><![CDATA[<center><strong><span style="font-size: 22px;">文法记录与总结</span></strong></center>

<h4 id="第三十六课"><a href="#第三十六课" class="headerlink" title="第三十六课"></a>第三十六课</h4><a id="more"></a>

<ol>
<li><p><strong>{ <span style="color: red;">动词1 字典形</span> / <span style="color: red;">动词1 ない形 ない</span> } + <span style="color: red;">ように</span>、动词2（表示 “<em>······的目的</em>”）</strong></p>
<p> 本句型表示<strong>动词2 的目的是成为「〜ように」所表示的状态</strong>。在「ように」的前面，要使用<strong>非意志动词（如：可能动词、「わかる」「みえる」「きこえる」「なる」等）</strong>的字典形和动词的否定形。</p>
<p> 例如：「速く泳げるように、毎日練習しています。」为了能游得快，每天都在练习。</p>
</li>
<li><p><strong>动词字典形 + <span style="color: red;">ように</span> + <span style="color: red;">なります</span></strong></p>
<ul>
<li><p>「なります」表示<strong>状态的变化</strong>。使用可能动词、「わかる」「みえる」等动词时，这个句型表示<strong>从不可能的状态转变到可能的状态</strong>。</p>
<p>  例如：「やっと自転車に乗れるようになりました。」终于会骑自行车了。</p>
</li>
<li><p>对于「〜ようになりましたか」这一疑问句，在使用「いいえ」做否定回答时，可以使用如下的表达方法：</p>
<p>  「ショパンの曲が弾けるようになりましたか。」会弹肖邦的曲子吗？</p>
<p>  ······「いいえ、まだ弾けません。」不，还不会。</p>
</li>
</ul>
<p> <strong><em>注意：这个句型在使用可能动词、「わかる」、「みえる」以外的动词时，表示新添了以前没有的习惯。</em></strong></p>
</li>
<li><p><strong>{ 动词字典形 / 动词 ない形 ない } + <span style="color: red;">ように</span> + <span style="color: red;">します</span></strong></p>
<ul>
<li><p><strong>～ようにしています</strong>（努力实现，但允许有不做的时候）</p>
<p>  表示<strong>注意一直坚持不断地去进行某一行动</strong>。</p>
<p>  例如：「歯に悪いですから、甘い物を食べないようにしています。」因为对牙不好，我很注意不吃甜食。</p>
</li>
<li><p><strong>〜ようにしてください</strong>（有请尽量的含义，但一般只是用于委婉表达）</p>
<p>  这是<strong>请求对方注意让某一行动得以进行的表达方式</strong>。</p>
<p>  「〜て / 〜ないで ください」是<strong>直接请求</strong>的表达方式。</p>
<p>  「〜ようにしてください」是<strong>间接请求</strong>的表达方式，较「〜て / 〜ないで ください」更为<strong>礼貌</strong>。</p>
<p>  例如：「絶対にパスポートをなくさないようにしてください。」注意一定不要把护照弄丢了。</p>
</li>
</ul>
<p> <strong><em>注意：「〜ようにしてください」不能用于当场所做的请求。</em></strong></p>
</li>
<li><p><strong>「早い」变为「早く」、「上手な」变为「上手に」</strong></p>
<p> 形容词修饰其他的形容词和动词时，<strong>「い形容词」用「〜く」的形式</strong>，<strong>「な形容词」用「〜に」的形式</strong>。</p>
<p> 例如：「早く上手にお茶がたてられるようになりたいです。」我很想能快点学会把茶沏好。</p>
</li>
</ol>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>本课所学句型可总结为：「〜ように、〜」、「〜ように + { なる / する }」等。</p>
<p>形容词的变化方法可以归纳为：{ ～い / 〜な + 名词 }、{ ～く / 〜に + 用言 }，前者为连体形，后者为连用形。</p>
<p>接「なる」的可以归纳为：{ 「イ形容词 <s>い</s> 变为 く」/ 「ナ形容词 / 名词 + に」 / 动词字典形 + ように } + なる</p>
<hr>
<h4 id="第三十七课"><a href="#第三十七课" class="headerlink" title="第三十七课"></a>第三十七课</h4><ol>
<li><p><strong>被动动词</strong></p>
<p> <span style="color: red;">I 类：「ます形」去「ます」，「イ段」变为「ア段」（若为「い」则变为「わ」），再加「れる」</span></p>
<p> <span style="color: red;">II 类：去「ます」，再加「られる」</span></p>
<p> <span style="color: red;">III 类：「します」＝＞「される」；「きます」＝＞「こられる」</span></p>
<p> <strong><em>注意：被动动词作为 II 类动词活用。</em></strong></p>
</li>
<li><p><strong>名词1（人1） + <span style="color: red;">は</span> + 名词2（人2） + <span style="color: red;">に</span> + 被动动词</strong></p>
<p> 这个句型是从行为受动者（人1）的立场来表现人2 对人1 所做的行为。人1 作为主题被提示，施动者（人2）用助词「に」来表示。</p>
<p> 例如：「私は先生に褒められました。」我受到了老师的表扬。</p>
<p> 有时候施动者可以是人以外的可以动的东西（动物、汽车等）。</p>
<p> 例如：「私は犬に噛まれました。」我被狗咬了。</p>
</li>
<li><p><strong>名词1（人1） + <span style="color: red;">は</span> + 名词2（人2） + <span style="color: red;">に</span> + 名词3 + <span style="color: red;">を</span> + 被动动词</strong></p>
<p> 这个句型表示人2 对人1 的所有物（名词3）所做的某种行为在大多数场合都会让人1（所有者）感到困扰和麻烦。</p>
<p> 有时候施动者可以是人以外的可以动的东西（动物、汽车等）。</p>
<p> <strong><em>注意：作为主题被提示的不是所有物，而是对这一行为感到困惑的人（所有者）。要注意的是，在大多数场合下，这个句型都表示受动者对那一行为感到困惑，如果想感谢别人为自己做了什么时，还是使用「〜てもらう」。</em></strong></p>
<p> 例如：「私は弟にパソコンを壊されました。」我被弟弟弄坏了电脑。</p>
</li>
<li><p><strong>名词（物 / 事） + { が / は } + 被动动词</strong></p>
<p> 在叙述某一事情时，有时并不特别注重行为者本身，而是<strong>把物或事作为主语或主题</strong>，用被动动词来表达。</p>
<p> 例如：「大阪で展覧会が開かれました。」展览会在大阪开幕。</p>
</li>
<li><p><strong>{ 名词 <span style="color: red;">から</span> / 名词 <span style="color: red;">で</span> } + つくります</strong></p>
<p> 在制造东西时，原料使用助词「から」，材料使用助词「で」。</p>
<p> 例如：「ビールは麦から作られます。」啤酒是用小麦酿造的。</p>
</li>
<li><p><strong>名词1 + の + 名词2</strong></p>
<p> 「ビールは麦から作られます。これが原料の麦です。」</p>
<p> 如上这句话中「原料の麦」表示了 ”原料是小麦“ 这样一种关系。</p>
</li>
<li><p><strong>{ この / その / あの } + 名词（位置）</strong></p>
<p> 「うえ」「した」等表示位置的名词之前接续「この」「その」等，表示与指示代词所指事物的位置关系。</p>
<p> 例如：「あの中に入れますか。」可以进到那里面去吗？</p>
</li>
</ol>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>本课学习的为被动动词的活用方式，以及几个与被动动词的使用相关的句型。</p>
<hr>
<h4 id="第三十八课"><a href="#第三十八课" class="headerlink" title="第三十八课"></a>第三十八课</h4><ol>
<li><p><strong>名词化的 の</strong></p>
<p> 「の」有使各种各样的表达方式转化为名词的功能，「の」之前接续的动词、形容词、名词使用<strong>普通形</strong>，不用礼貌形。名词化的表达方式可以成为句子中的各种成分。</p>
</li>
<li><p><strong><span style="color: red;">动词字典形</span> + <span style="color: red;">のは</span> + 形容词 + です</strong></p>
<p> 这是将「动词字典形の」做为主题，用「は」来提示的句型。这个句型常用的形容词有「難しい」「優しい」「面白い」「楽しい」等。与不使用「の」的句子相比，使用「の」的句子中的<strong>内容更为具体</strong>，表示<strong>某个动作很怎么怎么样</strong>。</p>
<p> 例如：「テニスをするのは面白いです。」打网球很有意思。</p>
</li>
<li><p><strong><span style="color: red;">动词字典形</span> + <span style="color: red;">のが</span> + 形容词 + です</strong></p>
<p> 「动词字典形の」是形容词的对象。这个句型中经常使用表示<strong>嗜好</strong>、<strong>技能</strong>、<strong>能力</strong>的形容词。如「好き」「嫌い」「遅い」「上手」等。</p>
<p> 例如：「私は花を育てるのが好きです。」我喜欢养花。</p>
</li>
<li><p><strong><span style="color: red;">动词字典形</span> + <span style="color: red;">のを</span> + 忘れました（表示 “<em>忘了······</em>”）</strong></p>
<p> 这个句型可以<strong>更为具体的说明被忘记了的内容</strong>。</p>
<p> 例如：「車の窓を閉めるのを忘れました。」忘了关车窗了。</p>
</li>
<li><p><strong><span style="color: red;">动词普通形</span> + <span style="color: red;">のを</span> + 知っていますか（表示 “<em>你知道······吗？</em>”）</strong></p>
<p> 这个句型在<strong>就具体内容询问对方是否知道时使用</strong>。</p>
<p> 例如：「鈴木さんが来月結婚するのを知っていますか。」你知道铃木下个月要结婚吗？</p>
<p> <strong><em>注意：「知りません」和「知りませんでした」的区别。听话人在被问到之前，并不知道这件事，但由于被问而得知了这件事时，使用「知りませんでした」；听话人在被问到之前不知道，被问到之后还是不知道，则使用「知りません」。</em></strong></p>
</li>
<li><p><strong>{ 动词普通形 / い形容词普通形 / <span style="color: red;">な形容词普通形（～<s>だ</s>=&gt;〜な）</span> / <span style="color: red;">名词1 普通形（～<s>だ</s>=&gt;〜な）</span> } + <span style="color: red;">のは</span> + 名词2 + です</strong></p>
<p> 这个句型用于<strong>强调名词2</strong>。</p>
<p> 例如：「初めて会ったのはいつですか。」初次见面是在什么时候？</p>
<p> 本句型也<strong>经常用来纠正对方所说的事情</strong>。</p>
<p> 例如：</p>
<p> 「経済を勉強しているんですか。」在学经济吗？</p>
<p> ······「いいえ、勉強しているのは音楽です。」不，在学的是音乐。</p>
<p> <strong><em>注意：「〜のは」之前的句子的主体不用「は」而要用「が」来表示。</em></strong></p>
<p> 例如：「父が生まれたのは北海道の小さな村です。」父亲出生在北海道的一个小村庄。</p>
</li>
</ol>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p>本课所学的内容为使用「の」来名词化的用法，实际在使用时可以结合之前所学的一系列的句型，不但只限于本课所学的这几个用法。</p>
<hr>
<h4 id="第三十九课"><a href="#第三十九课" class="headerlink" title="第三十九课"></a>第三十九课</h4><ol>
<li><p><strong>～て（で）、〜</strong></p>
<p> <strong>前半句</strong>（即「〜て（で）」的部分）表示<strong>原因</strong>、<strong>理由</strong>，<strong>后半句</strong>表示由于前面的原因、理由而带来的<strong>结果</strong>。后半句要使用<strong>与意志无关的表达方式</strong>，<strong>可表示某种状态</strong>。</p>
<ul>
<li><p><span style="color: red;">{ 动词て形 / 动词ない形なくて / い形容词（～<s>い</s>=&gt;〜くて） / な形容词（<s>な</s>=&gt;で） } 、～</span></p>
<p>  后半句主要使用如下的表达方式：</p>
<ul>
<li><p>表示<strong>感情的动词、形容词</strong></p>
<p>  如：「びっくりする」「安心する」「嬉しい」「残念」。</p>
<p>  例如：「ニュースを聞いて、びっくりしました。」听到新闻后吃了一惊。</p>
</li>
<li><p>表示<strong>可能或某种状态的动词</strong></p>
<p>  例如：「日曜日は都合が悪くて、行けません。」周日我有事，去不了。</p>
</li>
</ul>
<p>  <strong><em>注意：后半句使用含有意志的表达方式（意志、命令、劝诱、依赖）时，前半句要使用「〜から」。</em></strong></p>
<p>  例如：「危ないですから、機械に触らないでください。」因为很危险，请不要触碰机器。</p>
</li>
<li><p><span style="color: red;">名词で</span></p>
<p>  较多使用像「事故」「地震」「火事」等表示<strong>自然现象</strong>、<strong>事件</strong>的名词。</p>
<p>  例如：「地震でビルが倒れました。」因为地震，大厦倒塌了。</p>
</li>
</ul>
</li>
<li><p><strong>{ 动词普通形 / い形容词普通形 / <span style="color: red;">な形容词普通形（〜<s>だ</s>=&gt;〜な）</span> / <span style="color: red;">名词普通形（〜<s>だ</s>=&gt;〜な）</span> } + ので、〜</strong></p>
<p> 与之前学过的「〜から」一样，「〜ので」也表示<strong>原因</strong>、<strong>理由</strong>。因为「ので」原本就有表示因果关系（即陈述因某原因而引起某结果）的功能，所以适合在<strong>比较缓和地陈述某种请求的理由</strong>或<strong>进行辩解</strong>时使用。</p>
<p> 「〜から」与「〜ので」的区别可以理解为<strong>「〜から」一般是主观上的理由，「〜ので」一般是客观的理由</strong>。</p>
<p> 例如：「バスが遅れたので、約束に間に合いませんでした。」公交来迟了，所以约定的时间没赶上。</p>
</li>
<li><p><strong>途中で</strong></p>
<p> 「途中で」是指在两地之间移动时，其中的某一地点。与动词字典形或「名词の」一起使用。</p>
<p> 例如：</p>
<p> 「実は来る途中で事故があって、バスが遅れてしまったんです。」其实是因为在来的路上有事故，所以公交晚点了。</p>
</li>
</ol>
<h5 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h5><p>本课所学的为表示原因的句型，需要注意的为「〜から」与「〜ので」的区别。</p>
<hr>
<h4 id="第四十课"><a href="#第四十课" class="headerlink" title="第四十课"></a>第四十课</h4><ol>
<li><p><strong>{ 动词普通形 / い形容词普通形 / <span style="color: red;">な形容词普通形（～<s>だ</s>）</span> / <span style="color: red;">名词普通形（〜<s>だ</s>）</span> } + か、〜</strong></p>
<p> 将<strong>含有疑问词的疑问句</strong>与其他句子组合成一个句子时使用这个句型。</p>
<p> <strong><em>注意：疑问词是名词时，需要使用「疑问词 + か」的形式。</em></strong></p>
<p> 例如：</p>
<p> 「私達が初めて会ったのはいつか、覚えていますか。」你还记得我们第一次见面是什么时候吗？</p>
<p> 「結婚のお祝いは何がいいか、話しています。」我们在讨论结婚礼物送什么好。</p>
</li>
<li><p><strong>{ 动词普通形 / い形容词普通形 / <span style="color: red;">な形容词普通形（～<s>だ</s>）</span> / <span style="color: red;">名词普通形（〜<s>だ</s>）</span> } + かどうか、〜</strong></p>
<p> 将<strong>不含有疑问词的疑问句</strong>与其他句子组合成一个句子时使用这个句型，<strong>注意需要在「普通形か」之后接「どうか」</strong>。</p>
<p> 例如：</p>
<p> 「間違いがないかどうか、調べてください。」请查一下有没有错误。</p>
<p> <strong><em>注：这里之所以用「間違いがない」而不是「間違いがある」是因为说话人想让对方确认一下是否真的是「間違いがない」。</em></strong></p>
</li>
<li><p><strong>动词 て形 + みます</strong></p>
<p> 表示<strong>试着去做某件事</strong>。</p>
<p> 如果使用「〜てみたい」的话，则表示比「〜たい」更为<strong>低调地表示自己希望做某事</strong>。</p>
<p> 例如：</p>
<p> 「北海道へ行ってみたいです。」我想去北海道看看。</p>
<p> 「このズボンをはいてみてもいいですか。」我能试一下这条裤子吗？</p>
</li>
<li><p><strong>い形容词（～<s>い</s>）=&gt;〜さ</strong></p>
<p> 「い形容词」把词尾的「い」变为「さ」时可作为<strong>名词</strong>使用（<strong>注意不是所有的「い形容词」都适用</strong>）。</p>
<p> 例如：「山の高さはどうやって測るか、知っていますか。」你知道山的高度是怎么测量的吗？</p>
</li>
<li><p><strong>〜でしょうか</strong></p>
<p> 「〜でしょうか」用在问句中，是一种<strong>不要求对方进行某一确切回答的提问方式，在语气上会让人感觉比较委婉</strong>。</p>
<p> 例如：「ハンスは学校でどうでしょうか。」汉斯在学校怎么样啊？</p>
</li>
</ol>
<h5 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h5><p>本课重点学的是将含有疑问词或不包含疑问词的疑问句与其他句子连成一个句子的方式。<strong>「〜かどうか」可以理解为「か」表示肯定，「どうか」表示否定</strong>。</p>
]]></content>
      <categories>
        <category>日语</category>
      </categories>
      <tags>
        <tag>日语</tag>
        <tag>语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>杂七杂八</title>
    <url>/%E7%AC%94%E8%AE%B0/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/</url>
    <content><![CDATA[<h5 id="1-Servlet的结构"><a href="#1-Servlet的结构" class="headerlink" title="1. Servlet的结构"></a>1. Servlet的结构<a id="more"></a></h5><p>Java Servlet 开发包由 javax.servlet 和 javax.servlet.http 两个包组成。前者包括了所有的servlet <strong>实现</strong>和<strong>扩展</strong>的通用接口和类；后者包括了创建Http特定的servlet时所需要的扩充类。核心是<strong>javax.servlet.Servlet</strong>接口，它提供了servlet的框架结构。所有的Servlet必须实现这个接口，通常通过对<strong>javax.servlet.GenericServlet</strong>或者<strong>javax.servlet.http.HttpServlet</strong>进行继承来实现这个接口。</p>
<p> 如果开发与协议无关的Servlet，那么就对javax.servlet.GenericServlet进行继承，这时必须实现其中的service()方法。而javax.servlet.http.HttpServlet中已经实现了service()方法，通常不用对其进行覆盖，当service()方法被调用时，它会根据参数中用户请求时所用的类型（例如GET和POST）调用对应的方法，开发人员的主要任务是实现这些doXXX()方法，以便做出响应。</p>
<hr>
<h5 id="2-Servlet的生命周期"><a href="#2-Servlet的生命周期" class="headerlink" title="2. Servlet的生命周期"></a>2. Servlet的生命周期</h5><p> init()方法是Servlet生命周期的起点。加载某个Servlet时，服务器立即调用它的init()方法，在其中可创建和初始化在处理请求时需要用到的资源。</p>
<p>service()方法处理客户端发出的请求。前面说到了在javax.servlet.http.HttpServlet中已经实现了该方法，通常情况下无需覆盖。</p>
<p> destroy()方法释放在本Servlet中的init()方法中创建的资源。在服务需要关闭时（Java应用服务器关闭或者停止该Servlet所在的Web应用程序时），调用Servlet的destroy()方法释放在init()方法中创建的资源。可以在destroy()方法中处理以下清除任务：</p>
<p> <strong>①更新日志文件</strong></p>
<p> <strong>②关闭数据库连接</strong></p>
<p> <strong>③关闭任何套接字连接</strong></p>
<hr>
<h5 id="3-ServletContext"><a href="#3-ServletContext" class="headerlink" title="3. ServletContext"></a>3. ServletContext</h5><p> 容器会在Web应用程序启动时创建ServletContext。ServletContext接口定义Servlet用于与其Servlet容器<strong>通信</strong>的一组方法。每个Web应用程序有一个ServletContext。ServletContext中的信息通用于所有组件。</p>
<hr>
<h5 id="4-Struts中的ActionServlet"><a href="#4-Struts中的ActionServlet" class="headerlink" title="4. Struts中的ActionServlet"></a>4. Struts中的ActionServlet</h5><p> 来自用户的所有需要通过框架的请求，统一由ActionServlet接收（ActionServlet Struts已经为我们写好了，只要应用没有什么特别的需求，它基本上都能满足要求），根据接收的请求参数和Struts配置(struts-config.xml)中ActionMapping，将请求送给合适的Action去处理，<strong>解决由谁做的问题</strong>，它们共同构成Struts的<strong>控制器</strong>。</p>
<p> Action则是Struts应用中真正干活的组件，它<strong>解决的是做什么的问题</strong>，它通过调用需要的业务组件（模型）来完成应用的业务，<strong>业务组件解决的是如何做的问题</strong>，并将执行的结果返回一个代表所需的描绘响应的JSP（或Action）的ActionForward对象给ActionServlet以将响应呈现给用户。</p>
<p> 这里要特别说明一下的是<strong>Action这个类，它不应该包含过多的业务逻辑，而应该只是简单地收集业务方法所需要的数据并传递给业务对象</strong>。实际上，它的主要职责是：</p>
<p> <strong>①校验前提条件或者声明</strong></p>
<p> <strong>②调用需要的业务逻辑方法</strong></p>
<p> <strong>③检测或处理其他错误</strong></p>
<p> <strong>④路由控制到相关视图</strong></p>
<p> 在Web应用启动时就会加载，初始化ActionServlet，ActionServlet从struts-config.xml文件中读取配置信息，把它们存放到各种配置对象中。</p>
<hr>
<h5 id="5-Struts中的ActionServlet流程"><a href="#5-Struts中的ActionServlet流程" class="headerlink" title="5. Struts中的ActionServlet流程"></a>5. Struts中的ActionServlet流程</h5><p> ①检索和用户请求匹配的ActionMapping实例，如果不存在就返回请求路径无效信息</p>
<p> ②如果ActionForm实例不存在，就创建一个ActionForm对象，把用户提交的表单数据保存到ActionForm对象中</p>
<p> ③根据配置信息决定是否需要表单验证。如果需要验证，就调用ActionForm的validate()方法</p>
<p> ④如果ActionForm的validate()方法返回null或返回一个不包含ActionMessage的ActuibErrors对象，就表示表单验证成功</p>
<p> ⑤ActionServlet根据ActionMapping所包含的映射信息决定将请求转发给哪个Action，如果相应的Action实例不存在，就先创建这个实例，然后调用Action的execute()方法</p>
<p> ⑥Action的execute()方法返回一个ActionForward对象，ActionServlet在把用户请求转发给 ActionForward对象指向的JSP组件</p>
<p> ⑦ActionForward对象指向JSP组件生成动态网页,返回给用户</p>
<hr>
<h5 id="6-Filter典型应用"><a href="#6-Filter典型应用" class="headerlink" title="6. Filter典型应用"></a>6. Filter典型应用</h5><p> ①检测用户是否登录：编写一个用于检测用户是否登录的过滤器，如果用户未登录则重定向至指定页面</p>
<p> ②限制用户浏览权限</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title>赏味期限</title>
    <url>/%E6%97%A5%E5%B8%B8/%E8%B5%8F%E5%91%B3%E6%9C%9F%E9%99%90/</url>
    <content><![CDATA[<p>​    那还是你和好友说着想要去很多很多地方的年纪。<a id="more"></a></p>
<p>​    你踢踢踏踏地在走廊里面一边数着自己到底想去多少个地方，好友跟在你的后面臭着一张脸喊，好高骛远的家伙，离开这里看谁天天陪着你。</p>
<p>​    你转身去拉她的手，笑得相当谄媚，说你可以陪我一起去呀。好友摇着手告诉你去去去，先把英文考及格了再说吧。</p>
<p>​    所谓好友到底可以好成什么样子，CD机的耳机各戴一个，里面播放的无论是谁的CD都能跟着轻声唱。因为买书买CD而窘迫的时候，口袋里面的钱凑在一起买一碗米线来吃。坐在湖边给她读你喜爱的歌词，读到一半就笑闹成一团。在你有困难的时候，她会毫不犹豫地说“你在哪里，我去找你”，以及你难过的时候不觉羞愧地哭着说“我很难受，你快点过来”。你觉得你们的情谊如果拿尺量一定可以延伸到远远看不到边的那一头。</p>
<p>​    最后你给她保证：“无论到了哪个国家哪个城市，我第一个打电话的人肯定是你。”</p>
<p>​    隔了六年之后，站在与你距离半个地球的地方给你打电话的却是好友。</p>
<p>​    你因为熬夜工作而眼睛通红，一夜没有说话所以声音都闷闷的。你听着那边嘈杂的声音说：“你现在在哪？”那边顿了一下，“刚下飞机，现在在萨省。”你努力摆出兴趣盎然的样子，问起：“接下来呢，下一个要去的城市是哪儿？”</p>
<p>​    想去哪里？想去很多很多地方。</p>
<p>​    加拿大、美国、法国、英国、日本、西班牙。</p>
<p>​    那么再具体一点，萨省，纽约，巴黎，伦敦，东京，马德里。</p>
<p>​    你会抵达哪一处，你还可以再走多远。</p>
<p>​    那时候说着要走很远的某人是哪个某人，她有没有想到回来的方法。</p>
<p>​    然后很久后的一天，你看着电话上别国的来电显示怎么就想不起打来的是谁了。你接了电话听着对方喂喂的声音依旧没有听出是谁，最后你对那边嘈杂的声音说，请问是哪位。在等过大段的空白之后，你听到的是那边传来的压抑的哭声。</p>
<p>​    当然并不只是这样。</p>
<p>​    你是在进高中那年遇到他的，你们在午休的时候老土地在树下相遇。他对你带着一点点笑容，在你刚想要脸红心跳的时候，他忽然就说：“同学据我估计，粘在你的脸颊的米粒在上面已经过了三十分钟了。”</p>
<p>​    你当即发现：原来幻想泯灭只需要这么一个短短的过程。</p>
<p>​    十七岁的时候他跟你讲，我觉得我们会在一起很久的。</p>
<p>​    你挺鄙视地看着他，除了甜言蜜语你还会什么！</p>
<p>​    十八岁毕业的时候他对你说，我喜欢你，最最喜欢了。我鼓了很大的勇气经过万般思量才敢告诉你！</p>
<p>​    你当时想的是被谁被喜欢的人告白应该都是幸福羞涩的吧，为什么唯有自己得跟一身的鸡皮疙瘩抗争，你顶着恶心挥了挥手，行了，我批准了。</p>
<p>​    二十一岁的时候，他把你送到家楼下，说宝贝我爱你。</p>
<p>​    回到家后你躺在床上睡不着，你觉得那些成为了恋人之后一句我喜欢你都要纠结个很久的故事，是在动画里还是动漫里？都是放屁。你们之间从来都不缺乏这样的沟通。反而要是说得多了久了，我爱你这样的话就和我想要吃饭没有两样。你在这方面渐渐也不那么吝啬，并不是因为不羞涩的人也有过羞于启齿的时候。只是认识的时间太久了，在有一天你和他晚上打电话打到困了他不让你挂掉的时候，你半睡半醒说好啦我爱你，拜托我要睡觉了。说完时候你才猛地清醒过来，挂下电话后徒自愣了很久。</p>
<p>​    二十三岁的时候你在12点的时候打电话给他，他声音很疲倦，他说我在加班。你说我这就挂了。他说有什么事？你说生日快乐。他挺惊讶，今天是我生日啊。我都忘记了。没事，你说，你继续忙吧。注意身体。</p>
<p>​    二十五岁的时候，那年忽然就迷茫了，所以就分开了一段时间。一天在一起吃饭的餐厅遇到，你们各自都有同伴。最后干脆拼桌坐在了一起，晚上的时候他送你回家，到了楼下安静地看你上楼，你打开屋子里面灯的时候电话兀自响起来，接通后听到他闷闷的声音，想了很久还是还是觉得不行，想问你刚才陪你吃饭的那个男的不是你男朋友吧？你听得想笑又想哭，你说那和你一起来的女孩子是你女朋友么？</p>
<p>​    于是就又在一起。</p>
<p>​    二十六岁的时候，你看到他和年轻的女孩子在逛街，你回家什么都没有说。</p>
<p>​    二十七岁的时候，又分开，然后又在一起。</p>
<p>​    明明感动越来越少，分开像是缺些什么。在一起又不能好好地走下去。分分合合，一年两年，又三年。也已经习惯了。那些好些年前做过的梦，你和他坐在老房子的壁炉边，窗外天寒地冻，你靠着他偶尔把脚伸出去烤他会伸出手轻轻捏你的鼻子，看来也真的只是一个梦。穷极无聊的时候你也会想想，可能不是不爱，是不知道怎么爱了。</p>
<p>​    我们喜欢一件东西能喜欢多久。</p>
<p>​    一首歌听了几天也就腻了。</p>
<p>​    一种饮料喝了几个月也该换了。</p>
<p>​    一个人喜欢了几年，怎么样？也就该找下一个了。</p>
<p>​    你想到你和他都还是十六岁的时候，那些共撑一把伞的日子，他握着的伞柄明显地倾向你，自己却淋湿半个肩头的日子。</p>
<p>​    光阴无法倒退，你觉得实在是已经到头。</p>
<p>​    剩下的三十岁，四十岁，五十岁，或者说下半生都与他没有任何关系了。</p>
<p>​    一种感动能保存多久。</p>
<p>​    你接到手里的玫瑰花几天就谢了，那香气能留在你记忆里么。</p>
<p>​    你们曾经听过的那首歌几年后就已经过时了，那旋律你还记得么。</p>
<p>​    天早就放晴了与你撑伞的也不再是那个人了，那把伞还立在你的墙角么。</p>
<p>​    你是不是会把这些都忘记呢。</p>
<p>​    仿佛什么都是有期限，爱情或者友情，以及更多更多。</p>
<p>​    过程，挫折，时间，现实，无论是什么让他过期了。你听过压抑的哭声，了解情感的过渡，知道心境的变化。你那么遗憾而又无可奈何。</p>
<p>​    当你停在这样一个美丽而又冷酷的地方，很久之后才想起回头去看看，对岸依旧青春正好，梧桐树在两旁笔直地连成线，男孩或者女孩一路摇摇晃晃地冲过，笑声长留在耳边。于是你背过身用手掩住了潮湿的眼眶。</p>
<p>​    然后你才明白了。</p>
<p>​    我们真正爱了，真正难过了，原来也就只有那几年。</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>随记</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA</title>
    <url>/JPA/JPA/</url>
    <content><![CDATA[<h5 id="JPA-概述"><a href="#JPA-概述" class="headerlink" title="JPA 概述"></a>JPA 概述<a id="more"></a></h5><ol>
<li>JPA（Java Persistence API）：用于对象持久化的 API，JavaEE 5.0 平台标准的 ORM 规范，使得应用程序以统一的方式访问持久层</li>
<li>JPA 与 Hibernate 的关系<ul>
<li>JPA 是 Hibernate 的一个抽象（就像 JDBC 和 JDBC 驱动的关系）</li>
<li>JPA 本质上是一种 ORM 规范，不是 ORM 框架，因为 JPA 并未提供 ORM 实现，它只是制定了一些规范，提供了一些编程的 API 接口，但具体实现要由 ORM 厂商来实现</li>
<li>Hibernate 除了作为 ORM 框架以外，它也是一种 JPA 实现</li>
<li>从功能上来说，JPA 是 Hibernate 功能的一个子集</li>
</ul>
</li>
<li>JPA 的目标之一是制定一个可以由很多供应商实现的 API，例如 Hibernate、OpenJPA、TopLink 等</li>
<li>JPA 优势<ul>
<li>标准化<ul>
<li>提供相同的 API，这保证了基于 JPA 开发的企业应用能够经过少量的修改就能够在不同的 JPA 框架下运行</li>
</ul>
</li>
<li>简单易用，集成方便<ul>
<li>JPA 的主要目标之一就是提供更加简单的编程模型，在 JPA 框架下创建实体和创建 Java 类一样简单，只需要使用 javax.persistence.Entity 进行注释，JPA 的框架和接口也都非常简单</li>
</ul>
</li>
<li>可媲美 JDBC 的查询能力<ul>
<li>JPA 的查询语言是面向对象的，JPA 定义了独特的 JPQL，而且能够支持批量更新和修改、JOIN、GROUP BY、HAVING 等通常只有 SQL 才能提供的高级查询特性，甚至还能够支持子查询</li>
</ul>
</li>
<li>支持面向对象的高级特性<ul>
<li>JPA 中能够支持面向对象的高级特性，例如类之间的继承、多态和类之间的复杂关系，最大限度的使用面向对象的模型</li>
</ul>
</li>
</ul>
</li>
<li>JPA 包括三方面的技术<ul>
<li>ORM 映射元数据<ul>
<li>JPA 支持 XML 和 JDK5.0 注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中</li>
</ul>
</li>
<li>JPA 的 API<ul>
<li>用来操作实体对象，执行 CRUD 操作，框架在后台完成所有的事情，开发者可以不用编写繁琐的 JDBC 和 SQL 代码</li>
</ul>
</li>
<li>查询语言 JPQL<ul>
<li>通过面向对象而非面向数据库的查询语言查询数据，避免程序和具体的 SQL 紧密结合</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h5 id="使用-JPA-持久化对象的步骤"><a href="#使用-JPA-持久化对象的步骤" class="headerlink" title="使用 JPA 持久化对象的步骤"></a>使用 JPA 持久化对象的步骤</h5><ol>
<li><p>导入所需 JAR 包（以 Hibernate 实现为例）</p>
<ul>
<li>hibernate\lib\required\*.jar</li>
<li>hibernate\lib\jpa\*.jar</li>
<li>数据库驱动</li>
</ul>
</li>
<li><p>创建 persistence.xml，在这个文件中配置持久化单元（ JPA 规范要求放在类路径的 META-INF 目录中且文件名固定）</p>
<ul>
<li><p>需要指定与哪个数据库进行交互</p>
</li>
<li><p>需要指定 JPA 使用哪个持久化的框架以及配置该框架的基本属性</p>
</li>
<li><p>persistence.xml 文件中元素含义</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">persistence</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- name 属性用于定于持久化单元的名字 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">		transaction-type 用于指定 JPA 的事务处理策略</span></span><br><span class="line"><span class="comment">		RESOURCE_LOCAL: 默认值，数据库级别的事务，只能针对一种数据库，不支持分布式事务</span></span><br><span class="line"><span class="comment">		如需支持分布式事务，应使用 JTA: transaction-type=&quot;JTA&quot;</span></span><br><span class="line"><span class="comment"> 	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">persistence-unit</span> <span class="attr">name</span>=<span class="string">&quot;JPA&quot;</span> <span class="attr">transaction-type</span>=<span class="string">&quot;RESOURCE_LOCAL&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">			配置使用什么 ORM 框架来作为 JPA 的实现</span></span><br><span class="line"><span class="comment">			实际上配置的是 javax.persistence.spi.PersistenceProvider 接口的实现类</span></span><br><span class="line"><span class="comment">			若 JPA 项目中只有一个 JPA 的实现框架, 则也可以不配置该节点 </span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span>&gt;</span>org.hibernate.ejb.HibernatePersistence<span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 添加持久化类 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">class</span>&gt;</span>beiran.bean.Customer<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">            配置二级缓存的策略 </span></span><br><span class="line"><span class="comment">            ALL：所有的实体类都被缓存</span></span><br><span class="line"><span class="comment">            NONE：所有的实体类都不被缓存. </span></span><br><span class="line"><span class="comment">            ENABLE_SELECTIVE：标识 @Cacheable(true) 注解的实体类将被缓存</span></span><br><span class="line"><span class="comment">            DISABLE_SELECTIVE：缓存除标识 @Cacheable(false) 以外的所有实体类</span></span><br><span class="line"><span class="comment">            UNSPECIFIED：默认值，JPA 实现框架的默认值将被使用</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">shared-cache-mode</span>&gt;</span>ENABLE_SELECTIVE<span class="tag">&lt;/<span class="name">shared-cache-mode</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 连接数据库的基本信息 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;javax.persistence.jdbc.driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;javax.persistence.jdbc.url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///jpa&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;javax.persistence.jdbc.user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;javax.persistence.jdbc.password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span>/&gt;</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">&lt;!-- 配置 JPA 实现框架的基本属性. 配置 Hibernate 的基本属性 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.format_sql&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.show_sql&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.hbm2ddl.auto&quot;</span> <span class="attr">value</span>=<span class="string">&quot;update&quot;</span>/&gt;</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">&lt;!-- 二级缓存相关 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.cache.use_second_level_cache&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.cache.region.factory_class&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.hibernate.cache.ehcache.EhCacheRegionFactory&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.cache.use_query_cache&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">persistence-unit</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persistence</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>创建实体类，使用注解来描述实体类跟数据库表之间的映射关系</p>
</li>
<li><p>使用 JPA API 完成 CRUD 操作</p>
<ul>
<li><p>创建 EntityManagerFactory（对应 Hibernate 中的 SessionFactory ）</p>
</li>
<li><p>创建 EntityManager（对应 Hibernate 中的 Session ）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 EntityManagerFactory 对象</span></span><br><span class="line">EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(<span class="string">&quot;JPA&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 EntityManager 对象</span></span><br><span class="line">EntityManager entityManager = entityManagerFactory.createEntityManager();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启事务</span></span><br><span class="line">EntityTransaction entityTransaction = entityManger.getTransaction();</span><br><span class="line">entityTransaction.begin();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行持久化操作</span></span><br><span class="line">entityManager.persist(object);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交事务</span></span><br><span class="line">entityTransaction.commit();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭 EntityManager</span></span><br><span class="line">entityManager.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭 EntityManagerFactory</span></span><br><span class="line">entityManagerFactory.close();</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<hr>
<h5 id="JPA-基本注解"><a href="#JPA-基本注解" class="headerlink" title="JPA 基本注解"></a>JPA 基本注解</h5><ol>
<li><p>@Entity</p>
<ul>
<li>@Entity 注解用于实体类声明语句前，指出该 Java 类是一个实体类，将映射到指定的数据库表</li>
</ul>
</li>
<li><p>@Table</p>
<ul>
<li>当实体类与其映射的数据库表名不同名时，需要使用 @Table 注解指定数据表名，该注解与 @Entity 注解并列使用</li>
<li>@Table 注解常用的属性是 name，用于指定数据表名</li>
<li>@Table 注解其他属性<ul>
<li>catalog 属性用于指定数据库目录，通常无需指定</li>
<li>schema 属性用于指定数据库模式，通常无需指定</li>
<li>uniqueConstraints 属性用于设置约束条件，通常无需设置</li>
</ul>
</li>
</ul>
</li>
<li><p>@Id</p>
<ul>
<li>@Id 注解用于声明一个实体类的属性映射为数据表的主键列，该属性通常置于属性声明语句上（也可置于属性的 getter 方法之前）</li>
</ul>
</li>
<li><p>@GeneratedValue</p>
<ul>
<li>@GeneratedValue 注解用于标注主键的生成策略，通过 strategy 属性指定。默认情况下，JPA 自动选择一个最适合底层数据库的主键生成策略（ SQLServer 对应 identity，MySQL 对应 auto ）</li>
<li>在 javax.persistence.GenerationType 中定义了以下几种可供选择的策略<ul>
<li>IDENTITY：采用数据库 ID 自增长的方式来自增主键字段，Oracle 不支持此种方式</li>
<li>AUTO（默认值）：JPA 自动选择合适的策略</li>
<li>SEQUENCE：通过序列产生主键，通过 @SequenceGenerator 注解指定序列名，MySQL 不支持此种方式</li>
<li>TABLE：通过表产生主键，框架借由表模拟序列产生主键，使用该策略可以使应用更易于数据库移植</li>
</ul>
</li>
</ul>
</li>
<li><p>@Basic</p>
<ul>
<li>@Basic 注解表示一个简单的属性到数据表的字段的映射，对于没有任何标注 @Basic 注解的 getter 方法，默认即为 @Basic</li>
<li>@Basic 注解的 fetch 属性表示该字段的读取策略，有 EAGER 和 LAZY 两种，分别表示主支抓取和延迟加载，默认为 EAGER。@Basic 注解的 optional 属性表示该字段是否允许为 null，默认为 true</li>
</ul>
</li>
<li><p>@Column</p>
<ul>
<li>当实体的属性与其映射的数据表的列不同名时需要使用 @Column 注解说明，该属性通常置于实体的属性声明语句之前（也可以置于 getter 方法之前），还可以与 @Id 注解一起使用</li>
<li>@Column 注解常用的属性是 name，用于设置映射数据表的列名，此外，该注解还包含其他多个属性，例如 unique、nullable、length 等</li>
<li>@Column 注解的 columnDefinition 属性表示该字段在数据表中的实际类型，通常 ORM 框架可以根据属性类型自动判断数据表中字段的类型，但是对于 Date 类型仍然无法确定数据表中字段类型究竟是 DATE、TIME 还是 TIMESTAMP。此外，String 类型的默认映射类型为 VARCHAR，如果要将 String 类型映射到特定数据表的 BLOB 或者 TEXT，可以通过 columnDefinition 属性进行设置</li>
</ul>
</li>
<li><p>@Transient</p>
<ul>
<li>@Transient 注解表示该属性并非一个到数据表的字段的映射，ORM 框架将忽略该属性</li>
<li>如果一个属性并非数据表的字段映射，就务必为其标注 @Transient 注解，否则，ORM 框架默认其注解为 @Basic</li>
</ul>
</li>
<li><p>@Temporal</p>
<ul>
<li>在核心的 Java API 中并没有定义 Date 类型的精度，而在数据库中，表示 Date 类型的数据有 DATE、TIME 和 TIMESTAMP 三种精度，在进行属性映射时可以使用 @Temporal 注解来调整精度</li>
</ul>
</li>
<li><p>用数据表来生成主键</p>
<ul>
<li><p>将当前主键的值单独保存到一个数据表中，主键的值每次都是从指定的表中查询来获得</p>
</li>
<li><p>这种方法生成主键的策略可以适用于任何数据库，不必担心不同数据库不兼容造成的问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// name 属性表示该主键生成策略的名称，它被引用在 @GeneratedValue 中设置的 generator 值中</span></span><br><span class="line"><span class="comment">// table 属性表示存储生成的主键值的表名</span></span><br><span class="line"><span class="comment">// pkColumnName 属性表示在实体类对应的表中，该主键生成策略所对应键值的名称</span></span><br><span class="line"><span class="comment">// pkColumnValue 属性表示在实体类对应的表中，该生成策略所对应的主键</span></span><br><span class="line"><span class="comment">// valueColumnName 属性表示在实体类对应的表中，该主键当前所生成的值，它的值会随着每次创建而累加</span></span><br><span class="line"><span class="comment">// initialValue 属性表示生成的主键的初始值，默认为 0</span></span><br><span class="line"><span class="comment">// allocationSize 属性表示每次主键值增加的大小，默认为 50</span></span><br><span class="line"><span class="meta">@TableGenerator(name = &quot;ID_GENERATOR&quot;, table = &quot;JPA_ID_GENERATOR&quot;,</span></span><br><span class="line"><span class="meta">               allocationSize = 1, initialValue = 1, </span></span><br><span class="line"><span class="meta">                pkColumnName = &quot;PK_NAME&quot;, pkColumnValue = &quot;PERSON_ID&quot;, </span></span><br><span class="line"><span class="meta">               valueColumnName = &quot;ID_VAL&quot;)</span></span><br><span class="line"><span class="meta">@GeneratedValue(strategy = GenerationType.TABLE, generator=&quot;ID_GENERATOR&quot;)</span></span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br></pre></td></tr></table></figure>

<p><img src="image-20200217000332301.png" alt="用数据表来生成主键"></p>
</li>
</ul>
</li>
</ol>
<hr>
<h5 id="JPA-API"><a href="#JPA-API" class="headerlink" title="JPA API"></a>JPA API</h5><ol>
<li><p>Persistence</p>
<ul>
<li>Persistence 类用于获取 EntityManagerFactory 实例，该类包含一个 createEntityManagerFactory 的静态方法</li>
<li>createEntityManagerFactory 方法有两个重载版本<ul>
<li>带有一个参数的方法以 JPA 配置文件 persistence.xml 中的持久化单元名（ persistence-unit ）作为参数</li>
<li>带有两个参数的方法：前一个参数的含义相同，后一个参数为 Map 类型，用于设置 JPA 的相关属性，这时将忽略其他地方设置的属性。Map 对象的属性名必须是 JPA 实现框架提供商的命名空间约定的属性名</li>
</ul>
</li>
</ul>
</li>
<li><p>EntityManagerFactory</p>
<ul>
<li>EntityManagerFactory 接口主要用于创建 EntityManager 实例<ul>
<li>createEntityManager()：用于创建 EntityManager 对象实例</li>
<li>createEntityManager(Map map)：用于创建 EntityManager 对象实例的重载方法，Map 参数用于提供 EntityManager 的属性</li>
<li>isOpen()：检查 EntityManagerFactory 是否处于打开状态，EntityManagerFactory 创建之后就一直处于打开状态，除非调用 close() 方法将其关闭</li>
<li>close()：关闭 EntityManagerFactory，EntityManagerFactory 关闭后将释放所有资源，isOpen() 方法将返回 false，其他方法则不能调用，否则将抛出 IllegalStateException</li>
</ul>
</li>
</ul>
</li>
<li><p>EntityManager</p>
<ul>
<li><p>在 JPA 规范中，EntityManager 是完成持久化操作的核心对象，实体作为普通 Java 对象，只有在调用 EntityManager 将其持久化后才会变为持久化对象。EntityManager 对象在一组实体类与底层数据源之间进行 O/R 映射的管理，它可以用管理和更新 Entity Bean，根据主键查找 Entity Bean，还可以通过 JPQL 语句查询实体</p>
</li>
<li><p>实体的状态</p>
<ul>
<li>新建状态：新创建的对象，尚未拥有持久性主键</li>
<li>持久化状态：已经拥有持久性主键并和持久化建立了上下文环境</li>
<li>游离状态：拥有持久化主键，但是没有与持久化建立上下文环境</li>
<li>删除状态：拥有持久化主键，已经和持久话建立了上下文环境，但是已经从数据库中删除了</li>
</ul>
</li>
<li><p>find(Class&lt;T&gt; entityClass, Object primaryKey)：返回指定的 OID 对应的实体类对象，如果这个实体存在于当前的持久化环境，则返回一个被缓存的对象，否则会创建一个新的 Entity，并加载数据库中相关信息。若 OID 不存在于数据库中，则返回一个 null。第一个参数为被查询的实体类类型，第二个参数为待查找实体的主键值</p>
</li>
<li><p>getReference(Class&lt;T&gt; entityClass, Object primaryKey)：与 find() 方法类似，不同的是如果缓存中不存在指定的 Entity，EntityManager 会创建一个 Entity 类的代理，但是不会立即加载数据库中的信息，只有第一次真正使用此 Entity 的属性才加载，所以如果此 OID 在数据库中不存在，getReference() 方法不会返回 null 值，而是抛出 EntityNotFoundException</p>
</li>
<li><p>persist(Object entity)：用于将新创建的 Entity 纳入到 EntityManager 的管理，该方法执行后，传入 persist() 方法的 Entity 对象将转换成持久化状态</p>
<ul>
<li>如果传入 persist() 方法的 Entity 对象已经处于持久化状态，则 persist() 方法什么都不做</li>
<li>如果对删除状态的 Entity 对象进行 persist() 操作，会转换为持久化状态</li>
<li>如果对游离态的 Entity 对象进行 persist() 操作，可能会在 persist() 方法抛出 EntityExistException（也有可能是在 flush 或事务提交后抛出）</li>
</ul>
</li>
<li><p>remove(Object entity)：删除实例，如果实例是被管理的（即与数据库实体记录关联），则同时会删除关联的数据库记录</p>
</li>
<li><p>merge(T entity)：用于处理 Entity 的同步（即数据库的插入和更新操作）</p>
<p>  <img src="JPA%20merge()%20%E6%B5%81%E7%A8%8B.png" alt="JPA merge() 流程"></p>
</li>
<li><p>flush()：同步持久化上下文环境（即将持久化上下文环境中的所有未保存实体的状态信息保存到数据库中）</p>
</li>
<li><p>setFlushMode(FlushModeType flushMode)：设置持久化上下文环境的 Flush 模式，参数可以取两个枚举值</p>
<ul>
<li>FlushModeType.AUTO 为自动更新数据库实体</li>
<li>FlushModeType.COMMIT 为直到提交事务时才更新数据库记录</li>
</ul>
</li>
<li><p>getFlushMode()：获取持久化上下文环境的 Flush 模式，返回 FlushModeType 类型的枚举值</p>
</li>
<li><p>refresh(Object entity)：用数据库实体记录的值更新实体对象的状态（即更新实例的属性值）</p>
</li>
<li><p>clear()：清除持久化上下文环境，断开所有关联的实体，如果这时候还有未提交的更新则会被撤销</p>
</li>
<li><p>contains(Object entity)：判断一个实例是否是当前持久化上下文环境管理的实体</p>
</li>
<li><p>isOpen()：判断当前的 EntityManager 是否为打开状态</p>
</li>
<li><p>getTransaction()：获取资源层的事务对象，EntityTransaction 实例可用于开始和提交多个事务</p>
</li>
<li><p>close()：关闭 EntityManager，之后若调用 EntityManager 实例的方法或其派生的查询对象的方法都将抛出 IllegalStateException，除了 getTransaction() 和 isOpen() 方法（返回 false ）。但是，当与 EntityManager 关联的事务处于活动状态时，调用 close() 方法后持久化上下文环境将仍处于被管理状态直到事务完成为止</p>
</li>
<li><p>createQuery(String qlString)：创建一个查询对象</p>
</li>
<li><p>createNamedQuery(String name)：根据命名的查询语句块创建查询对象，参数为命名的查询语句</p>
<ul>
<li>使用 @NamedQuery 注解（标注在类上，且可标注多个），该注解的 name 属性指定 JPQL 语句名称，query 属性指定 JPQL 语句</li>
</ul>
</li>
<li><p>createNativeQuery(String sqlString)：使用标准 SQL 语句创建查询对象，参数为标准 SQL 语句字符串</p>
</li>
<li><p>createNativeQuery(String sqls, String resultSetMapping)：使用标准 SQL 语句创建查询对象，并指定返回结果集 Map 的名称</p>
</li>
</ul>
</li>
<li><p>EntityTransaction</p>
<ul>
<li>EntityTransaction 接口用来管理资源层 EntityManager 的事务操作，通过调用 EntityManager 的 getTransaction() 方法获取其实例</li>
<li>begin()：用于启动一个事务，此后的多个数据库操作将作为整体被提交或回滚，若这时事务已经启动则会抛出 IllegalStateException</li>
<li>commit()：用于提交当前事务（即将事务启动以后的所有数据库更新操作持久化到数据库中）</li>
<li>rollback()：回滚当前事务（即回滚事务启动后的所有数据库更新操作，从而不对数据库产生影响）</li>
<li>isActive()：查询当前事务是否是活动的。如果返回 true 则不能调用 begin() 方法，否则将抛出 IllegalStateException。如果返回 false 则不能调用 commit()、rollback()、setRollbackOnly() 及 getRollbackOnly() 方法，否则将抛出 IllegalStateException</li>
</ul>
</li>
</ol>
<hr>
<h5 id="映射关联关系"><a href="#映射关联关系" class="headerlink" title="映射关联关系"></a>映射关联关系</h5><ol>
<li><p>映射单向多对一的关联关系</p>
<ul>
<li>使用 @ManyToOne 注解来映射单向多对一的关联关系</li>
<li>使用 @JoinColumn 注解来映射外键列的名称</li>
<li>可以使用 @ManyToOne 注解的 fetch 属性来修改默认的关联属性的加载策略。默认情况下，使用左外连接的方式来获取 n 的一端的对象和其关联的 1 的一端的对象</li>
<li>保存多对一时，建议先保存 1 的一端，再保存 n 的一端，这样不会多出额外的 UPDATE 语句</li>
<li>不能直接删除 1 的一端，因为有外键约束</li>
</ul>
</li>
<li><p>映射单向一对多的关联关系</p>
<ul>
<li>使用 @OneToMany 注解来映射一对多的关联关系</li>
<li>使用 @JoinColumn 注解来映射外键列的名称</li>
<li>可以使用 @OneToMany 注解的 fetch 属性来修改默认的加载策略。可以通过 @OneToMany 注解的 cascade 属性来修改默认的删除策略（默认情况下，若删除 1 的一端，会先把关联的 n 的一端的外键置为 null，然后再进行删除）</li>
<li>单向一对多关联关系执行保存时，一定会多出 UPDATE 语句，因为 n 的一端在插入时不会同时插入外键列</li>
</ul>
</li>
<li><p>映射双向多对一的关联关系</p>
<ul>
<li>双向一对多关系中，必须存在一个关系维护端，在 JPA 规范中，要求 n 的一端作为关系的维护端（ owner side ），1 的一端作为被维护端（ inverse side )</li>
<li>可以在 1 的一端指定 @OneToMany 注解并设置 mappedBy 属性，以指定它是这一关联中的被维护端，n 的一端为维护端。若在 1 的一端的 @OneToMany 中使用 mappedBy 属性，则 @OneToMany 端就不能再使用 @JoinColumn 属性了</li>
<li>在 n 的一端指定 @ManyToOne 注解，并使用 @JoinColumn 指定外键名称</li>
</ul>
</li>
<li><p>映射双向一对一的关联关系</p>
<ul>
<li>基于外键的一对一关联关系，在双向一对一关联中，需要在关系被维护端（ inverse side ）中的 @OneToOne 注解中指定 mappedBy，以指定是这个关联中的被维护端，同时需要在关系维护端（ owner side ）建立外键列指向关系被维护端的主键列（需要指定 unique 属性）</li>
<li>对于双向一对一关联关系，建议先保存不维护关联关系的一端（即没有外键的一端），这样不会多出 UPDATE 语句</li>
<li>默认情况下，若获取维护关联关系的一端，则会通过左外连接获取其关联的对象，但可以通过 @OneToOne 的 fetch 属性来修改加载策略</li>
<li>双向一对一无法使用延迟加载</li>
</ul>
</li>
<li><p>映射双向多对多的关联关系</p>
<ul>
<li><p>在双向多对多关系中，必须指定一个关系维护端（ owner side ），可以通过 @ManyToMany 注解中 mappedBy 属性来标识其为关系维护</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @JoinTable 来映射中间表</span></span><br><span class="line"><span class="comment">// joinColumns 映射当前类所在的表在中间表中的外键</span></span><br><span class="line"><span class="comment">// inverseJoinColumns 映射关联的类所在中间表的外键</span></span><br><span class="line"><span class="meta">@ManyToMany</span></span><br><span class="line"><span class="meta">@JoinTable(name = &quot;中间表名称&quot;,</span></span><br><span class="line"><span class="meta">          joinColumns = @JoinColumn(name = &quot;本类的外键&quot;,</span></span><br><span class="line"><span class="meta">                                   referencedColumnName = &quot;本类与外键对应的主键&quot;),</span></span><br><span class="line"><span class="meta">          inverseJoinColumns = &#123; @JoinColumn(name = &quot;对方类的外键&quot;, </span></span><br><span class="line"><span class="meta">                                            referencedColumnName = &quot;对方类与外键对应的主键&quot;) &#125;)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于关联的集合对象，默认使用懒加载。无论使用维护关系的一端还是不维护关系的一端获取，发送的 SQL 语句数量相同</p>
</li>
</ul>
</li>
</ol>
<hr>
<h5 id="使用二级缓存"><a href="#使用二级缓存" class="headerlink" title="使用二级缓存"></a>使用二级缓存</h5><ol>
<li>&lt;shared-cache-mode&gt; 节点<ul>
<li>若 JPA 实现框架支持二级缓存，该节点可以配置在当前的持久化单元中是否启用二级缓存<ul>
<li>ALL：所有实体类都被缓存</li>
<li>NONE：所有的实体类都不被缓存</li>
<li>ENABLE_SELECTIVE：标识 @Cacheable(true) 注解的实体类将被缓存</li>
<li>DISABLE_SELECTIVE：缓存除标识 @Cacheable(false) 注解以外的所有实体类</li>
<li>UPSPECIFIED：默认值，使用 JPA 实现框架的默认值</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h5 id="JPQL"><a href="#JPQL" class="headerlink" title="JPQL"></a>JPQL</h5><ol>
<li><p>Java Persistence Query Language 简称 JPQL，是一种和 SQL 非常类似的中间性和对象化的查询语言，它最终会被编译成针对不同底层数据库的 SQL 查询，从而屏蔽不同数据库的差异</p>
</li>
<li><p>JPQL 语言的语句可以是 SELECT 语句、UPDATE 语句或 DELETE 语句，它们都通过 javax.persistence.Query 接口封装执行</p>
</li>
<li><p>javax.persistence.Query 接口封装了执行数据库查询的相关方法，调用 EntityManager 的 createQuery()、createNamedQuery()、createNativeQuery() 方法即可获取查询对象，进而可以调用 javax.persistence.Query 接口的相关方法来执行查询操作</p>
</li>
<li><p>javax.persistence.Query 接口的主要方法</p>
<ul>
<li>int executeUpdate()：用于执行 UPDATE 语句或 DELETE 语句</li>
<li>List getResultList()：用于执行 SELECT 语句并返回结果集实体集合</li>
<li>Object getSingleResult()：用于执行只返回单个结果实体的 SELECT 语句</li>
<li>Query setFirstResult(int startPosition)：用于设置从哪个实体记录开始返回查询结果</li>
<li>Query setMaxResults(int maxResult)：用于设置返回结果实体的最大值，可以 setFirstResult() 方法结合使用实现分页查询</li>
<li>Query setFlushMode(FlushModeType flushMode)：设置查询对象的 Flush 模式，参数同 EntityManager 的 setFlushMode() 方法</li>
<li>setHint(String hintName, Object value)：设置与查询对象相关的特定供应商参数或提示信息，参数名及其取值需要参考特定 JPA 实现框架提供商的文档。如果第二个参数无效将抛出 IllegalArgumentException</li>
<li>setParameter(int position, Object value)：为查询语句的指定位置参数赋值，position 指定参数序号（从 1 开始），value 为赋给参数的值</li>
<li>setParameter(int position, Date value, TemporalType type)：为查询语句的指定位置参数赋 Date 值，position 指定参数序号，value 为赋给参数的值，type 取 TemporalType 的枚举常量，包括 DATE、TIME、TIMESTAMP 三种，用于将 Java 的 Date 类型的值临时转换为数据库支持的日期时间类型（java.sql.Date、java.sql.Time、java.sql.Timestamp）</li>
<li>setParameter(int position, Calendar value, TemporalType type)：为查询语句的指定位置参数赋 Calendar 值，position 指定参数序号，value 为赋给参数的值，type 取值同上</li>
<li>setParameter(String name, Object value)：为查询语句的指定名称参数赋值</li>
<li>setParameter(String name, Date value, TemporalType type)：为查询语句的指定名称参数赋 Date 值，用法同上</li>
<li>setParameter(String name, Calendar value, TemporalType type)：为查询语句的指定名称参数赋 Calendar 值，用法同上。该方法调用时如果参数位置或参数名不对，或者所赋参数值类型不匹配，则抛出 IllegalArgumentException</li>
</ul>
</li>
<li><p>SELECT-FROM 语句</p>
<ul>
<li>SELECT 用来指定查询返回的结果实体或实体的某些属性</li>
<li>FROM 子句声明查询源实体类，并指定标识符变量（相当于 SQL 的别名）</li>
<li>如果不希望返回重复实体，可使用 DISTINCT 关键字修饰</li>
</ul>
</li>
<li><p>JPQL 支持包含参数的查询</p>
<ul>
<li>若占位符使用 “?index”（ index = { 1, 2, 3, … }），则执行查询前必须使用 javax.persistence.Query.setParameter(int position, Object value) 方法给参数赋值</li>
<li>若占位符使用 “:name”（ name 为自定义参数名 ），则执行查询前必须使用 javax.persistence.Query.setParameter(String name, Object value) 方法给参数赋值</li>
</ul>
</li>
<li><p>WHERE 条件表达式中可用的运算符基本上与 SQL 一致</p>
</li>
<li><p>若只须查询实体的部分属性而不需要返回整个实体，则执行 getResultList() 方法返回的不再是实体集合，而是一个 Object[] 类型的集合。也可以在实体类中创建对应的构造器，然后在 JPQL 语句中利用对应的构造器返回实体类的对象（ <code>SELECT new Object(field1, field2) FROM Object o WHERE condition</code> ）</p>
</li>
<li><p>使用 Hibernate 的查询缓存</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String jpql = <span class="string">&quot;SELECT c FROM Customer c&quot;</span>;</span><br><span class="line">Query query = entityManager.createQuery(jpql);</span><br><span class="line">query.setHint(QueryHints.CACHEABLE, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>ORDER BY 子句用于对查询结果集进行排序</p>
</li>
<li><p>GROUP BY 子句用于对查询结果分组统计，通常需要使用聚合函数。没有 GROUP BY 子句的查询是基于整个实体类的，使用聚合函数将返回单个结果值，可使用 getSingleResult() 方法获取查询结果</p>
</li>
<li><p>HAVING 子句用于对 GROUP BY 分组设置约束条件</p>
</li>
<li><p>支持关联查询和子查询。在 JPQL 中很多时候都是通过在实体类中配置实体关联的类属性来实现隐含的关联查询（ <code>SELECT o FROM Orders o WHERE o.address.streetNumber = 2000</code> ）</p>
</li>
<li><p>JPQL 函数</p>
<ul>
<li>字符串处理函数<ul>
<li>concat(String s1, String s2)：字符串合并/连接函数</li>
<li>substring(String s, int start, int length)：取子串函数</li>
<li>trim([leading|trailing|both,] [char c,] String s)：去掉字符串的首/尾/指定的字符或空格</li>
<li>lower(String s)：将字符串转换成小写</li>
<li>upper(String s)：将字符串转换成大写</li>
<li>length(String s)：获取字符串长度</li>
<li>locate(String s1, String s2[, int start])：从第一个字符串中查找第二个字符串出现的位置，若未找到则返回 0</li>
</ul>
</li>
<li>算术函数<ul>
<li>abs</li>
<li>mod</li>
<li>sqrt</li>
<li>size（用于求集合的元素个数）</li>
</ul>
</li>
<li>日期函数<ul>
<li>current_date</li>
<li>current_time</li>
<li>current_timestamp</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h5 id="整合-Spring"><a href="#整合-Spring" class="headerlink" title="整合 Spring"></a>整合 Spring</h5><ol>
<li><p>三种整合方式</p>
<ul>
<li>LocalEntityManagerFactoryBean：适用于那些仅使用 JPA 进行数据访问的项目，该 FactoryBean 将根据 JPA Persistence Provider 自动检测配置文件进行工作，一般从 META-INF/persistence.xml 文件中读取配置信息。这种方式最简单，但是不能设置 Spring 中定义的 DataSource，且不支持 Spring 管理的全局事务</li>
<li>从 JNDI 获取：用于从 JavaEE 服务器获取制定的 EntityManagerFactory，这种方式在进行 Spring 事务管理一般要使用 JTA 事务管理</li>
<li>LocalContainerEntityManagerFactoryBean：适用于所有环境的 FactoryBean，能全面控制 EntityManagerFactory 配置，如指定 Spring 定义的 DataSource 等</li>
</ul>
</li>
<li><p>Spring 配置文件中需要配置的</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置 EntityManagerFactory --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;entityManagerFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 配置 JPA 提供商的适配器. 可以通过内部 bean 的方式来配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jpaVendorAdapter&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 配置实体类所在的包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;packagesToScan&quot;</span> <span class="attr">value</span>=<span class="string">&quot;beiran.bean&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 配置 JPA 的基本属性. 例如 JPA 实现框架的属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jpaProperties&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.show_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.format_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.hbm2ddl.auto&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置 JPA 使用的事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;entityManagerFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;entityManagerFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置支持基于注解是事务配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 DAO 中使用 @PersistenceContext 注解来注入 EntityManager 实例</p>
</li>
</ol>
]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>N3 补充语法</title>
    <url>/%E6%97%A5%E8%AF%AD/N3-%E8%A1%A5%E5%85%85%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<ol>
<li><p><strong>イ形容詞の語幹＋<span style="color: red;">くないです</span></strong><a id="more"></a><br> <strong>イ形容詞の語幹＋<span style="color: red;">くありません</span></strong></p>
<p> 这两种「イ形容詞」的敬语否定形式的意义、功能相同。</p>
</li>
<li><p><strong>イ形容詞の語幹＋<span style="color: red;">くなかったです</span></strong><br> <strong>イ形容詞の語幹＋<span style="color: red;">くありませんでした</span></strong></p>
<p> 这两种「イ形容詞」的敬语否定形式（过去时）的意义、功能相同。</p>
</li>
<li><p><strong>主語＋<span style="color: red;">が（の）</span>用言＋名詞</strong></p>
<p> 当主谓句做定语修饰名词时，在不引起误会的情况下，其主语的格助词「が」可以替换成「の」，意义上不会发生变化。</p>
<p> 例如：</p>
<p> 「母<span style="color: red;">が（の）</span>作った料理を食べました。」</p>
<p> 「天気<span style="color: red;">が（の）</span>いい日は、よく山へ行きます。」</p>
<p> 「あの目<span style="color: red;">が（の）</span>きれいな女の子は誰ですか。」</p>
</li>
<li><p><strong>本<span style="color: red;">も</span>ノート<span style="color: red;">も</span>あります</strong></p>
<p>  「〜も〜も」前接名词，表示并列，意为 “既······也······“。「も」同样也可以接在格助词之后。</p>
<p> 例如：</p>
<p> 「先生<span style="color: red;">も</span>学生<span style="color: red;">も</span>います。」</p>
<p> 「学校<span style="color: red;">でも</span>家<span style="color: red;">でも</span>よく勉強します。」</p>
<p> 「夏休み、山<span style="color: red;">へも</span>海<span style="color: red;">へも</span>行きます。」</p>
</li>
<li><p><strong>このバスは大学へ<span style="color: red;">は</span>行きません。</strong></p>
<p>副助词「は」的作用很多：</p>
<ul>
<li><p>提示句子成分</p>
<p>  例如：</p>
<p>  「日曜日<span style="color: red;">は</span>勉強しません。」</p>
<p>  「日曜日<span style="color: red;">は</span>、うちでのんびりします。」</p>
</li>
<li><p>与谓语的否定形式相呼应</p>
<p>  例如：</p>
<p>  「あの人<span style="color: red;">は</span>学生ではありません。」</p>
<p>  「このバスは大学へ<span style="color: red;">は</span>行きません。」</p>
</li>
<li><p>表示对比</p>
<p>  例如：</p>
<p>  「日本語<span style="color: red;">は</span>勉強しますが、英語<span style="color: red;">は</span>勉強しません。」</p>
<p>  「富士山<span style="color: red;">は</span>見たことはありますが、登ったこと<span style="color: red;">は</span>ありません。」</p>
</li>
</ul>
</li>
<li><p><strong>今日<span style="color: red;">か</span>明日<span style="color: red;">（か）</span>来てください</strong></p>
<p> 「〜か〜（か）」意为 “～或（者）～” “～还是～”。</p>
<p> 例如：</p>
<p> 「電車<span style="color: red;">か</span>バス<span style="color: red;">（か）</span>で学校へ行きます。」</p>
<p> 「進学する<span style="color: red;">か</span>就職する<span style="color: red;">か</span>で悩んでいます。」</p>
<p> 「その小説は面白い<span style="color: red;">か</span>つまらない<span style="color: red;">か</span>読んでから分かる。」</p>
</li>
<li><p><strong>行く<span style="color: red;">か</span>行か<span style="color: red;">ないか</span>分かりません</strong></p>
<p> 句型「〜か〜か」前后可以使用同一个词的肯定形式和否定形式，构成「〜か〜ないか」的形式，意为 “是～还是不～”。</p>
<p> 例如：</p>
<p> 「その小説は面白い<span style="color: red;">か</span>面白く<span style="color: red;">ないか</span>読んでからでない分かりません。」</p>
<p> 「あの人は来る<span style="color: red;">か</span>来<span style="color: red;">ないか</span>知っています。」</p>
<p> 「田中さんは先生<span style="color: red;">か</span>先生で<span style="color: red;">ないか</span>よくわかりません。」</p>
</li>
<li><p><strong>あの部屋に人が３０人<span style="color: red;">ぐらい</span>います</strong></p>
<p> 「数量詞＋ぐらい」表示概数，意为 “大概～” “～左右”。</p>
<p> 例如：</p>
<p> 「家までバスで２０分<span style="color: red;">ぐらい</span>かかります。」</p>
<p> 「今度の日帰り旅行は、１万円<span style="color: red;">ぐらい</span>かかりました。」</p>
<p> 「庭には３歳<span style="color: red;">ぐらい</span>の女の子が立っています。」</p>
</li>
<li><p><strong>私も一緒に行く<span style="color: red;">わ</span></strong></p>
<p> 终助词「わ」放在句尾，表示轻微的意志、主张。女性使用较多。</p>
<p> 例如：</p>
<p> 「知らない<span style="color: red;">わ</span>。」</p>
<p> 「私は行かない<span style="color: red;">わ</span>。」</p>
<p> 「この方がいいと思う<span style="color: red;">わ</span>。」</p>
</li>
<li><p><strong>こちらの方が<span style="color: red;">（お）</span>安<span style="color: red;">うございます</span></strong></p>
<p>「ございます」是「ある」的礼貌语，以「（お）イ形容詞＋ございます」的形式构成郑重表达形式。有时形容词的词尾「い」会发生音变，由「い」变为「う」。</p>
<p>例如：</p>
<p>「<span style="color: red;">お</span>早う<span style="color: red;">ございます</span>。」</p>
<p>「<span style="color: red;">お</span>めでとう<span style="color: red;">ございます</span>。」</p>
</li>
<li><p><strong>妹を泣<span style="color: red;">かせて</span>はいけません</strong></p>
<p> 助动词「〜（さ）せる」除了表示强制以外，还可以表示引起某事（「誘発」）。</p>
<p> 例如：</p>
<p> 「先生はいつも冗談を言って、生徒を笑<span style="color: red;">わせた</span>。」</p>
<p> 「二年も続けて合格できなくて、母をがっかり<span style="color: red;">させた</span>。」</p>
</li>
<li><p><strong>子供のころ、母にいろいろな野菜を食べ<span style="color: red;">させられました</span></strong></p>
<p> 助动词「〜（さ）せる」与表示被动的助动词「〜（ら）れる」构成使役被动态，表示 “被迫做～”。使役被动态的动词变化方式参照「みんなの日本語初級２第４８課」。</p>
<p> 例如：</p>
<p> 「昨日は、母に４時間も勉強<span style="color: red;">させられました</span>。」</p>
<p> 「友達に無理にお酒を飲<span style="color: red;">まされました</span>。」</p>
</li>
<li><p><strong>あの人は今日かばんを持た<span style="color: red;">ずに</span>家を出ました</strong></p>
<p> 「动词1 ないで + 动词2」的形式用于表示动词2 的附带动作或状态。这里的「〜ないで」可以用「ずに」进行替换，构成「动词1 ずに + 动词2」的形式，意思相同。</p>
<p> 例如：</p>
<p> 「朝ご飯を食べ<span style="color: red;">ないで</span>、学校へ行きました。」</p>
<p> 「朝ご飯を食べ<span style="color: red;">ずに</span>、学校へ行きました。」</p>
<p> 「傘を持た<span style="color: red;">ないで</span>出かけたので、雨に降られてしまった。」</p>
<p> 「傘を持た<span style="color: red;">ずに</span>出かけたので、雨に降られてしまった。」</p>
</li>
<li><p><strong>この漢字は<span style="color: red;">こう</span>書きます</strong></p>
<p> 「こそあど」系列词中的副词类「こう、そう、ああ、どう」修饰动词。「こう」意为 “这样、这么”，表示说话人刚刚表达过的内容或即将表达的内容。</p>
<p> 例如：</p>
<p> 「私は<span style="color: red;">こう</span>思います。」</p>
<p> 「それでは<span style="color: red;">こう</span>してください。」</p>
</li>
<li><p><strong>あの人はいつも<span style="color: red;">ああ</span>言います</strong></p>
<p> 「こそあど」系列词中的副词类「こう、そう、ああ、どう」修饰动词。「ああ」意为 ”那样、那么“，表示双方都知道的状态或者场面。</p>
<p> 例如：</p>
<p> 「<span style="color: red;">ああ</span>まで言わなくていいです。」</p>
<p> 「<span style="color: red;">ああ</span>強くては歯が立たない。」</p>
</li>
<li><p><strong>そんなことをし<span style="color: red;">ちゃ</span>いけないよ</strong></p>
<p> 「〜てはいけない」意为 ”不许～“。其中，「ては」的口语缩略形式为「ちゃ」，所以「〜てはいけない」的口语形式为「〜ちゃいけない」。</p>
<p> 例如：</p>
<p> 「遅くなっ<span style="color: red;">ちゃ</span>だめですよ。」</p>
<p> 「怠け<span style="color: red;">ちゃ</span>いけませんよ。」</p>
</li>
<li><p><strong>彼はパンをいつつ<span style="color: red;">も</span>食べました</strong></p>
<p> 副助词「も」接在数量词之后与谓语的否定形式相呼应，表示超出预期；与谓语的否定形式相呼应，则表示低于预期。</p>
<p> 例如：</p>
<p> 「今日の講演会には１００人<span style="color: red;">も</span>来ました。」</p>
<p> 「雨は何日<span style="color: red;">も</span>降り続いた。」</p>
<p> 「あの本は千円<span style="color: red;">も</span>かかりませんでした。」</p>
</li>
<li><p><strong>この子は毎日テレビ<span style="color: red;">ばかり</span>見ています</strong></p>
<p> 副助词「〜ばかり」接在体言后表示事物涉及的范围只偏向于一个，意为 ”净“ ”光“。</p>
<p> 例如：</p>
<p> 「妹の家<span style="color: red;">ばかり</span>に行きます。」</p>
<p> 「あの人は文句<span style="color: red;">ばかり</span>言っています。」</p>
<p> 「家に<span style="color: red;">ばかり</span>閉じこもっている人が多い。」</p>
</li>
<li><p><strong>あなたも一緒に行く<span style="color: red;">の</span></strong></p>
<p> 终助词「の」放在句尾伴随升调表示疑问、确认。</p>
<p> 例如：</p>
<p> 「まだ帰らない<span style="color: red;">の</span>。」</p>
<p> 「どうした<span style="color: red;">の</span>。」</p>
<p> 「仕事があるんじゃなかった<span style="color: red;">の</span>。」</p>
</li>
<li><p><strong>どうしたん<span style="color: red;">だい</span></strong></p>
<p> 「だい」由判断助动词「だ」和终助词「い」构成，放在句尾，与表示疑问的词一起使用，为质问增添亲近的语气。</p>
<p> 例如：</p>
<p> 「あの人は誰<span style="color: red;">だい</span>。」</p>
<p> 「何をしているん<span style="color: red;">だい</span>。」</p>
</li>
<li><p><strong>このウィスキー、飲む<span style="color: red;">かい</span></strong></p>
<p> 「かい」由终助词「か」和终助词「い」构成，表示一般的询问、反问、确认等。</p>
<p> 例如：</p>
<p> 「もう行くの<span style="color: red;">かい</span>。」</p>
<p> 「そんなこと誰がやる<span style="color: red;">かい</span>。」</p>
<p> 「そうかい。嫌だって言うの<span style="color: red;">かい</span>。」</p>
</li>
<li><p><strong>あの人は、本当に男<span style="color: red;">らしい</span>人だと思いますよ</strong></p>
<p> 接尾词「らしい」接在名词后面表示具有该名词本身应该具有的特征。</p>
<p> 例如：</p>
<p> 「彼は外国人ですが、日本語<span style="color: red;">らしい</span>日本語を話しています。」</p>
<p> 「今日は春<span style="color: red;">らしい</span>天気ですね。」</p>
</li>
<li><p><strong>子どもは甘い物を欲し<span style="color: red;">がる</span></strong></p>
<p> 「〜がほしい」表示第一人称的愿望。如果想要表示第三人称的愿望时，则需要对表示感情色彩的「イ形容詞」与「ナ形容詞」进行变形，使用「イ形容詞」与「ナ形容詞」的词干，后面接续接尾词「がる」。其对象语也由「が」变成「を」。</p>
<p> 例如：</p>
<p> 「李さんはお母さんが作った料理<span style="color: red;">を食べたがっている</span>。」</p>
<p> 「子どもは自分と同じぐらいの大きさの犬<span style="color: red;">をかわいがっている</span>。」</p>
<p> 「注射<span style="color: red;">をいやがる</span>人が多い。」</p>
</li>
<li><p><strong>彼は何をし<span style="color: red;">ようとして</span>いるのですか</strong></p>
<p> 「动作动词的意向形 + とする」表示为实现该动作而进行的努力和尝试。</p>
<p> 例如：</p>
<p> 「娘は東大に<span style="color: red;">入ろうとして</span>います。」</p>
<p> 「いくら<span style="color: red;">思い出そうとして</span>も、思い出せないことがある。」</p>
</li>
<li><p><strong>私は毎日ジョギングする<span style="color: red;">ことにしました</span></strong></p>
<p> 「动词字典形 + ことにする」表示 ”决定做～“ ，不管最终有没有做，只要做出了决定，一般都使用过去时。</p>
<p> 例如：</p>
<p> 「明日からコーヒーを<span style="color: red;">飲まないことにしました</span>。」</p>
<p> 「明日から毎日１０分間日本語を<span style="color: red;">朗読することにしました</span>。」</p>
</li>
<li><p><strong>私は<span style="color: red;">カレーライスにする</span></strong></p>
<p> 「N + する」表示 ”决定“。</p>
<p> 例如：</p>
<p> 「昼食は<span style="color: red;">カレーにしました</span>。」</p>
<p> 「私は<span style="color: red;">ジュースにします</span>。」</p>
</li>
<li><p><strong>明日学校を休<span style="color: red;">ませてください</span></strong></p>
<p> 「动词使役态 + てください」表示 “请求允许”，意为 “请允许～” “请让我来～”。</p>
<p> 例如：</p>
<p> 「すみませんが、今日は早く<span style="color: red;">帰らせてください</span>。」</p>
<p> 「この仕事はぜひ私に<span style="color: red;">やらせてください</span>。」</p>
</li>
<li><p><strong>ゆうべ８時ごろから雨が降り<span style="color: red;">始めました</span></strong></p>
<p> 「はじめる」接在动词的「ます形」后构成复合动词，表示某动作开始实施，意为 “开始～”。</p>
<p> 例如：</p>
<p> 「事務所前の桜がやっと<span style="color: red;">咲き始めた</span>。」</p>
<p> 「同席者を待たずに、<span style="color: red;">食べ始める</span>のはマナー違反です。」</p>
</li>
<li><p><strong>その子は急に泣き<span style="color: red;">出した</span></strong></p>
<p> 「だす」接在动词的「ます形」后构成复合动词，表示某动作开始，意为 “～起来”。</p>
<p> 例如：</p>
<p> 「雨が急に<span style="color: red;">降り出した</span>。」</p>
<p> 「<span style="color: red;">言い出した</span>ら、後へは引かない。」</p>
</li>
<li><p><strong>あんな寒いところへは誰も行き<span style="color: red;">たがらない</span>だろう</strong></p>
<p> 接尾词「〜がる」接在表示感情色彩的「イ形容詞」和「ナ形容詞」，以及助动词「たい」的词干后，表示第三人称外表所展现的样子。其变化形式与 I 类动词一致，否定形式为「〜がらない」。</p>
<p> 例如：</p>
<p> 「彼は中国料理を<span style="color: red;">食べたがらない</span>だろう。」</p>
<p> 「子どもはそんなおもちゃを<span style="color: red;">欲しがらない</span>だろう。」</p>
</li>
<li><p><strong>テレビを見たい人は見<span style="color: red;">てもかまいません</span></strong></p>
<p> 表示同意、许可，一般可以使用「〜てもいいです」这一形式，另外还有一种形式是「〜てもかまいません」。「〜てもいいです」只是单纯地表示同意、允许对方做某事，而「〜てもかまいません」除了表示同意、允许外，还带有此行为不会影响自己的语感。疑问句时，「〜てもいいですか」只是询问对方同意与否，而「〜てもかまいませんか」还带有询问对方自己的行为是否会给对方造成麻烦的语感。</p>
<p> 例如：</p>
<p> 「すみません。ここで<span style="color: red;">待っていてもかまいません</span>か。」</p>
<p> 「窓を<span style="color: red;">開けてもかまいません</span>。」</p>
<p> 「今すぐできないのなら、あとで<span style="color: red;">やってもかまいません</span>。」</p>
</li>
<li><p><strong>長い間本を<span style="color: red;">読み続け</span>ていると、目が痛くなる</strong></p>
<p> 「〜続ける」接在动词的「ます形」后构成复合动词，表示某动作或行为不间断地持续着，意为 ”一直～“。</p>
<p> 例如：</p>
<p> 「あの人は日本一になってから、２０年間、ずっと<span style="color: red;">勝ち続けている</span>。」</p>
<p> 「この機械をずっと<span style="color: red;">使い続ける</span>理由はどこにありますか。」</p>
</li>
<li><p><strong>晩ごはんを<span style="color: red;">食べ終わ</span>ってから、みんなでトランプをした</strong></p>
<p> 「〜終わる」接在动词的「ます形」后构成复合动词，表示某动作结束，意为 ”～完“。</p>
<p> 例如：</p>
<p> 「汚れた服は全部<span style="color: red;">洗い終わりました</span>。」</p>
<p> 「借金はこれで<span style="color: red;">払い終わった</span>。」</p>
</li>
<li><p><strong>この山の写真は田中先生に<span style="color: red;">さしあげる</span>つもりです</strong></p>
<p> 「さしあげる」是「あたえる」「やる」的谦让语，表示呈送、敬献。</p>
<p> 例如：</p>
<p> 「お茶を<span style="color: red;">さしあげ</span>ずに失礼しました。」</p>
<p> 「お中元を<span style="color: red;">さしあげました</span>ので、お収めください。」</p>
</li>
<li><p><strong>わかりにくいところですから、地図を書い<span style="color: red;">てさし上げ</span>ましょうか</strong></p>
<p> 「〜てさし上げる」接在动词的「て形」后，较「〜してあげる」所含敬意更高，更加礼貌。</p>
<p> 例如：</p>
<p> 「少しおまけし<span style="color: red;">てさしあげましょう</span>。」</p>
<p> 「事務室までご案内し<span style="color: red;">てさしあげなさい</span>。」</p>
</li>
<li><p><strong>明日いい天気だ<span style="color: red;">と</span>、いいね（仮定）</strong></p>
<p> 接续助词「と」以「〜といい」的形式，表示希望变成那样。如果伴随「が」「けど」「のに」等词一起使用时，则含有 “也许实现不了” 的语感。</p>
<p> 例如：</p>
<p> 「早く治る<span style="color: red;">と、いい</span>ね。」</p>
<p> 「勉強部屋がもっと<span style="color: red;">広いといい</span>のになあ。」</p>
</li>
<li><p><strong>窓を開ける<span style="color: red;">と</span>、雪が降っていた（発見の「と」）</strong></p>
<p> 接续助词「と」表示说话人在前项成立的情况下，发现了后项描述的状况。</p>
<p> 例如：</p>
<p> 「家に帰る<span style="color: red;">と</span>、食事の支度ができていた。」</p>
<p> 「あそこに着く<span style="color: red;">と</span>、出迎えのバスは既に来ていた。」</p>
</li>
<li><p><strong>私は、どんなことがあっ<span style="color: red;">ても</span>、あなたのことを忘れません</strong></p>
<p> 「〜ても」以「どんなことがあっても」「どんなに〜ても」的形式表示退让性转折，意为 “即便～，也（不）～”。</p>
<p> 例如：</p>
<p> 「<span style="color: red;">どなんにつらくても</span>、頑張っていきます。」</p>
<p> 「<span style="color: red;">どんな複雑な問題があって</span>、彼は解決してくれます。」</p>
</li>
<li><p><strong>木村さんは昨日東京へ行った<span style="color: red;">らしい</span>です</strong></p>
<p> 助动词「らしい」接在句尾，表示说话人认为该内容的可信度很高，意为 “好像～”。其依据是外部信息或是可观察到的现象等客观的东西，而不是主观的想象。</p>
<p> 例如：</p>
<p> 「天気予報によると、明日は<span style="color: red;">雨らしい</span>。」</p>
<p> 「あの人は有名な<span style="color: red;">作家らしい</span>。」</p>
</li>
<li><p><strong>冬は風邪を引き<span style="color: red;">やすい</span>（そのような傾向がある）</strong></p>
<p> 「〜やすい」可以表示事物具备某种特征，而这里的「〜やすい」则表示容易发生某种事情。</p>
<p> 例如：</p>
<p> 「夏は雨が<span style="color: red;">降りやすい</span>です。」</p>
<p> 「北京では春は風が<span style="color: red;">吹きやすい</span>。」</p>
</li>
<li><p><strong>ヘリコプターは飛行機<span style="color: red;">ほど</span>速く<span style="color: red;">ない</span>です</strong></p>
<p> 以「A は B ほど〜ない」的形式，表示 “B” 为标准，而 “A” 不如 “B” 这一标准，意为 “A 不如 B～”。</p>
<p> 例如：</p>
<p> 「今度の試験は思っていた<span style="color: red;">ほど難しくありませんでした</span>。」</p>
<p> 「今年の冬は去年<span style="color: red;">ほど寒くなかった</span>。」</p>
</li>
<li><p><strong>父は子どもの<span style="color: red;">よう</span>です</strong></p>
<p> 助动词「〜ようだ」接在「N + の」「A い / N A な」之后，表示比喻。不仅可以比喻成同一事物，还可以比喻成完全不同的事物。其连体形、连用形分别为「ような」和「ように」，还可以与副词「まるで」「あたかも」等呼应使用。</p>
<p> 例如：</p>
<p> 「彼女の心はまるで氷の<span style="color: red;">ように</span>冷たいです。」</p>
<p> 「彼はあたかも魚の<span style="color: red;">ように</span>泳いでいます。」</p>
<p> 「このパンは硬くて石の<span style="color: red;">よう</span>です。」</p>
<p> 「彼女は赤ん坊の<span style="color: red;">ような</span>手をしています。」</p>
<p> 「彼はまるでお酒でも飲んだ<span style="color: red;">ような</span>赤い顔をしていました。」</p>
</li>
<li><p><strong>食後にこの薬を飲み<span style="color: red;">なさい</span></strong></p>
<p> 「〜なさい」接在动词的「ます形」后，表示按照指示做，意为 “请～”。</p>
<p> 例如：</p>
<p> 「文章を読んで、後の質問に<span style="color: red;">答えなさい</span>。」</p>
<p> 「早く<span style="color: red;">食べなさい</span>。」</p>
</li>
<li><p><strong>事故の<span style="color: red;">ため（に）</span>電車が遅れました</strong></p>
<p> 「ため（に）」除了表示目的和受益对象外，还可以用来客观地陈述原因，意为 “因为～，～”。</p>
<p> 例如：</p>
<p> 「病気の<span style="color: red;">ため</span>、学校を休みました。」</p>
<p> 「友達が訪ねてきた<span style="color: red;">ために</span>、約束の時間に遅れてしまった。」</p>
</li>
<li><p><strong>あの人は時々学校を<span style="color: red;">休むことがある</span></strong></p>
<p> 「V たことがある」表示经历，而「V ることがある」则表示有时会发生这样的事情，常常与副词「ときどき」呼应使用。</p>
<p> 例如：</p>
<p> 「私は時々一人で映画を見に<span style="color: red;">行くことがある</span>。」</p>
<p> 「彼は仕事が忙しくて、食事の時間を<span style="color: red;">取れないこともある</span>そうです。」</p>
</li>
<li><p><strong>この学校では２ヶ月に一度試験をする<span style="color: red;">ことになっている</span></strong></p>
<p> 「〜ことになっている」表示日常生活中约束人们行为的各种规定。</p>
<p> 例如：</p>
<p> 「学校を休むときは必ず学校に連絡しなければならない<span style="color: red;">ことになっている</span>。」</p>
<p> 「デパートではこの商品を買うお客様に景品を差し上げる<span style="color: red;">ことになっている</span>。」</p>
</li>
<li><p><strong>あの人にはあまり心配しない<span style="color: red;">ように言ってください</span></strong></p>
<p> 在带有「〜てください」「〜なさい」「〜ないでください」等命令、请求的直接引语变为间接引语时，需要使用「〜ように言う」的形式。</p>
<p> 例如：</p>
<p> 「お母さんは私に「今晩早く帰ってください」と言いました。」</p>
<p> ······「お母さんは私に<span style="color: red;">今晩早く帰るように言いました</span>。」</p>
<p> 「お医者さんは「これからタバコを吸わないでください」と言いました。」</p>
<p> ······「お医者さんはこれからタバコを<span style="color: red;">吸わないように言いました</span>。」</p>
</li>
</ol>
]]></content>
      <categories>
        <category>日语</category>
      </categories>
      <tags>
        <tag>日语</tag>
        <tag>语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-MVC</title>
    <url>/Spring/Spring-MVC/</url>
    <content><![CDATA[<h5 id="SpringMVC-概述"><a href="#SpringMVC-概述" class="headerlink" title="SpringMVC 概述"></a>SpringMVC 概述</h5><ol>
<li>采用松散耦合可拔插组件结构，支持 RESTful API 请求<a id="more"></a></li>
</ol>
<hr>
<h5 id="使用-RequestMapping-映射请求"><a href="#使用-RequestMapping-映射请求" class="headerlink" title="使用 @RequestMapping 映射请求"></a>使用 <code>@RequestMapping</code> 映射请求</h5><ol>
<li>在控制器的类定义及方法定义处都可标注 <code>@RequestMapping</code><ul>
<li>类定义处：提供初步的请求映射信息，相对于 Web 应用的根目录</li>
<li>方法处：提供进一步的细分映射信息，相对于类定义处的 URL，若类定义处未标注 <code>@RequestMapping</code> ，则方法处标注的 URL 相对于 Web 应用的根目录</li>
</ul>
</li>
<li><code>@RequestMapping</code> 除了可以使用请求 URL 映射请求外，还可以使用请求方法、请求参数及请求头映射请求<ul>
<li><code>@RequestMapping</code> 的 value、method、params、headers 分别表示请求 URL、请求方法、请求参数及请求头的映射条件，它们之间是与的关系，联合使用多个条件可以让请求更加精确化</li>
<li>params 和 headers 支持简单的表达式：<ul>
<li>param1：表示请求必须包含名为 param1 的请求参数</li>
<li>!param1：表示请求不能包含名为 param1 的请求参数</li>
<li>param1 != value1：表示请求包含名为 param1 的请求参数，但是其值不能为 value1</li>
<li>{ “param1 = value1”, “param2” }：表示请求必须包含名为 param1 和 param2 的两个请求参数，且 param1 参数的值必须为 value1</li>
</ul>
</li>
</ul>
</li>
<li><code>@RequestMapping</code> 还支持 Ant 风格的 URL<ul>
<li>Ant 风格资源地址支持三种匹配符：<ul>
<li>? ：匹配文件名中的一个字符</li>
<li>* ：匹配文件名中的任意字符</li>
<li>** ：匹配多层路径</li>
</ul>
</li>
</ul>
</li>
<li><code>@PathVariable</code> 映射 URL 绑定的占位符<ul>
<li>带占位符的 URL 是 Spring3.0 新增的功能</li>
<li>通过 <code>@PathVariable</code> 可以将 URL 中占位符参数绑定到控制器处理方法的入参中：URL 中的 { xxx } 占位符可以通过 <code>@PathVariable(&#39;xxx&#39;)</code> 绑定到操作方法的入参中</li>
</ul>
</li>
<li>REST ：即 Representational State Transfer 。（资源）表现层状态转化<ul>
<li>资源（ Resources ）：可以用一个 URI （统一资源定位符）来指向它</li>
<li>表现层（ Representation ）：把资源具体呈现出来的形式，叫做他的表现层</li>
<li>状态转化（ State Transfer ）：HTTP 协议中四个表示操作方式的动词：GET、POST、PUT、DELETE 分别对应四种基本操作：GET 用来获取资源；POST 用来新建资源；PUT 用来更新资源；DELETE 用来删除资源</li>
</ul>
</li>
<li>HiddenHttpMethodFilter：将 form 表单不支持的请求转换为标准的 http 方法</li>
</ol>
<hr>
<h5 id="映射请求参数-amp-请求头"><a href="#映射请求参数-amp-请求头" class="headerlink" title="映射请求参数 &amp; 请求头"></a>映射请求参数 &amp; 请求头</h5><ol>
<li>SpringMVC 通过分析处理方法的签名，将 HTTP 请求信息绑定到处理方法的相应入参中<ul>
<li>必要时可以通过对方法及方法入参使用相应的注解（ <code>@PathVariable</code>，<code>@RequestParam</code>，<code>@RequestHeader</code> 等）</li>
<li>在处理方法入参处使用 <code>@RequestParam</code> 可以把请求参数传递给请求方法<ul>
<li>value：参数名</li>
<li>required：是否必须，默认为 true</li>
<li>defaultValue：默认值</li>
</ul>
</li>
<li>使用 <code>@RequestHeader</code> 注解可以获取请求头中的属性值</li>
<li>使用 <code>@CookieValue</code> 注解可以让处理方法入参绑定某个 Cookie 值</li>
<li>SpringMVC 会按请求参数名和 POJO 属性名进行自动匹配，自动为该对象填充属性值，支持级联属性（即属性为另一个类的实例）。<strong>注意请求参数名要与 POJO 属性名一致</strong></li>
<li>SpringMVC 支持的传入参数类型有：<ul>
<li>HttpServletRequest</li>
<li>HttpServletResponse</li>
<li>HttpSession</li>
<li>java.security.Principal</li>
<li>Locale</li>
<li>InputStream</li>
<li>OutPutStream</li>
<li>Reader</li>
<li>Writer</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h5 id="处理模型数据"><a href="#处理模型数据" class="headerlink" title="处理模型数据"></a>处理模型数据</h5><ol>
<li>SpringMVC 提供了以下几种途径输出模型数据：<ul>
<li>ModelAndView：处理方法返回值类型为 ModelAndView 时，方法体即可通过该对象添加模型数据</li>
<li>Map 及 Model：入参为 org.springframework.ui.Model、org.springframework.ui.ModelMap 或 java.util.Map 时，处理方法返回时，Map 中的数据会自动添加到模型中。SpringMVC 在调用方法前会创建一个隐含的模型对象作为模型数据的存储容器，如果方法的入参为 Map 或 Model 类型，SpringMVC 会将隐含模型引用传递给这些入参。在方法体内，开发者可以通过这个入参对象访问到模型中的所有数据，也可以向模型中添加新的属性数据</li>
<li><code>@SessionAttributes</code> ：将模型中的某个属性暂时存放到 HttpSession 中，以便多个请求之间可以共享这个属性。除了可以通过属性名指定需要放到 session 中的属性外，还可以通过模型属性的对象类型指定哪些模型属性需要放到 session 中<ul>
<li><code>@SessionAttribute(value = &#123; &#39;user1&#39;,.&#39;user2&#39; &#125;, types = User.class)</code> ：会将隐含模型中所有类型为 User.class 的属性添加到 session 中，并且也会将属性名为 user1 和 user2 的属性添加到 session 中</li>
</ul>
</li>
<li><code>@ModelAttribute</code> ：方法入参使用这个注解后，入参的对象就会放入到数据模型中。注意键要与入参一致</li>
</ul>
</li>
</ol>
<hr>
<h5 id="视图和视图解析器"><a href="#视图和视图解析器" class="headerlink" title="视图和视图解析器"></a>视图和视图解析器</h5><ol>
<li><p>请求处理方法执行完成后，最终返回一个 ModelAndView 对象，对于那些返回 String，View 或者 ModelMap 等类型的处理方法，SpringMVC 也会在内部将他们装配成一个 ModelAndView 对象，他包含了逻辑名和模型对象的视图</p>
</li>
<li><p>SpringMVC 借助视图解析器得到最终的视图对象 View，处理器工作重点在生成模型数据的工作上，从而实现 MVC 的充分解耦</p>
</li>
<li><p>视图的作用是渲染模型数据，org.springframework.web.servlet 包中定义了一个高度抽象的 View 接口</p>
</li>
<li><p>视图对象由视图解析器负责实例化，由于视图是无状态的，所以不会有线程安全问题</p>
<p> <img src="%E5%9B%BE1.jpg"></p>
<p> <img src="%E5%9B%BE2.png"></p>
</li>
<li><p>直接访问页面不经过 Handler 可以在 SpringMVC 配置文件中加入一个 <code>&lt;mvc:view-controller path=&quot;&quot; view-name=&quot;&quot;/&gt;</code> ，path 为 URL 地址，view-name 为视图名</p>
</li>
<li><p>自定义视图可以使用 BeanNameViewResolver 来解析，注意需要在自定义视图上加上 <code>@Component</code> 注解（将其加入 IOC 容器）。可以使用 order 属性来定义视图解析器的优先级，order 的值越小优先级越高</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- order 值越小 优先级越高 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.BeanNameViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;99&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h5 id="RESTful-CRUD"><a href="#RESTful-CRUD" class="headerlink" title="RESTful CRUD"></a>RESTful CRUD</h5><ol>
<li>users GET</li>
<li>user POST</li>
<li>user/id DELETE</li>
<li>user/id PUT</li>
</ol>
<hr>
<h5 id="SpringMVC-表单标签-amp-处理静态资源"><a href="#SpringMVC-表单标签-amp-处理静态资源" class="headerlink" title="SpringMVC 表单标签 &amp; 处理静态资源"></a>SpringMVC 表单标签 &amp; 处理静态资源</h5><ol>
<li>form 标签<ul>
<li>一般情况下通过 GET 请求获取表单页面，而通过 POST 请求提交表单页面，因此获取表单页面和提交表单页面的 URL 是相同的</li>
<li>可以通过 modelAttribute 属性指定绑定的模型属性，若没有指定该属性，则默认从 request 域中读取 command 的表单 bean，如果该属性值也不存在则会发生错误</li>
<li>SpringMVC 提供了多个表单组件标签，如 &lt;form:input /&gt;、&lt;form:select /&gt; 等，用来绑定表单字段的属性值，他们共有属性如下：<ul>
<li>path：表单字段，对应 html 元素的 name 属性，支持级联属性</li>
<li>htmlEscape：是否对表单值的 HTML 特殊字符进行转换，默认为 true</li>
<li>cssClass：表单组件对应的 CSS 样式类名</li>
<li>cssErrorClass：表单组件的数据存在错误时，采取的 CSS 样式</li>
</ul>
</li>
<li>form:radiobuttons：单选框组件标签，用于构造多个单选框：<ul>
<li>items：可以是一个 List、String[] 或 Map</li>
<li>itemValue：指定 radio 的 value 值，可以是集合中 bean 的一个属性值</li>
<li>itemLabel：指定 radio 的 label 值</li>
<li>delimiter：多个单选框可以通过 delimiter 指定分隔符</li>
</ul>
</li>
<li>form:errors：显示表单组件或数据校验所对应的错误：<ul>
<li>&lt;form:errors path=“*” /&gt; 显示表单所有的错误</li>
<li>&lt;form:errors path=“user*” /&gt; 显示所有以 user 为前缀的属性对应的错误</li>
<li>&lt;form:errors path=“username” /&gt; 显示特定表单对象属性的错误</li>
</ul>
</li>
<li>可以使用重定向进行数据表单回显</li>
</ul>
</li>
<li>处理静态资源：<ul>
<li>资源 URL 不希望带 .html 或 .do 等后缀</li>
<li>若将 DispatcherServlet 请求映射配置为 / ，则 SpringMVC 将会捕获所有请求，包括静态资源的请求</li>
<li>可以在 SpringMVC 的配置文件中配置 <code>&lt;mvc:default-servlet-handler /&gt;</code> 的方式解决静态资源的问题<ul>
<li><code>&lt;mvc:default-servlet-handler /&gt;</code> 会在 SpringMVC 上下文中定义一个 DefaultServletHttpRequestHandler，他会对进入 DispatcherServlet 的请求进行筛选，如果是发现没有经过映射的请求，就将该请求交给 Web 服务器的默认 Servlet 处理，如果不是静态资源的请求，才由 DispatcherServlet 继续处理</li>
<li>一般 Web 服务器默认的 Servlet 名称都是 default ，若使用的 Web 服务器默认 Servlet 名称不是 default ，则需要通过 <code>default-servlet-name</code> 属性进行显式指定</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h5 id="数据转换-amp-数据格式化-amp-数据校验"><a href="#数据转换-amp-数据格式化-amp-数据校验" class="headerlink" title="数据转换 &amp; 数据格式化 &amp; 数据校验"></a>数据转换 &amp; 数据格式化 &amp; 数据校验</h5><ol>
<li><p>数据绑定流程：</p>
<ul>
<li>SpringMVC 主框架将 ServletRequest 对象及目标方法的入参实例传递给 WebDataBinderFactory 实例，以创建 DataBinder 实例对象</li>
<li>DataBinder 调用装配在 SpringMVC 上下文中的 ConversionService 组件进行数据类型转换、数据格式化工作，将 Servlet 中的请求信息填充到入参对象中</li>
<li>调用 Validator 组件对已经绑定了请求消息的入参对象进行数据合法性校验，并最终生成 BindingData 对象</li>
<li>SpringMVC 抽取 BindingResult 中的入参对象和校验错误对象，将他们赋给处理方法的响应入参</li>
</ul>
</li>
<li><p>自定义类型转换器</p>
<ul>
<li><p>ConversionService 是 Spring 类型转换体系的核心接口</p>
</li>
<li><p>可以使用 ConversionServiceFactoryBean 在 Spring 的 IOC 容器中定义一个 ConversionService，Spring 将自动识别出 IOC 容器中的 ConversionService，并在 Bean 属性配置及 SpringMVC 处理方法入参绑定等场合使用他进行数据转换</p>
</li>
<li><p>可以通过 ConversionServiceFactoryBean 的 converters 属性注册自定义的类型转换器</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 不使用 NumberFormat 和 DateTimeFormat --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conversionServiceFactoryBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;自定义的类型转换器全类名&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;conversionServiceFactoryBean&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 两者皆有 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conversionServiceFactoryBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;自定义的类型转换器全类名&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;conversionServiceFactoryBean&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>SpringMVC 支持的转换器</p>
<ul>
<li>SpringMVC 定义了三种类型的转换器接口：<ul>
<li>Converter&lt;S, T&gt;：将 S 类型对象转为 T 类型对象</li>
<li>ConverterFactory：将相同系列多个 “同质” Converter 封装在一起。如果希望将一种类型的对象转换为另一种类型及其子类型的对象，可使用该转换器工厂类</li>
<li>GenericConverter：会根据源类对象及目标类对象所在的宿主类中的上下文信息进行类型转换</li>
</ul>
</li>
</ul>
</li>
<li><p>关于 <code>mvc:annotation-driven</code> ：</p>
<ul>
<li><code>&lt;mvc:annotation-driven /&gt;</code> 会自动注册 RequestMappingHandlerMapping、RequestMappingHandlerAdapter 与 ExceptionHandlerExceptionResovler 三个 bean</li>
<li>支持使用 ConversionService 实例对表单参数进行类型转换</li>
<li>支持使用 <code>@NumberFormat</code> 、<code>@DataTimeFormat</code> 注解完成数据类型的格式化</li>
<li>支持使用 <code>@Valid</code> 注解对 JavaBean 实例进行 JSR303 验证</li>
<li>支持使用 <code>@RequestBody</code> 和 <code>@ResponseBody</code> 注解</li>
</ul>
</li>
<li><p><code>@InitBinder</code> 注解</p>
<ul>
<li>由 <code>@InitBinder</code> 标识的方法，可以对 WebDataBinder 对象进行初始化。WebDataBinder 是 DataBinder 的子类，用于完成由表单字段到 JavaBean 属性的绑定</li>
<li><code>@InitBinder</code> 标识的方法不能有返回值，必须声明为 void</li>
<li><code>@InitBinder</code> 方法的参数通常是 WebDataBinder</li>
</ul>
</li>
<li><p>日期格式化</p>
<ul>
<li><code>@DataTimeFormat</code> 注解可对 java.util.Date、java.util.Calender、java.long.Long 时间类型进行标注<ul>
<li>pattern 属性：类型为字符串，指定解析/格式化字段数据的模式，如 “yyyy-MM-dd”</li>
<li>iso 属性：类型为 DateTimeFormat.ISO，指定解析/格式化字段数据的 ISO 模式，包括四种：ISO.NONE（默认）、ISO.DATE（yyyy-MM-dd）、ISO.TIME（hh:mm:ss.SSSZ）、ISO.DATE_TIME（yyyy-MM-dd hh:mm:ss.SSSZ）</li>
<li>style 属性：字符串类型，通过样式指定日期时间的格式，由两位字符组成，第一位表示日期的格式，第二位表示时间的格式：S：短日期/时间格式、M：中日期/时间格式、L：长日期/时间格式、F：完整日期/时间格式、-：忽略日期或时间格式</li>
</ul>
</li>
</ul>
</li>
<li><p>数值格式化</p>
<ul>
<li><code>@NumberFormat</code> ：可对类似数字类型的属性进行标注，他有两个互斥的属性：<ul>
<li>style 属性：类型为 NumberFormat.Style，用于指定样式类型，包括三种：Style.NUMBER（正常数字类型）、Style.CURRENCY（货币类型）、Style.PERCENT（百分数类型）</li>
<li>pattern 属性：类型为 String，自定义样式，如 pattern = “#,###”；</li>
</ul>
</li>
</ul>
</li>
<li><p>类型转换出错的错误信息可以在入参中加入 BindingResult 来进行获取</p>
</li>
<li><p>数据校验：</p>
<ul>
<li>可以使用 Hibernate Validator 来进行数据验证（实现了 JSR303 标准）</li>
<li>注意如果出现了 el 相关的报错，去 Tomcat 安装目录中找到 el-api.jar 包并删除，然后将 Hibernate Validator 中 required 文件夹中 el 相关的 jar 包复制过去即可</li>
<li>在实体类中将需要校验的字段添加 JSR303 标准中的注解</li>
<li>将 Handler 中处理方法有数据校验的入参（实体类入参）添加 <code>@Valid</code> 注解</li>
<li>注意需要校验的 Bean 对象和其绑定结果对象或错误对象是成对出现的，他们之间不允许声明其他参数</li>
<li>错误消息的显示可以使用 &lt;form:errors /&gt; 标签</li>
</ul>
</li>
<li><p>国际化提示信息：</p>
<ul>
<li><p>在 SpringMVC 配置文件中配置国际化资源文件：</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;resourceBundleMessageSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;i18n&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>i18n.properties 文件中键名格式：校验注解名为前缀，结合 modelAttribute、属性名及属性类名（注解名.Bean名（首字母小写）.字段名）</p>
</li>
<li><p>若数据类型转换或数据格式转换时发生错误，或该有的参数不存在，或调用处理方法时发生错误，都会在隐含模型中创建错误消息，其错误代码前缀说明如下：</p>
<ul>
<li>required：必要的参数不存在</li>
<li>typeMismatch：在数据绑定时，发生数据类型不匹配的问题</li>
<li>methodInvocation：SpringMVC 在调用处理方法时发生了错误</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h5 id="处理-JSON：使用-HttpMessageConverter"><a href="#处理-JSON：使用-HttpMessageConverter" class="headerlink" title="处理 JSON：使用 HttpMessageConverter"></a>处理 JSON：使用 HttpMessageConverter</h5><ol>
<li>步骤：<ul>
<li>加入 Jackson 的 jar 包</li>
<li>返回 List</li>
<li>处理方法以 <code>@ResponseBody</code> 注解修饰</li>
</ul>
</li>
<li>HttpMessageConverter&lt;T&gt;<ul>
<li>HttpMessageConverter&lt;T&gt; 是 Spring3.0 新添加的一个接口，负责将请求信息转换为一个类型为 T 的对象，将类型为 T 的对象输出为响应信息</li>
<li>使用 HttpMessageConverter&lt;T&gt; 将请求信息转化并绑定到处理方法的入参中或将响应结果转为对应类型的响应信息，Spring 提供了两种途径：<ul>
<li>使用 <code>@RequestBody</code>/<code>@ResponseBody</code> 对处理方法进行标注</li>
<li>使用 HttpEntity&lt;T&gt;/ResponseEntity&lt;T&gt; 作为处理方法的入参或返回值</li>
<li>当控制器处理方法使用到 <code>@RequestBody</code>/<code>@ResponseBody</code> 或者 HttpEntity&lt;T&gt;/ResponseEntity&lt;T&gt; 时，Spring 首先根据请求头或响应头的 Accept 属性选择匹配的 HttpMessageConverter，进而根据参数类型或泛型类型的过滤得到匹配的 HttpMessageConverter，若找不到可用的 HttpMessageConverter 则报错</li>
<li><code>@RequestBody</code>/<code>@ResponseBody</code> 不需要成对出现</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h5 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h5><ol>
<li><p>默认情况下，SpringMVC 根据 Accept-Language 参数判断客户端的本地化类型</p>
</li>
<li><p>当接收到请求时，SpringMVC 会在上下文中查找一个本地化解析器（LocalResolver），找到后使用他获取请求所对应的本地化类型信息</p>
</li>
<li><p>SpringMVC 还允许装配一个动态更改本地化类型的拦截器，这样通过指定一个请求参数就可用控制单个请求的本地化类型</p>
</li>
<li><p>本地化解析器和本地化拦截器：</p>
<ul>
<li><p>AcceptHeaderLocaleResolver：根据 HTTP 请求头的 Accept-Language 参数确定本地化类型，如果没有显式定义本地化解析器，SpringMVC 使用该解析器</p>
</li>
<li><p>CookieLocaleResolver：根据指定的 Cookie 值确定本地化类型</p>
</li>
<li><p>SessionLocaleResolver：根据 Session 中特定的属性确定本地化类型</p>
</li>
<li><p>LocaleChangeInterceptor：从请求参数中获取本次请求对应的本地化类型</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;localeResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.i18n.SessionLocaleResolver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.i18n.LocaleChangeInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>使用 JSTL 的 fmt 标签可以在页面上的文本进行本地化处理</p>
</li>
<li><p>在 bean 中注入 ResourceBundleMessageSource 的实例，使用其对应的 getMessage 方法即可在 bean 中获取国际化资源文件 Locale 对应的消息</p>
</li>
<li><p>通过配置 LocalResolver 和 LocaleChangeInterceptor 即可通过超链接切换 Locale，而不再依赖于浏览器的语言设置情况</p>
<ul>
<li>需要在链接中添加 locale = zh_CN 这样的国家信息</li>
</ul>
</li>
</ol>
<hr>
<h5 id="文件的上传"><a href="#文件的上传" class="headerlink" title="文件的上传"></a>文件的上传</h5><ol>
<li><p>SpringMVC 为文件上传提供了直接的支持，这种支持是通过即插即用的 MultipartResolver 实现的，Spring 用 Jakarta Commons FileUpload 技术实现了一个 MultipartResolver 实现类：CommonsMultipartResolver</p>
</li>
<li><p>SpringMVC 上下文中默认没有装配 MultipartResolver，因此默认情况下不能处理文件的上传工作，如果想使用 Spring 的文件上传功能，需要在配置文件中配置</p>
</li>
<li><p>配置 MultipartResolver ：</p>
<ul>
<li><p>defaultEncoding：必须和用户 JSP 的 pageEncoding 属性一致，以便正确解析表单的内容</p>
</li>
<li><p>为了让 CommonsMultipartResolver 正确工作，必须先将 Jakarta Commons FileUpload 及 Jakarta Commons IO 的 jar 包添加到类路径下</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;commonsMultipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5242880&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多文件上传只需要多个相同 name 的类型为 file 的 input 类型，然后在处理方法用 MultipartFile 数组接收即可</p>
</li>
</ul>
</li>
</ol>
<hr>
<h5 id="使用拦截器"><a href="#使用拦截器" class="headerlink" title="使用拦截器"></a>使用拦截器</h5><ol>
<li><p>自定义拦截器：</p>
<ul>
<li><p>SpringMVC 也可以使用拦截器对请求进行拦截处理，用户可以自定义拦截器来实现特定的功能，自定义的拦截器必须实现 HandlerInterceptor 接口</p>
<ul>
<li>preHandle()：这个方法在业务处理器处理请求之前被调用，在该方法中对用户请求 request 进行处理。如果决定该拦截器对请求进行拦截处理之后还要调用其他拦截器，或者是业务处理器去进行处理，则返回 true；如果不需要再调用其他的组件去处理请求，则返回 false</li>
<li>postHandle()：这个方法在业务处理器处理完请求后，在 DispatcherServlet 向客户端返回响应前被调用，在该方法中对用户请求 request 进行处理</li>
<li>afterCompletion()：这个方法在 DispatcherServlet 完全处理完请求之后被调用，可以在该方法中进行一些资源清理的操作</li>
</ul>
</li>
<li><p>拦截器的配置</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 拦截所有请求的拦截器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 拦截指定路径的拦截器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/users&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多个拦截器的执行顺序</p>
<p>  <img src="1571924837923.png"><br>  若 SecondInterceptor 的 preHandle 方法返回了 false：</p>
<p>  <img src="1571925064054.png"><br>  若某个拦截器已经执行了 preHandle 方法（即返回 true 的情况），则一定需要执行这个拦截器的 afterCompletion 方法，若某个拦截器执行的 preHandle 方法返回了 false，那么就不需要执行这个拦截器的 afterCompletion 方法</p>
</li>
</ul>
</li>
</ol>
<hr>
<h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><ol>
<li><p>SpringMVC 通过 HandlerExceptionResolver 处理程序的异常，包括 Handler 映射、数据绑定以及目标方法执行时发生的异常</p>
</li>
<li><p>ExceptionHandlerExceptionResolver：</p>
<ul>
<li>主要处理 Handler 中用 <code>@ExceptionHandler</code> 注解定义的方法</li>
<li><code>@ExceptionHandler</code> 注解定义的方法优先级问题：假设发生的异常是 NullPointerException，但是声明的异常有 RuntimeException 和 Exception，此时会根据异常的最近继承关系找到继承深度最浅的那个 <code>@ExceptionHandler</code> 注解方法，即标记了 RuntimeException 的方法</li>
<li>ExceptionHandlerMethodResolver 内部若找不到 <code>@ExceptionHandler</code> 注解的话，会找 <code>@ControllerAdvice</code> 中的 <code>@ExceptionHandler</code> 注解方法</li>
</ul>
</li>
<li><p>在 <code>@ExceptionHandler</code> 注解修饰的方法的参数中可以加入 Exception 类型的参数，该参数对应发生的异常对象。 <code>@ExceptionHandler</code> 方法的参数中不能传入 Map，如果希望把异常信息传至页面可以使用 ModelAndView 作为返回值</p>
</li>
<li><p>ResponseStatusExceptionResolver：</p>
<ul>
<li><p>在异常及异常父类中找到 <code>@ResponseStatus</code> 注解，然后使用这个注解的属性进行处理</p>
</li>
<li><p>定义一个 <code>@ResponseStatus</code> 注解修饰的异常类：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseStatus(HttpStatus.UNAUTHORIZED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnauthorizedException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>若在处理方法中抛出了上述异常：若 ExceptionHandlerExceptionResolver 不解析上述异常。由于触发的异常 UnauthorizedException 带有 <code>@ResponseStatus</code> 注解。因此会被 ResponseStatusExceptionResolver 解析到。最后响应 HttpStatus.UNAUTHORIZED 代码给客户端，HttpStatus.UNAUTHORIZED 代表响应码 401，无权限。其他的响应码参考 HttpStatus 枚举类型源码</p>
</li>
<li><p><code>@ResponseStatus</code> 有两个属性：</p>
<ul>
<li>value：HttpStatus 的值</li>
<li>reason：自定义的错误信息</li>
</ul>
</li>
</ul>
</li>
<li><p>DefaultHandlerExceptionResolver：</p>
<ul>
<li>对一些特殊的异常进行统一处理，例如：NoSuchRequestHandingMethodException、HttpRequestMethodNotSupportedException、HttpMediaTypeNotSupportException、HttpMediaTypeNotAcceptableException 等</li>
</ul>
</li>
<li><p>SimpleMappingExceptionResolver：</p>
<ul>
<li><p>如果希望对所有异常进行统一处理，可以使用 SimpleMappingExceptionResolver，他将异常类名映射为视图名，即发生异常时使用对应的视图报告异常</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;simpleMappingExceptionResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.portlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 放入 request 域的异常键名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionAttribute&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 出现这个异常时转向的页面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionMappings&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;java.lang.NullPointerException&quot;</span>&gt;</span>error<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<hr>
<h5 id="SpringMVC-运行流程"><a href="#SpringMVC-运行流程" class="headerlink" title="SpringMVC 运行流程"></a>SpringMVC 运行流程</h5><p><img src="1571929627099.png"></p>
<hr>
<h5 id="在-Spring-的环境下使用-SpringMVC"><a href="#在-Spring-的环境下使用-SpringMVC" class="headerlink" title="在 Spring 的环境下使用 SpringMVC"></a>在 Spring 的环境下使用 SpringMVC</h5><ol>
<li>解决 Spring 与 SpringMVC 扫描的包重合的问题：<ul>
<li>要么就强制对 Handler、Service、Dao 进行分包然后两个配置文件中分别扫描</li>
<li>要么使用 exclude-filter 和 include-filter 子节点来规定只能扫描哪些注解</li>
</ul>
</li>
<li>SpringMVC 的 IOC 容器中的 bean 可以引用 Spring IOC 容器中的 bean，反之则不行</li>
<li>多个 Spring IOC 容器之间可以设置父子关系以实现良好的解耦。SpringMVC Web 层容器可以作为 “业务层” Spring 容器的子容器：即 Web 层容器可以引用业务层容器的 Bean，而业务层容器不能访问 Web 层容器的 Bean</li>
</ol>
<hr>
<h5 id="SpringMVC-对比-Struts2"><a href="#SpringMVC-对比-Struts2" class="headerlink" title="SpringMVC 对比 Struts2"></a>SpringMVC 对比 Struts2</h5><ol>
<li>SpringMVC 的入口是 Servlet，而 Struts2 是 Filter</li>
<li>SpringMVC 会稍微比 Struts2 快些，SpringMVC 是基于方法设计，Struts2 是基于类，每发一次请求会实例化一个 Action</li>
<li>SpringMVC 使用更加简洁，开发效率 SpringMVC 比 Struts2 高。SpringMVC 支持 JSR303，处理 Ajax 请求更方便</li>
<li>Struts2 的 OGNL 表达式使页面的开发效率相比 SpringMVC 高点</li>
</ol>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title>みんなの日本語（二）</title>
    <url>/%E6%97%A5%E8%AF%AD/%E3%81%BF%E3%82%93%E3%81%AA%E3%81%AE%E6%97%A5%E6%9C%AC%E8%AA%9E%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<center><strong><span style="font-size: 22px;">文法记录与总结</span></strong></center>

<h4 id="第十六课"><a href="#第十六课" class="headerlink" title="第十六课"></a>第十六课</h4><a id="more"></a>

<ol>
<li><p><strong>连接两个以上句子的方法</strong></p>
<p> 可以使用<span style="color: red;">「〜て（で）」</span>把两个以上的句子连接成一个句子。</p>
<ul>
<li><p>动词1 て 形、[动词2 て 形、] 动词3</p>
<p>  在叙述两个以上连续发生的动作时，按动作的先后顺序，用动词的「て形」将它们连接在一起。<strong>整个句子的时态按最后一个动词的时态而定</strong>。</p>
<p>  例如：</p>
<p>  「朝ジョギングをして、シャワーを浴びて、会社へ行きます。」早上先去跑步，然后冲个澡，再去公司。</p>
</li>
<li><p>い形容词<span style="color: red;">去掉「い」</span>再加<span style="color: red;">「くて」</span></p>
<p>  <strong><em>注意：「いい」变成「よくて」。</em></strong></p>
</li>
<li><p>な形容词<span style="color: red;">直接加 「で」</span></p>
<p>  例如：</p>
<p>  「奈良は静かで、きれいな町です。」奈良是一个既安静又美丽的城市。</p>
</li>
<li><p>名词<span style="color: red;">直接加「で」</span>（与な形容词一致）</p>
<p>  例如：</p>
<p>  「カリナさんは学生で、マリアさんは主婦です。」卡莉娜是学生，玛丽亚是家庭主妇。</p>
</li>
</ul>
</li>
<li><p><strong>动词1 て 形 + <span style="color: red;">から</span>、动词2</strong></p>
<p> 这个句型表示<strong>动词2 是在动词1 之后进行的动作</strong>。因此动词1 多为动词2 的<strong>前提行为</strong>或<strong>准备动作</strong>。<strong>整个句子的时态是根据最后一个动词的时态而定</strong>。另外，「动词 て 形から」的主语用「が」来表示。</p>
<p> 例如：</p>
<p> 「もう昼ごはんを食べましたあか。」已经吃过午饭了吗？</p>
<p> ······「この仕事が終わってから、食べます。」这件工作结束后去吃。</p>
</li>
<li><p><strong>名词1 + <span style="color: red;">は</span> + 名词2 + <span style="color: red;">が</span> + 形容词</strong></p>
<p> 这个句型表示句子的主题（名词1）<strong>具有「名词2 が 形容词」这样的性质</strong>。</p>
<p> 例如：</p>
<p> 「大阪は食べ物がおいしいです。」大阪的小吃很好吃。</p>
</li>
<li><p><strong>名词 + <span style="color: red;">を</span> + 动词</strong></p>
<p> 「でます」「おります」等动词与助词「を」一起使用。助词「を」在这里表示<strong>起点</strong>、<strong>出发点</strong>。</p>
<p> 例如：</p>
<p> 「7時に家を出ます。」7点从家里出去。</p>
</li>
<li><p><strong><span style="color: red;">どうやって</span></strong></p>
<p> 「どうやって」在<strong>问路</strong>或<strong>询问方法</strong>时使用。</p>
<p> 例如：</p>
<p> 「大学までどうやって行きますか。」去大学怎么走？</p>
<p> ······「京都駅から16番のバスに乗って、大学前で降ります。」从京都站坐16路公交车，在大学前站下车。</p>
</li>
<li><p><strong>{ <span style="color: red;">どれ / どの</span> } + 名词</strong></p>
<p> 要求对方从 3 个以上的事物中选择一个时，使用疑问词「どれ」。</p>
<p> 「どれ」不能直接修饰名词，修饰名词需要使用「どの」。</p>
<p> 例如：</p>
<p> 「ミラーさんの傘はどれですか。」米勒的雨伞是哪一把。</p>
<p> ······「あの青い傘です。」是那把蓝色的伞。</p>
</li>
</ol>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>本课学习了连接两个及以上句子的方法以及几个句型，并且学习了「どうやって」以及「どれ / どの」的使用方法。</p>
<hr>
<h4 id="第十七课"><a href="#第十七课" class="headerlink" title="第十七课"></a>第十七课</h4><ol>
<li><p><strong>动词 ない 形</strong></p>
<p> 接续「ない」的动词活用形叫做「ない形」。</p>
<ul>
<li><p>I 类动词</p>
<p>  <strong>「い段」变「あ段」再加「ない」。特殊的当为「い」时，变为「わ」再加「ない」。</strong></p>
</li>
<li><p>II 类动词</p>
<p>  <strong>直接加「ない」即可。</strong></p>
</li>
<li><p>III 类动词</p>
<p>  <strong>直接加「ない」即可。特殊的「きます」变为「こない」。</strong></p>
</li>
</ul>
</li>
<li><p><strong>动词 ない 形 + <span style="color: red;">ないでください</span>（表示 “<em>请不要······</em>”）</strong></p>
<p> 这个句型用于<strong>请求、命令对方不要做某事</strong>。另外，<strong>也可以用于客气地告诉对方没有这样做的必要</strong>。</p>
</li>
<li><p><strong>动词 ない 形 + <span style="color: red;">なければ + なりません</span>（表示 “<em>必须······</em>”）</strong></p>
<p> 这个句型表示<strong>必须要做的事情</strong>。需要注意这个句型<strong>并不是否定句</strong>。</p>
<p> 例如：</p>
<p> 「薬を飲まなければなりません。」必须吃药。</p>
</li>
<li><p><strong>动词 ない 形 + <span style="color: red;">なくてもいいです</span>（表示 “<em>不······也行</em>”）</strong></p>
<p> 这个句型表示<strong>没有必要做某事</strong>。</p>
<p> 例如：</p>
<p> 「明日来なくてもいいです。」明天你不来也可以。</p>
</li>
<li><p><strong>宾语的主题化</strong></p>
<p> 把 「名词 を 动词」中的名词（直接宾语）作为主题提示时，需要去掉助词「を」，换用助词「は」，并将名词放在句首。</p>
<p> 例如：</p>
<p> 「<span style="color: red;">ここに荷物を</span>置かないでください。」请不要把行李放在这里。</p>
<p> 「<span style="color: red;">荷物はここに</span>置かないでください。」</p>
</li>
<li><p><strong>名词（时间） + <span style="color: red;">までに</span> + 动词</strong></p>
<p> <strong>表示动作、事情的期限</strong>。</p>
<p> <strong><em>注意：要与之前学过的表示持续进行的动作的结束时间的助词「まで」区分开来。</em></strong></p>
<p> 例如：</p>
<p> 「会議は５時までに終わります。」会议在 5 点之前结束。</p>
<p> 「５時まで働きます。」工作到 5 点。</p>
</li>
</ol>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>本课学习了动词的「ない形」以及「ない形」的三个句型。以及「までに」的使用方法。</p>
<hr>
<h4 id="第十八课"><a href="#第十八课" class="headerlink" title="第十八课"></a>第十八课</h4><ol>
<li><p><strong>动词字典形（即动词原形）</strong></p>
<p> 这是动词的基本形，是动词在字典中表示的形态。</p>
<ul>
<li><p>I 类动词</p>
<p>   <span style="color: red;">将 「い段」变为「う段」。</span></p>
</li>
<li><p>II 类动词</p>
<p>   <span style="color: red;">直接加「る」。</span></p>
</li>
<li><p>III 类动词</p>
<p>   <span style="color: red;">「します」变为「する」。</span></p>
<p>   <span style="color: red;">「きます」变为「くる」。</span></p>
</li>
</ul>
</li>
<li><p><strong>{ 名词 / 动词字典形 <span style="color: red;">こと</span> }+ <span style="color: red;">が</span> + できます （表示 “<em>能······、会······、可以······</em>”）</strong></p>
<p> 「できます」是表示<strong>能力和可能</strong>的动词，表示<strong>某人有能力做某事</strong>，或<strong>某情况下可以进行某种行为</strong>。「できます」的宾语用助词「が」来提示。<strong>有能力做的事和可以进行的行为用名词或动词字典形加「こと」来表示</strong>。</p>
<ul>
<li><p>名词</p>
<p>  可以使用动作性名词（即<strong>动名词</strong>），还可以使用像「日本語」「ピアノ」这种表示技能的名词。</p>
<p>  例如：「ミラーさんは日本語ができます。」米勒会日语。</p>
</li>
<li><p>动词字典形 こと</p>
<p>  表示能够进行某一行为时，在动词字典形的后面加上「こと」，使其变为名词句，然后再接「ができます」。<strong>在这里这个「こと」的作用是将动作（即动词）名词化</strong>。（「こと」的汉字为「事」）。</p>
<p>  例如：「カードで払うことができます。」可以用信用卡付款。</p>
</li>
</ul>
</li>
<li><p><strong>私<span style="color: red;">の</span>趣味<span style="color: red;">は</span> + { 名词 / 动词字典形 <span style="color: red;">こと</span> } + です（表示 “<em>我的爱好是······</em>”）</strong></p>
<p> 可以使用「动词字典形 こと」将兴趣的内容更为具体的表现出来。</p>
<p> 例如如下两句话：</p>
<p> 「私の趣味は音楽です。」我的爱好是音乐。</p>
<p> 「私の趣味は音楽を聞くことです。」我的爱好是听音乐。</p>
</li>
<li><p><strong>{ 动词1 字典形 / 名词 <span style="color: red;">の</span> / 数量词（期间） } + <span style="color: red;">まえに</span>、动词2（表示 “<em>······之前······</em>”）</strong></p>
<ul>
<li><p>动词字典形</p>
<p>  <strong>表示动词2 发生在动词1 之前。要注意句子的时态（也就是动词2 的时态）不论是过去时还是非过去时，动词1 都是用字典形</strong>。</p>
<p>  例如：「寝るまえに、ブログを書きます。」睡觉之前写博客。</p>
</li>
<li><p>名词</p>
<p>  可以使用动作性名词（即动名词），<strong>需要注意的是要在名词之后加「の」来连接</strong>。</p>
<p>  例如：「食事のまえに、手を洗います。」吃饭之前要洗手。</p>
</li>
<li><p>数量词（表示期间的）</p>
<p>  例如：「山田さんは１時間まえに、出かけました。」山田 1 小时之前出去了。</p>
</li>
</ul>
</li>
<li><p><strong><span style="color: red;">なかなか</span></strong></p>
<p> 「なかなか」的后面接续否定形或否定的表示方式，表示 “不能轻易达成”、“不能像所期待的那样” 之意。</p>
<p> 例如：「日本ではなかなか馬を見ることができません。」在日本很难看到马。</p>
<p> <strong><em>注意：这句话是将「日本で」作为主题的句子。像这样把带有「で」的名词作为主题时，需要使用「名词では」的形式。</em></strong></p>
</li>
<li><p><strong><span style="color: red;">ぜひ</span></strong></p>
<p> 「ぜひ」与表示说话人愿望的语句一起使用时，起到的是<strong>加强语气的作用</strong>。</p>
<p> 例如：「ぜひ北海道へ行きたいです。」一定要去北海道。</p>
</li>
</ol>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p>本课学习的是动词的字典形（即动词的原形）以及几个使用到动词字典形的句型，例如「〜は〜ができます。」等。</p>
<hr>
<h4 id="第十九课"><a href="#第十九课" class="headerlink" title="第十九课"></a>第十九课</h4><ol>
<li><p><strong>动词 た形</strong></p>
<p> 以「た」或「だ」结束的动词活用形叫做「た形」。<strong>「た形」的变形方式与「て形」一样，只不过是把「て」「で」变成「た」「だ」而已。</strong></p>
</li>
<li><p><strong>动词 た形 + <span style="color: red;">ことがあります</span>（表示 “<em>做过······</em>”）</strong></p>
<p> 讲述<strong>过去经历、体验过的事情</strong>时使用该句型。</p>
<p> <strong><em>注意：如果只是单纯地讲述过去某个时间做了某件事情这一事实的话，还是用过去式。</em></strong></p>
<p> 例如（注意体会如下两句话所表达的）：</p>
<p> 「馬に乗ったことがあります。」我骑过马。</p>
<p> 「去年北海道で馬にのりました。」我去年在北海道骑马了。</p>
</li>
<li><p><strong>动词1 た形 <span style="color: red;">り</span>、动词2 た形 <span style="color: red;">り</span> + <span style="color: red;">します</span>（表示 “<em>又······又······</em>”）</strong></p>
<p> 选择<strong>几个具有代表性的动作</strong>并将其列出来时使用这个句型，<strong>注意整句话的时态在句尾</strong>。并且<strong>本句型并没有时间先后的关系</strong>（也就是说可能是同时发生，也可能是一个在前一个在后之类的概念）。因为这个句型列举的是具有代表性的动行，所以这个句型如果用于叙述每天一定要发生的事情（比如吃饭、睡觉等）的话会让人觉得很不自然。</p>
<p> 例如（注意体会如下两句话所表达的）：</p>
<p> 「日曜日はテニスをしたり、映画を見たり<span style="color: red;">します</span>。」周日打打网球，看看电影。</p>
<p> 「日曜日はテニスをしたり、映画を見たり<span style="color: red;">しました</span>。」周日打了网球，看了电影。</p>
<p> <strong><em>注意：需要与助词「や」以及「動詞１て形、[動詞２て形、] 動詞３」这两个句型区别开来。助词「や」的使用场景是选择两个及以上具有代表性的名词并将其列出来。而「動詞１て形、[動詞２て形、] 動詞３」这个句型表示的是动作之间的先后关系（并且是连续性动作）。</em></strong></p>
<p> 例如：</p>
<p> 「日曜日はテニスを<span style="color: red;">して</span>、映画を見<span style="color: red;">ました</span>。」周日打了网球后，去看了场电影。</p>
</li>
<li><p><strong>{ い形容词（～く）/ な形容词（～に）/ 名词（に） } + なります</strong></p>
<p> 这个句型是本课的重点句型，因为这个句型能与之前所学过的其他句型搭配起来使用，这样这个句子就会变得比较的复杂，在分析句子时需要注意。「なります」表示状态的变化。</p>
<p> <strong>「い形容詞」去掉「い」然后加「く」再加「なります」。</strong></p>
<p> <strong>「な形容詞」去掉「な」然后加「に」再加「なります」。</strong></p>
<p> <strong>「名詞」直接加「に」再加「なります」。</strong></p>
<p> <strong><em>注意：在这里「い形容詞」与「な形容詞」所加的「く」和「に」均为词尾，而名词加的「に」则是助词「に」！！</em></strong></p>
<p> 「寒い」＝＞「寒くなります」变冷</p>
<p> 「元気 [な]」＝＞「元気になります」恢复健康（一般说明之前是生病了）</p>
<p> 「２５歳」＝＞「２５歳になります」到 25 岁</p>
<p> 例如：</p>
<p> 「テレーザちゃんは背がたかく<span style="color: red;">なりました</span>。」特蕾沙长高了。</p>
</li>
</ol>
<h5 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h5><p>本课学习了动词的「た形」，并且增加了三个句型，其中「なります」这个句型能与之前学过的句型搭配一起使用，比较灵活，所以需要多多注意。</p>
<hr>
<h4 id="第二十课"><a href="#第二十课" class="headerlink" title="第二十课"></a>第二十课</h4><ol>
<li><p><strong>敬体和简体</strong></p>
<p> 日语分为敬体和简体两种。</p>
<table>
<thead>
<tr>
<th>敬体</th>
<th>简体</th>
</tr>
</thead>
<tbody><tr>
<td>明日東京へ<span style="color: red;">行きます</span>。<br />明天去东京。</td>
<td>明日東京へ<span style="color: red;">行く</span>。<br />明天去东京。</td>
</tr>
<tr>
<td>毎日<span style="color: red;">忙しいです</span>。<br />每天都很忙。</td>
<td>毎日<span style="color: red;">忙しい</span>。<br />每天都很忙。</td>
</tr>
<tr>
<td>相撲が<span style="color: red;">好きです</span>。<br />喜欢相扑。</td>
<td>相撲が<span style="color: red;">好きだ</span>。<br />喜欢相扑。</td>
</tr>
<tr>
<td>富士山に<span style="color: red;">登りたいです</span>。<br />想去登富士山。</td>
<td>富士山に<span style="color: red;">登りたい</span>。<br />想去登富士山。</td>
</tr>
<tr>
<td>ドイツへ行ったことが<span style="color: red;">ありません</span>。<br />没去过德国。</td>
<td>ドイツへいったことが<span style="color: red;">ない</span>。<br />没去过德国。</td>
</tr>
</tbody></table>
<p> 敬体句中带有<strong>「です」「ます」</strong>的谓语叫做<strong>礼貌形（即丁寧形）</strong>，简体句中的谓语叫做<strong>普通形（即普通形）</strong>。</p>
</li>
<li><p><strong>敬体和简体的区别</strong></p>
<ul>
<li><p>会话</p>
<p>  <strong>对初次见面的人、上司、长辈或同辈但并不很熟悉的人使用敬体。相反，对比较亲密的朋友、同事以及家里人使用敬体。</strong></p>
<p>  <strong>在错误的场合使用简体的话，对对方很不礼貌，所以在使用之前要注意对方是否是可以使用简体的人。</strong></p>
</li>
<li><p>书写时</p>
<p>  书信一般多使用敬体。论文、报告、日记等使用简体。</p>
</li>
</ul>
</li>
<li><p><strong>简体的会话</strong></p>
<ul>
<li><p>简体的疑问句一般不在句尾加「か」，而是使用升调来发问</p>
<p>  例如：</p>
<p>  「コーヒーを飲む？（语调上升）」喝咖啡吗？</p>
<p>  ······「うん、飲む。（语调下降）」嗯，喝。</p>
</li>
<li><p>在名词以及「な形容词」的疑问句中可以省略「です」的简体「だ」。在进行肯定回答时，用「だ」的话，会给人很生硬的感觉，所以为了缓和语气，会省略「だ」或加上终助词</p>
<p>  例如：</p>
<p>  「今晩暇？」今晚有空吗？</p>
<p>  ······「うん、暇 / 暇だ / 暇だよ。」嗯，有空。（男性用）</p>
<p>  ······「うん、暇 / 暇よ / 暇だよ。」嗯，有空。（女性用）</p>
<p>  ······「ううん、暇じゃない。」不，没空。</p>
</li>
<li><p>简体句中，当通过前后句可以明白语意时多省略助词。但是，<span style="color: red;">「で」「に」「から」「まで」「と」</span>等助词不能省略，因为这些助词一旦省略会使句意不清。</p>
<p>  例如：「ご飯 [を] 食べる？」吃饭吗？</p>
</li>
<li><p>简体句中，「动词 て 形 いる」中的「い」也常常省略</p>
<p>  例如：</p>
<p>  「辞書、持って [い] る？」带字典了吗？</p>
<p>  ······「うん、持って [い] る。」嗯，带着呢。</p>
<p>  ······「ううん、持って [い] ない。」没，没带。</p>
</li>
<li><p>けど</p>
<p>  「けど」与起转折作用的「が」有相同的功能，在会话中很常用</p>
<p>  例如：</p>
<p>  「そのカレー [は] おいしい？」那种咖哩好吃吗？</p>
<p>  ······「うん、辛いけど、おいしい。」嗯，有点辣，但是很好吃。</p>
</li>
</ul>
</li>
</ol>
<h5 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h5><p>本课学习了简体的使用方法。</p>
<hr>
<h4 id="PLUS"><a href="#PLUS" class="headerlink" title="PLUS"></a>PLUS</h4><ol>
<li><p>めがね（眼鏡）</p>
<p> 戴眼镜使用 かける，取下眼镜使用 とる（取る）。</p>
</li>
<li><p>ぼうし（帽子）</p>
<p> 戴帽子使用 かぶる，摘下帽子使用 とる（取る）。</p>
</li>
<li><p>うわぎ（上着）</p>
<p> 穿上衣使用 きる（着る），脱上衣使用 ぬぐ（脱ぐ）。</p>
</li>
<li><p>ズボン</p>
<p> 穿裤子使用 はく（履く），脱裤子使用 ぬぐ（脱ぐ）。</p>
</li>
<li><p>くつ（靴）</p>
<p> 穿鞋子使用 はく（履く），脱鞋使用 ぬぐ（脱ぐ）。</p>
</li>
<li><p>「ここでみちをわたります。（ここで道を渡ります。）」在这里过马路。</p>
</li>
<li><p>「つぎのかどをまがってください。（次の角を曲がってください。）」请在下一个转角转弯。</p>
</li>
<li><p>「このバスはえきのまえをとおります。（このバスは駅の前を通ります。）」这辆车经过车站前。</p>
</li>
<li><p>「トイレはかいだんをおりたところにあります。（トイレは階段を降りた所にあります。）」厕所在楼下。</p>
</li>
</ol>
<hr>
<h4 id="句型总结"><a href="#句型总结" class="headerlink" title="句型总结"></a>句型总结</h4><ol>
<li>〜ます<ul>
<li>〜ます / 〜ません</li>
<li>〜ましょう / ～ませんか</li>
<li>〜たい / 〜たくないです</li>
<li>〜に { 行きます / 来ます / 帰ります }</li>
</ul>
</li>
<li>〜ない<ul>
<li>〜ないでください</li>
<li>〜なければなりません</li>
<li>〜なくてもいいです</li>
</ul>
</li>
<li>辞書形<ul>
<li>辞書形 ことができます</li>
<li>辞書形 まえに、〜</li>
<li>辞書形 ことです</li>
</ul>
</li>
<li>て形<ul>
<li>て形 ください</li>
<li>て形 います</li>
<li>て形 もいいです</li>
<li>て形 はいけません</li>
<li>て形 から、〜</li>
<li>て形、て形</li>
</ul>
</li>
<li>た形<ul>
<li>た形 ことがあります</li>
<li>た形 り、た形 りします</li>
</ul>
</li>
</ol>
<hr>
<h4 id="活用总结"><a href="#活用总结" class="headerlink" title="活用总结"></a>活用总结</h4>]]></content>
      <categories>
        <category>日语</category>
      </categories>
      <tags>
        <tag>日语</tag>
        <tag>语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>みんなの日本語（五）</title>
    <url>/%E6%97%A5%E8%AF%AD/%E3%81%BF%E3%82%93%E3%81%AA%E3%81%AE%E6%97%A5%E6%9C%AC%E8%AA%9E%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<center><strong><span style="font-size: 22px;">文法记录与总结</span></strong></center>

<h4 id="第三十一课"><a href="#第三十一课" class="headerlink" title="第三十一课"></a>第三十一课</h4><a id="more"></a>

<ol>
<li><p><strong>意向形</strong></p>
<p> 「ます形」变为意向形的方法如下：</p>
<p> <span style="color: red;">I 类：去「ます」，「ます形」的「イ段」变为「オ段」，再加上「う」</span></p>
<p> <span style="color: red;">II 类：去「ます」，加「よう」</span></p>
<p> <span style="color: red;">III 类：します =&gt; しよう、きます =&gt; こよう</span></p>
</li>
<li><p><strong>意向形的用法</strong></p>
<ul>
<li><p>意向形作为「〜ましょう」的普通形，用在简体的句子里</p>
<p>  <strong><em>注意：简体疑问句一般句尾不加助词「か」，但是如果是「〜ましょうか」的简体疑问句，则需要加「か」。</em></strong></p>
<p>  例如：「傘を持って行こうか。」带伞去吧。</p>
</li>
<li><p><strong>动词意向形 + と思っています</strong></p>
<p>  这个句型用于说话人向对方表明自己的意志。</p>
<p>  「动词意向形 + と思います」单纯表示说话人的意志。并且仅限于说话人的意志。</p>
<p>  「动词意向形 + と思っています」表示这一意志到现在已经保持一段时间了。可以表示第三者的意志。</p>
<p>  例如：</p>
<p>  「今から銀行へ行こうと思います。」我现在想去银行。</p>
<p>  「彼は学校を作ろうと思っています。」他想建一所学校。</p>
</li>
</ul>
</li>
<li><p><strong>{ <span style="color: red;">动词字典形</span> / <span style="color: red;">动词 ない 形 ない</span> } + つもりです</strong></p>
<p> 「动词字典形 + つもりです」表示意志，「动词 ない形 ない + つもりです」表示否定。</p>
<p> <strong><em>注意：「动词意向形 + と思っています」和「动词字典形 + つもりです」的意思没有太大的不同，但在表示确定的意志和坚定的决心时，多用「动词字典形 + つもりです」。</em></strong></p>
<p> 例如：「国へ帰っても、日本語の勉強を続けるつもりです。」我回国后也准备继续学习日语。</p>
</li>
<li><p><strong>{ <span style="color: red;">动词字典形</span> / <span style="color: red;">名词 の</span> } + 予定です</strong></p>
<p> 这个句型表示预订的计划。</p>
<p> 例如：「旅行は一週間ぐらいの予定です。」旅行预定去一星期左右。</p>
</li>
<li><p><strong>まだ + 动词 て形 + いません</strong></p>
<p> 这个句型表示在说话时，<strong>事态还没有发生或行为还没有结束</strong>。</p>
<p> 例如：「銀行はまだ開いていません。」银行还没开门。</p>
</li>
<li><p><strong>帰ります =&gt; 帰り</strong></p>
<p> 有时「ます形」可以作为名词使用。</p>
<p> 除了「帰ります」以外，以下动词的「ます形」也可以作为名词使用：</p>
<p> 遊びます =&gt; 遊び</p>
<p> 答えます =&gt; 答え</p>
<p> 申し込みます =&gt; 申し込み</p>
<p> 楽しみます =&gt; 楽しみ</p>
</li>
</ol>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>本课的重点是意向形的活用以及相关句型。</p>
<hr>
<h4 id="第三十二课"><a href="#第三十二课" class="headerlink" title="第三十二课"></a>第三十二课</h4><ol>
<li><p><strong>{ 动词 た形 / 动词 ない形 ない } + <span style="color: red;">ほうがいいです</span></strong></p>
<p> 这个句型表示<strong>向听话人提出建议和忠告</strong>。「动词 た形 + ほうがいいです」<strong>含有将两种行为加以比较后作出选择的意思，会让人觉得不做被选出来的那一行为不好，因此有时候会给人一种强加于人的印象。只是单纯的建议对方去进行某一行为的时候，应该使用「〜たらいい」的句型</strong>。</p>
<p> 例如：</p>
<p> 「日本のお寺が見たいんですが······。」想去看看日本的寺庙。</p>
<p> ······「じゃ、京都へ行ったらいいですよ。」那你可以去京都。</p>
</li>
<li><p><strong>{ 动词普通形 / い 形容词普通形 / な 形容词普通形（<s>～だ</s>） / 名词普通形（<s>～だ</s>） } + <span style="color: red;">でしょう</span></strong></p>
<p> <strong>在说话人对未来的事情或不太确定的事情进行推断</strong>时可以使用这个句型。</p>
<p> 例如：「明日雨が降るでしょう。」明天会下雨吧。</p>
</li>
<li><p><strong>{ 动词普通形 / い 形容词普通形 / な 形容词普通形（<s>～だ</s>） / 名词普通形（<s>～だ</s>） } + <span style="color: red;">かもしれません</span></strong></p>
<p> 这个句型可以表示 “<strong>······的可能性还是多少有一点的</strong>”。</p>
<p> 例如：「約束の時間に間に合わないかもしれません。」或许赶不上约定的时间了。</p>
</li>
<li><p><strong>动词 ます形 + ましょう</strong></p>
<p> 这个句型用于<strong>说话人向听话人传达自己意志时的表达方式</strong>，在说话人提出要进行某种行为时使用，比「动词 ます形ましょうか」的语气<strong>更为积极一点</strong>。</p>
<p> 例如：</p>
<p> 「エンジンの音がおかしいんですが。」发动机的声音有点怪啊。</p>
<p> ······「そうですね。故障かもしれません。ちょっと調べましょう。」是啊，也许是出故障了，我们来检查一下吧。</p>
</li>
<li><p><strong>数量词 <span style="color: red;">で</span></strong></p>
<p> <strong>表示期限和限度</strong>。</p>
<p> 例如：「駅まで３０分で行けますか。」30分钟能到车站吗？</p>
</li>
<li><p><strong>なにか心配なこと</strong></p>
<p> 使用「なにか心配なこと」而不是用「心配なことなにか」的这种表示方式用于表示 “什么担心的事”。类似的用法还有「なにか〜もの」「どこか〜ところ」「だれか〜ひと」「いつか〜とき」等。</p>
<p> 例如：「スキーに行きたいんですが、どこかいい所、ありますか。」我想去滑雪，有什么好地方吗？</p>
</li>
</ol>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>本课主要学习的是「ほうがいいです」「でしょう」「かもしれません」等句型的用法。</p>
<hr>
<h4 id="第三十三课"><a href="#第三十三课" class="headerlink" title="第三十三课"></a>第三十三课</h4><ol>
<li><p><strong>命令形与禁止形</strong></p>
<ul>
<li><p><strong>命令形的变化方法</strong></p>
<p>  <span style="color: red;">I 类：「ます形」去「ます」，然后「イ段」变为「エ段」</span></p>
<p>  <span style="color: red;">II 类：「ます形」去「ます」，然后加「ろ」</span></p>
<p>  <span style="color: red;">III 类：「します」变为「しろ」；「きます」变为「こい」</span></p>
</li>
<li><p><strong>禁止形的变化方法</strong></p>
<p>  <span style="color: red;">动词字典形直接加「な」</span>。</p>
</li>
</ul>
<p> <strong><em>注意：「ある」「できる」「わかる」等状态动词没有命令形。</em></strong></p>
</li>
<li><p><strong>命令形和禁止形的用法</strong></p>
<p> <strong>命令形用于强行要求对方做某一动作。</strong></p>
<p> <strong>禁止形则用于命令对方不要做某一动作。</strong></p>
<p> 由于这两种形式都带有非常强烈的语气，所以用于句尾的情况不多。另外，作为口语使用的话几乎只限于男性使用。如下几种情形可以将命令形和禁止形用于句尾。</p>
<ul>
<li><p>地位高或者年龄大的男性对比自己地位低或者年龄小的男性，或者父亲对自己的孩子说话时。</p>
<p>  例如：「早く寝ろ。」早点睡！</p>
</li>
<li><p>男性朋友之间对话时，为了缓和语气，使用时多会在句尾加「よ」。</p>
<p>  「あまり飲むなよ。」别喝多了！</p>
</li>
<li><p>在工厂的共同作业中发出指示时，以及在发生火灾、地震等紧急情况下，没有时间考虑说话的方式和语气时。但这种场合也往往只限于地位高或年龄较大的男性使用。</p>
<p>  例如：「逃げろ。」快逃！</p>
</li>
<li><p>在集体训练、学校体育课以及俱乐部的体育活动中发出号令时。</p>
<p>  例如：「休め。」稍息！</p>
</li>
<li><p>在体育比赛中加油助威时，这种场合，女性也可以使用。</p>
<p>  例如：「頑張れ。」加油！</p>
</li>
<li><p>追求强烈效果或要求用语简洁明了时。如交通标志和标语等。</p>
<p>  例如：「入るな。」禁止入内！</p>
<p>  <strong><em>注意：「动词 ます形 + なさい」是表示命令的句型之一。这个句型比动词命令形更加礼貌，父母对孩子以及老师对学生都可以使用。女性一般用这个句型来代替动词命令形。但是，该句型不能对上司或者长辈用。</em></strong></p>
<p>  例如：「勉強しなさい。」快学习去！</p>
</li>
</ul>
</li>
<li><p><strong>〜<span style="color: red;">と</span>書いてあります / 〜<span style="color: red;">と</span>読みます</strong></p>
<p> 这里的「と」与「〜と言います」（「～と言います」中的「と」表示说的内容）中的「と」起相同的作用，在这里表示<strong>写的内容 / 读的内容</strong>。</p>
<p> 例如：</p>
<p> 「あの漢字はなんと読むんですか。」那个汉字念什么？</p>
<p> 「あそこに「止まれ」と書いてあります。」那里写着 “停”。</p>
</li>
<li><p><strong>X は Y という意味です</strong></p>
<p> 给 X 下定义时可以使用这个句型。「と言う」是从「と言います」转换过来的。<strong>在询问某个词的意思时使用疑问词「どういう」</strong>。</p>
<p> 例如：</p>
<p> 「「立入禁止」は入るなという意味です。」「たちいりきんし」就是别进去的意思。</p>
</li>
<li><p><strong>{ “句子” / 普通形 } + <span style="color: red;">と</span>言っていました</strong></p>
<p> <strong>引用第三者</strong>的话使用「〜と言いました」。</p>
<p> <strong>传达第三者</strong>的话使用「〜と言っていました」。</p>
<p> 例如：「田中さんは明日休むと言っていました。」田中说他明天休息。</p>
</li>
<li><p><strong>{ “句子” / 普通形 } + <span style="color: red;">と</span>伝えていただけませんか</strong></p>
<p> 表示<strong>礼貌地委托对方转告某事</strong>。</p>
<p> 例如：「ワンさんに「あとで電話をください」と伝えていただけませんか。」请转告小王回头给我打个电话好吗？</p>
</li>
</ol>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p>本课学习了两种新的形态：命令形与禁止形，以及传达第三者的话时使用的「〜と言っていました」的句型和礼貌地委托对方转告某事时使用的「〜と伝えていただけませんか」的句型。</p>
<hr>
<h4 id="第三十四课"><a href="#第三十四课" class="headerlink" title="第三十四课"></a>第三十四课</h4><ol>
<li><p><strong>{ 动词1 た形 / 名词 の } + <span style="color: red;">とおりに（通りに）</span>、动词2</strong></p>
<ul>
<li><p><span style="color: red;">动词1 た形 + とおりに、动词2</span></p>
<p>  表示以与动词1 <strong>同样的状态和方法</strong>来进行动词2。</p>
<p>  例如：「見たとおりに、話してください。」请按照你所看到的来说。</p>
</li>
<li><p><span style="color: red;">名词 の + とおりに、动词</span></p>
<p>  表示按照<strong>名词所提示的标准</strong>进行某个动作。</p>
<p>  例如：「線のとおりに、紙を切ってください。」请沿着这条线把纸裁开。</p>
</li>
</ul>
<p> <strong><em>注意：因为「とおり」是名词，所以可以直接接续「この」「その」「あの」等指示代词。表示以指示代词所示的同样的状态和方法去做某事。</em></strong></p>
<p> 例如：「このとおりに、書いてください。」请照这样写。</p>
</li>
<li><p><strong>{ 动词1 た形 / 名词 の } + <span style="color: red;">あとで（後で）</span>、动词2</strong></p>
<p> <strong>动词2 表示在动词1 或名词之后发生的事情</strong>。</p>
<p> 例如：「新しいのを買ったあとで、なくした時計が見つかりました。」在买的新的之后，丢了的那块表又找到了。</p>
<p> <strong><em>注意：与表示同样意思的「动词 て形 + から」相比，本句型更多强调的是时间的先后关系。另外与「动词 て形 + から」不同，本句型中动词1 和名词没有作为动词2 的前提或准备动作的意思。</em></strong></p>
</li>
<li><p><strong>{ 动词1 て形 / 动词1 ない形<span style="color: red;">ないで</span> } + 动词2</strong></p>
<ul>
<li><p>动词1 表示动词2 的<strong>附带动作或状态</strong>，<strong>动词1 和动词2 的行为主体是一个</strong>。</p>
<p>  例如：「醤油をつけて食べます。」蘸酱油吃。</p>
</li>
<li><p>「动词1 ない形 ないで 动词2」还可以用于表示从两个不能同时进行的动作中选择一个动作来做。</p>
<p>  例如：「日曜日はどこも行かないで、うちでゆっくり休みます。」周日哪都不去，在家好好休息。</p>
</li>
</ul>
</li>
</ol>
<h5 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h5><p>本课主要学习的为三个句型。</p>
<hr>
<h4 id="第三十五课"><a href="#第三十五课" class="headerlink" title="第三十五课"></a>第三十五课</h4><ol>
<li><p><strong>假定形的转换方法</strong></p>
<p> <span style="color: red;">I 类：「ます形」去「ます」，「イ段」变「エ段」，再接「ば」</span></p>
<p> <span style="color: red;">II 类：「ます形」去「ます」，再接「れば」</span></p>
<p> <span style="color: red;">III 类：「します」＝＞「すれば」；「きます」＝＞「くれば」</span></p>
<p> <span style="color: red;">动词否定形：去掉「ない」，再接「なければ」</span></p>
<p> <span style="color: red;">イ形容词否定：去掉「ない」，再接「なければ」</span></p>
<p> <span style="color: red;">{ ナ形容词 / 名词 } 否定：～で（じゃ）なければ，比如「きれいで（じゃ）なければ」</span></p>
<p> <span style="color: red;">イ形容词：「い」变为「ければ」</span></p>
<p> <span style="color: red;">ナ形容词：去「な」再接「なら」</span></p>
<p> <span style="color: red;">名词：直接加「なら」</span></p>
</li>
<li><p><strong>假定形、～</strong></p>
<ul>
<li><p>表示前半句是后半句（主句）成立的<strong>必要条件</strong></p>
<p>  例如：「いい天気なら、向こうに島が見えます。」天气好的时候，能看见对面的小岛。</p>
</li>
<li><p>表示根据对方的话和某种状况，<strong>说话人做出的某种判断</strong></p>
<p>  例如：</p>
<p>  「明日までにレポートを出さなければなりませんか。」报告必须在明天之前交吗？</p>
<p>  ······「無理なら、金曜日までに出してください。」如果有些勉强的话，那就在星期五之前交吧。</p>
</li>
<li><p><strong>{ 比较 }</strong></p>
<ul>
<li><p>～と、〜</p>
<p>  「〜と、〜」表示「と」之前的动作和事态一旦发生，其后的主句所表示的状态、动作、现象、事态也会随之自然发生。后半句（主句）中<strong>不会出现</strong>表示意志、希望、命令、请求等的表达方式。</p>
</li>
<li><p>〜たら、〜</p>
<p>  「〜たら、〜」有两种用法：</p>
<ul>
<li><p>表示假定条件</p>
</li>
<li><p>表示知道前半句「动词た形ら」描述的某一事态成立时，后半句（主句）中的动作和事态也会随之发生。后半句（主句）可以使用表示意志、希望、命令、请求等的表达方式。</p>
<p>当后半句（主句）中表现出说话人的意志时，可以用「〜たら」，但不能用「〜と」和「〜ば」。</p>
<p>但是当<strong>前句和后句（主句）的主语不一致</strong>时，后半句即使表现出了说话人的意志，也可以使用「〜ば」。</p>
<p>可以说「〜たら」的使用范围最大，但因为「〜たら」是口语，所以不宜作为书面语使用。</p>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>「〜と、〜」一般表示<strong>客观描述的必然性</strong>。</li>
<li>「〜たら、〜」<strong>强调的是动作的先后顺序，这个句型的假定语气最弱</strong>。</li>
<li>「〜ば、〜」当<strong>假定条件不受说话人的控制时（即前后主语不一致，或者说「ば」前面是状态），后面的主句可以使用意志表达，这个句型的假定语气最强</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>疑问句 + 动词假定形 + いいですか</strong></p>
<p> 表示<strong>说话人向听话人寻求建议和指示</strong>。与「〜たらいいですか」用法相同。</p>
<p> 例如：</p>
<p> 「本を借りたいんですが、<span style="color: red;">どうすればいいですか</span>。」我想借书，怎么做好呢？</p>
<p> 「本を借りたいんですが、<span style="color: red;">どうしたらいいですか</span>。」我想借书，怎么做才好呢？</p>
</li>
<li><p><strong>名词 + なら、～</strong></p>
<p> 在<strong>听了对方所说的事情之后，就这一事情提供一些信息</strong>时可以使用「名词 + なら、〜」。</p>
<p> 例如：</p>
<p> 「温泉に行きたいんですが、どこがいいですか。」我想去温泉，哪儿好？</p>
<p> ······「温泉なら、白馬がいいですよ。」温泉的话，白马不错啊。</p>
<p> <strong><em>注意：实际「なら」前面不只可以接名词，还有「动词普通形 + なら」「ナ形容词（<s>「な」</s>） + なら」「名词（<s>「だ」</s>） + なら」等用法。</em></strong></p>
</li>
<li><p><strong>～はありませんか</strong></p>
<p> 「〜ありますか」与「〜ありませんか」意思相同，但「～ありませんか」是一种<strong>比较照顾对方情绪的询问方式</strong>，可以使对方易于做否定回答。</p>
<p> 一般来说，否定疑问句是一种比较礼貌的询问方式。</p>
<p> 回答时使用「はい、あります。」或「いいえ、ありません。」即可。</p>
<p> 例如：「２、３日旅行をしようと思っているんですが、どこかいい所はありませんか。」我想去旅行两三天，有什么好的地方吗？</p>
</li>
</ol>
<h5 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h5><p>本课学习了动词假定形的变化方法，以及假定形的部分使用方法，并将其与之前学过的「〜と、〜」「〜たら、〜」等句型进行了对比。实际上算上「〜なら、〜」的话，表示假定的句型总共有四个。</p>
]]></content>
      <categories>
        <category>日语</category>
      </categories>
      <tags>
        <tag>日语</tag>
        <tag>语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>みんなの日本語（八）</title>
    <url>/%E6%97%A5%E8%AF%AD/%E3%81%BF%E3%82%93%E3%81%AA%E3%81%AE%E6%97%A5%E6%9C%AC%E8%AA%9E%EF%BC%88%E5%85%AB%EF%BC%89/</url>
    <content><![CDATA[<center><strong><span style="font-size: 22px;">文法记录与总结</span></strong></center>

<h4 id="第四十六课"><a href="#第四十六课" class="headerlink" title="第四十六课"></a>第四十六课</h4><a id="more"></a>

<ol>
<li><p><strong>{ 动词字典形 / 动词 て形 いる / 动词 た形 } + ところです</strong></p>
<p> 这里的「ところ」用于<strong>叙述某个动作或发生的事情当下所处的状态（即适用于表示持续性动作的动词与状态）</strong>。当下所处的状态可以理解为<strong>做到了哪个阶段了</strong>。</p>
<ul>
<li><p><span style="color: red;">动词字典形 + ところです</span></p>
<p>  表示<strong>动作即将开始</strong>。常与「これから」「ちょうど今から」等副词一起使用。</p>
<p>  例如：</p>
<p>  「昼ごはんはもう食べましたか。」吃过午饭了吗？</p>
<p>  ······「いいえ、これから食べるところです。」没有，正要吃呢。</p>
</li>
<li><p><span style="color: red;">动词 て形 いる + ところです</span></p>
<p>  表示<strong>动作正在进行</strong>。常与「いま」一起使用。</p>
<p>  <strong><em>注意：「〜ているところ」虽然表示的为动作正在进行，但是实际上意思为 “正处于这个动作的进行阶段”，也就是说在这个阶段允许做别的事情；而「〜ている」则表示的单单只是这个动作正在持续进行，在这个过程中没有做别的事情。</em></strong></p>
<p>  例如：</p>
<p>  「故障の原因がわかりましたか。」故障的原因弄清楚了吗？</p>
<p>  ······「いいえ、今調べているところです。」没有，现在正在查呢。</p>
</li>
<li><p><span style="color: red;">动词 た形 + ところです</span></p>
<p>  表示<strong>动作刚刚结束</strong>。常与「たった今」等副词一起使用。</p>
<p>  例如：「たった今バスが出たところです。」公交车刚走。</p>
</li>
</ul>
<p> <strong><em>注意：「〜ところです」作为名词句可以接续各种句型。</em></strong></p>
</li>
<li><p><strong>动词 た形 + ばかりです</strong></p>
<p> 表示<strong>说话人觉得某一动作或某一事情发生之后还没过多久的心情</strong>。不管实际上经过多长时间，<strong>只要说话人觉得时间短</strong>就可以使用这个句型。这一点与「〜たところです」不一样。</p>
<p> 例如：「木村さんは先月この会社に入ったばかりです。」木村上个月刚进这家公司。</p>
<p> <strong><em>注意：「〜ばかりです」作为名词句可以接续各种句型。</em></strong></p>
</li>
<li><p><strong>{ 动词字典形 / 动词 ない形 ない / い 形容词（〜い） / な 形容词 な / 名词 の } + はずです</strong></p>
<p> 表示<strong>说话人很有把握地说出自己凭借着某种依据来做出的某种判断</strong>。</p>
<p> 例如：</p>
<p> 「ミラーさんは今日来るでしょうか。」米勒今天会来吗？</p>
<p> ······「来るはずですよ。昨日電話がありましたから。」应该会来的。因为他昨天打过电话。</p>
</li>
</ol>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>本课学习了三个句型，需要重点注意的就是「〜ところ」实际上表示的为某个阶段。还有「〜ばかり」中 “发生之后的没过多久” 这个点，实际上是说话人觉得短就是短。</p>
<hr>
<h4 id="第四十七课"><a href="#第四十七课" class="headerlink" title="第四十七课"></a>第四十七课</h4><ol>
<li><p><strong>普通形 + そうです（表示 “<em>听说······</em>”，即「伝聞」）</strong></p>
<p> 表示<strong>说话人把从别人那里得到的信息，不掺杂任何自己的意见告诉听话人</strong>。如果要显示信息的出处，可以在句首使用<span style="color: red;">「〜によると」</span>。</p>
<p> 例如：「天気予報によると、明日は寒くなるそうです。」据天气预报说，明天要降温。</p>
<ul>
<li><p><span style="color: red;">「〜そうです（様態）」与「〜そうです（伝聞）」的区别</span></p>
<ul>
<li><p>接续上的区别</p>
<p>  「〜そうです（様態）」前接「ます形」、「い 形容词」、「な 形容词」；而「〜そうです（伝聞）」前接「普通形」。</p>
</li>
<li><p>意思上的区别</p>
<p>  「〜そうです（様態）」表示 “看起来好像······”；而「〜そうです（伝聞）」则表示 “听说······”。</p>
<p>例如：</p>
<p>「雨が降りそうです。」好像要下雨了。</p>
<p>「雨が降るそうです。」听说要下雨。</p>
</li>
</ul>
</li>
<li><p><span style="color: red;">「〜そうです（伝聞）」与「〜と言っていました」的区别</span></p>
<p>  「〜そうです（伝聞）」信息的出处不一定是当事人，也就是说不一定是从当事人那听说的；而「〜と言っていました」则是从当事人那听来的。</p>
<p>  例如：</p>
<p>  「木村さんは明日京都へ行くそうです。」听说木村明天去京都。</p>
<p>  「木村さんは明日京都へ行くと言っていました。」京都说他明天去京都。</p>
</li>
</ul>
</li>
<li><p><strong>{ 动词普通形 / い 形容词普通形 / <span style="color: red;">な 形容词普通形（～<s>だ</s> =&gt; 〜な）</span> / <span style="color: red;">名词普通形（～<s>だ</s> =&gt; 〜の）</span> } + ようです（表示 “<em>好像······</em>”）</strong></p>
<p> 「〜ようです」表示<strong>说话人根据现场状况做出的判断</strong>，有时会与表示 “并不能判定，但······” 的副词「どうも」一起使用。</p>
<p> 例如：「咳も出るし、頭も痛い。どうも風邪をひいたようだ。」又咳嗽又头疼，好像是感冒了。</p>
<ul>
<li><p><span style="color: red;">「〜そうです（様態）」与「〜ようです」的区别</span></p>
<p>  「〜そうです（様態）」只是<strong>单纯地讲述从外表上观察到的样子</strong>，即表象；而「〜ようです」则是表示<strong>说话人根据某种状况所做出的判断</strong>，即理性判断。</p>
<p>  例如：</p>
<p>  「木村さんは忙しそうです。」木村看上去很忙。</p>
<p>  「木村さんは忙しいようです。」木村好像很忙。</p>
</li>
</ul>
</li>
<li><p><strong>{ 声 / 音 / におい / 味 } + <span style="color: red;">が</span>します</strong></p>
<p> 表示<strong>通过感觉器官捕捉到的声音、气味、味道</strong>等。</p>
<p> 例如：「にぎやかな声がしますね。」声音很热闹。</p>
</li>
</ol>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>本课学习了表示 “听说······” 的「〜そうです」的用法，以及它与表示 “看起来好像······”「〜そうです」的区别。以及「〜そうです」与「〜ようです」的区别。</p>
<hr>
<h4 id="第四十八课（重要）"><a href="#第四十八课（重要）" class="headerlink" title="第四十八课（重要）"></a>第四十八课（重要）</h4><ol>
<li><p><strong>使役动词</strong></p>
<p> <span style="color: red;">I 类：「ます形」去「ます」，「イ段」变「ア段」，再加「せる」，注意「い」=&gt;「わ」。</span></p>
<p> <span style="color: red;">II 类：直接加「させる」。</span></p>
<p> <span style="color: red;">III 类：「きます」=&gt;「こさせる」；「します」=&gt;「させる」。</span></p>
<p> <strong><em>注意：使役动词作为 II 类动词活用。</em></strong></p>
</li>
<li><p><strong>使役动词句</strong></p>
<p> 使役动词中，动作的主体有用「を」和「に」来表示的两种。</p>
<p> <strong>若原来的动词是自动词，原则上使用「を」来表示。</strong></p>
<p> <strong>若原来的动词是他动词，则使用「に」来表示。</strong></p>
<ul>
<li><p><span style="color: red;">名词（人） + を + 使役动词（自动词）（表示 “让······做······”）</span></p>
<p>  例如：「私は息子<span style="color: red;">を</span>自由に遊ばせました。」我让儿子自由自在地玩耍。</p>
<p>  <strong><em>注意：使用自动词，且使用「名词（场所） + を」的句子，动作的主体要用「に」来表示。</em></strong></p>
<p>  例如：「私は子ども<span style="color: red;">に</span>道の右側を歩かせます。」我让孩子在路的右侧走。</p>
</li>
<li><p><span style="color: red;">名词1（人） + に + 名词2 + を + 使役动词（他动词）（表示 “让······做······”）</span></p>
<p>  例如：「先生は生徒<span style="color: red;">に</span>自由に意見を言わせました。」老师让学生自由地发表意见。</p>
</li>
</ul>
</li>
<li><p><strong>使役动词的使用方法</strong></p>
<p> 使役动词表示<strong>强制</strong>和<strong>容忍</strong>。</p>
<p> 常表示地位高、年龄大的人强制地位低、年龄小的人去做某件事情，或容忍他们的行为。比如父母对孩子、哥哥对弟弟、上司对部下等。</p>
<p> <strong><em>注意：从自己所处的位置来讲，一般对比自己地位高、年龄大的人不能强制，也不存在容忍，因此不使用带有使役动词的表达方式。如果想让别人去做某事时，要使用如「动词 て形 + いただきます」「动词 て形 + もらいます」等表示受到对方恩惠的表达方式。</em></strong></p>
<p> 例如：</p>
<p> 「私は友達に説明してもらいました。」我让朋友进行了说明。</p>
</li>
<li><p><strong>使役动词 て形 + いただけませんか（表示 “<em>可以让（允许）我······吗？</em>”）</strong></p>
<p> <strong>之前学过的「动词 て形 + いただけませんか」是请求对方做某事的用法。</strong></p>
<p> <strong>而「使役动词 て形 + いただけませんか」则是请求对方允许自己进行某种行为时的用法</strong>。</p>
<p> 例如：</p>
<p> 「友達の結婚式があるので、早く帰らせていただけませんか。」因为有朋友的婚礼，能允许我早走一会儿吗？</p>
</li>
<li><p><strong>使役受身动词</strong></p>
<p> 使役受身动词表示被强制做某事。变化思路是先变成使役动词再变成受身动词。</p>
<p> <span style="color: red;">I 类：「ます形」去「ます」，「イ段」变「ア段」，再加「される」。注意「い」=&gt;「わ」以及「さ」行的动词是加「せられる」。</span></p>
<p> <span style="color: red;">II 类：直接加「させられる」。</span></p>
<p> <span style="color: red;">III 类：「します」=&gt;「させられる」；「きます」=&gt;「こさせられる」。</span></p>
</li>
</ol>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p>本课学的使役动词比较重要，注意使役动词、可能动词、受身动词、使役受身动词等的活用方式。</p>
<hr>
<h4 id="第四十九课（难点）"><a href="#第四十九课（难点）" class="headerlink" title="第四十九课（难点）"></a>第四十九课（难点）</h4><ol>
<li><p><strong>敬语（「敬語（けいご）」）</strong></p>
<p> 所谓敬语，是<strong>对听话人</strong>或<strong>话题中的人表示敬意</strong>的表达方式。</p>
<p> 是否使用敬语，要根据<strong>对象</strong>、<strong>话题中的人</strong>以及<strong>场合</strong>来决定。</p>
<p> 敬语用于以下情况：</p>
<ul>
<li><strong>和上司、长辈、不认识或不太亲密的人说话时</strong></li>
<li><strong>在提及上司、长辈时</strong></li>
<li><strong>在正式场合讲话时</strong></li>
</ul>
</li>
<li><p><strong>尊敬语（「尊敬語（そんけいご）」）</strong></p>
<p> 在对动作及状态的主体表示敬意时使用尊敬语。</p>
<ul>
<li><p><span style="color: red;">动词</span></p>
<p>  对动作的行为者表示敬意。</p>
<ul>
<li><p><span style="color: red;">尊敬动词</span></p>
<p>  与被动动词形态一致，作为 II 类动词活用。</p>
</li>
<li><p><span style="color: red;">お + 动词 ます形 + になります</span></p>
<p>  一般来说这一形态比尊敬动词更为礼貌。</p>
<p>  <strong><em>注意：如「みます」「ねます」等的「ます 形」单音节动词和 III 类动词不能使用这一形式。另外，若有特殊尊敬语的动词也要使用它自己的特殊尊敬语。</em></strong></p>
<p>  例如：「社長はもうお帰りになりました。」总经理已经回去了。</p>
</li>
<li><p><span style="color: red;">特殊尊敬语</span></p>
<p>  有些动词有自己的特殊尊敬语，表示与「お + 动词 ます形 + になります」同等程度的敬意。</p>
<p>  例如：「どうぞ召し上がってください。」请用餐吧。</p>
<table>
<thead>
<tr>
<th>行きます<br />来ます<br />います</th>
<th>いらっしゃいます（いらっしゃる）</th>
</tr>
</thead>
<tbody><tr>
<td>食べます<br />飲みます</td>
<td>召し上がります</td>
</tr>
<tr>
<td>言います</td>
<td>おっしゃいます（おっしゃる）</td>
</tr>
<tr>
<td>知っています</td>
<td>ご存じです</td>
</tr>
<tr>
<td>知りません</td>
<td>ご存じじゃありません</td>
</tr>
<tr>
<td>見ます</td>
<td>ご覧になります</td>
</tr>
<tr>
<td>します</td>
<td>なさいます（なさる）</td>
</tr>
<tr>
<td>くれます</td>
<td>くださいます（くださる）</td>
</tr>
</tbody></table>
<p>  <strong><em>注意：「いらっしゃる」 =&gt; 「いらっしゃいます」 =&gt; 「いらしゃらない」 =&gt; 「いらしゃらなかった」。「いらっしゃいます」 =&gt; 「いらっしゃった」。</em></strong></p>
</li>
<li><p><span style="color: red;">{ お / ご } 〜 ください</span></p>
<p>  这个句型是「动词 て形 + ください」的尊敬形式。</p>
<p>  I 类动词和 II 类动词为「お + 动词 ます形 + ください」。</p>
<p>  III 类动词「名词 + します」为「ご + 名词 + ください」。</p>
<p>  <strong><em>注意：如「みます」「ねます」等的「ます 形」单音节动词不使用这个形式。并且有特殊尊敬语的动词，要使用「特殊尊敬语 て形 + ください」的形式。</em></strong></p>
</li>
</ul>
</li>
<li><p><span style="color: red;">名词、形容词、副词</span></p>
<p>  名词、形容词及副词可以在词首加「お」或者「ご」，以此形式对那一名词的所有者或处于那一状态的人表示敬意。</p>
<p>  加「お」还是加「ご」，要根据所接的单词而定。</p>
<p>  一般来说，日语固有词（「和語（わご）」）加「お」；</p>
<p>  从汉语引进的词（「漢語（かんご）」）加「ご」。</p>
<ul>
<li><p>加「お」的例子：</p>
<p>  お名前、お国、お仕事、お元気、お忙しい</p>
</li>
<li><p>加「ご」的例子：</p>
<p>  ご家族、ご旅行、ご親切、ご自由に</p>
</li>
</ul>
<p>  <strong><em>注意：不仅仅是动词，句中的其他词语也经常会使用敬语。</em></strong></p>
<p>  例如：「部長の奥様もご一緒にゴルフに行かれます。」部长夫人也一起去打高尔夫球。</p>
</li>
</ul>
</li>
<li><p><strong>敬语与文体</strong></p>
<p> <strong>只对话题中的人物表示敬意，而不需要对听话人表示敬意时</strong>，可以将敬语放在简体的句子中。</p>
<p> 例如：「部長は何時にいらっしゃる？」部长什么时候来？</p>
</li>
<li><p><strong>～まして</strong></p>
<p> 想把话讲得更为礼貌时，可以把「动词 て形」变为「动词 ます形 + まして」。</p>
<p> 例如：「ハンスがゆうべ熱を出しまして、今朝もまだ下がらないんです。」汉斯从昨晚开始发烧，到今天早上也还没退烧。</p>
</li>
<li><p><strong>〜ますので</strong></p>
<p> 想把「普通形 + ので」变得更为礼貌时，可以用「礼貌形 + ので」。</p>
<p> 例如：「今日は学校を休ませますので、先生によろしくお伝えください。」今天就不让他去学校了，请转告一下老师。</p>
</li>
</ol>
<h5 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h5><p>本课学习的为敬语中的尊敬语的部分，需要注意的是这一课所学的尊敬语只能算是冰山一角而已。</p>
<hr>
<h4 id="第五十课（难点）"><a href="#第五十课（难点）" class="headerlink" title="第五十课（难点）"></a>第五十课（难点）</h4><ol>
<li><p><strong>谦逊语 I</strong></p>
<p> 谦逊语 I 是<strong>说话人和说话人一方的人为了向听话人及听话人一方的人表示敬意并低调地陈述自己的行为、动作时使用的表达方式</strong>。</p>
<ul>
<li><p><span style="color: red;">お / ご〜します（有动作承受方，主语一般用 「が」来表示）</span></p>
<ul>
<li><p><span style="color: red;">お + 动词（I 类 / II 类）ます形 + します</span></p>
<p>  例如：「重そうですね。お持ちしましょうか。」看着挺重的，我来帮您拿吧。</p>
<p>  上述例子是说话人对拿着行李的人（行李的所有者，在场的听话人）表示敬意。</p>
<p>  <strong><em>注意：如「みます」「います」等的「ます形」单音节动词不能使用这一形式。</em></strong></p>
</li>
<li><p><span style="color: red;">ご + 动词（III 类）</span></p>
<p>  这一形式用于 III 类动词时，敬语接头词不一定是「ご」，也有可能是「お」。</p>
<p>  如：「お電話します」「お約束します」「ご紹介します」「ご相談します」。</p>
<p>  例如：「今日の予定をご説明します。」我来说一下今天的安排。</p>
</li>
</ul>
</li>
<li><p><span style="color: red;">特殊谦逊语</span></p>
<p>  有些动词有自己的特殊谦逊语。</p>
<p>  例如：「社長の奥様にお目にかかりました。」我见到总经理夫人了。</p>
<table>
<thead>
<tr>
<th>行きます<br />来ます</th>
<th>参ります</th>
</tr>
</thead>
<tbody><tr>
<td>います</td>
<td>おります</td>
</tr>
<tr>
<td>たべます<br />飲みます<br />もらいます</td>
<td>いただきます</td>
</tr>
<tr>
<td>見ます</td>
<td>拝見します</td>
</tr>
<tr>
<td>言います</td>
<td>申します</td>
</tr>
<tr>
<td>します</td>
<td>いたします</td>
</tr>
<tr>
<td>（〜さんの家へ）行きます<br />聞きます</td>
<td>伺います</td>
</tr>
<tr>
<td>知っています</td>
<td>存じております</td>
</tr>
<tr>
<td>知りません</td>
<td>存じません</td>
</tr>
<tr>
<td>会います</td>
<td>お目にかかります</td>
</tr>
<tr>
<td>あります</td>
<td>ございます</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>谦逊语 II</strong></p>
<p> 这是<strong>说话人把自己和自己一方的动作、行为礼貌地告诉对方的表达方式</strong>。</p>
<p> 例如：「わたくしはミラーと申します。」我叫米勒。</p>
<p> 像这样使用「申します」代替「言います」的说法是说话人更有礼貌地把自己的行为告诉对方的表达方式。像这样的谦逊语还有「いたします」「〜ております」等。</p>
</li>
</ol>
<h5 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h5><p>本课所学的为敬语中的谦逊语部分，需要注意的这只是谦逊语中的冰山一角而已。</p>
<hr>
<center><div style="color: red; font-size: 24px;">つづく<div></center>]]></content>
      <categories>
        <category>日语</category>
      </categories>
      <tags>
        <tag>日语</tag>
        <tag>语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>みんなの日本語（四）</title>
    <url>/%E6%97%A5%E8%AF%AD/%E3%81%BF%E3%82%93%E3%81%AA%E3%81%AE%E6%97%A5%E6%9C%AC%E8%AA%9E%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<center><strong><span style="font-size: 22px;">文法记录与总结</span></strong></center>

<h4 id="第二十六课"><a href="#第二十六课" class="headerlink" title="第二十六课"></a>第二十六课</h4><a id="more"></a>

<ol>
<li><p><strong>{ 动词普通形 / い 形容词普通形 / <span style="color: red;">な 形容词普通形 + な</span> / <span style="color: red;">名词普通形 + な</span> } + んです</strong></p>
<p> <strong>「〜んです」只用于口语，书面形式用「〜のです」。</strong></p>
<ul>
<li><p><strong>～んですか</strong></p>
<ul>
<li><p>说话人对自己见到的、听到的事<strong>加以确认或要求对方予以说明</strong>时使用</p>
<p>  例如：</p>
<p>  当看到拿着淋湿了的雨伞的人时可以问对方：</p>
<p>  「雨が降っているんですか。」下着雨呢吗？</p>
</li>
<li><p>说话人要求对方对自己见到的、听到的事<strong>进行更为详细的说明</strong>时使用</p>
<p>  例如：</p>
<p>  「面白いデザインの靴ですね。どこで買ったんですか。」真是一双设计别样的鞋子呀，在哪买的？</p>
</li>
<li><p>说话人要求对方对自己见到的、听到的事的<strong>理由予以说明</strong>时使用</p>
<p>  例如：「どうして遅れたんですか。」你为什么迟到了？</p>
</li>
<li><p>要求就<strong>事态予以说明</strong>时使用</p>
<p>  例如：「どうしたんですか。」你怎么了？</p>
</li>
</ul>
<p>  <strong><em>注意：「〜んですか」如果使用不当的话，会让听话人感到不快，因此使用时需要注意。</em></strong></p>
</li>
<li><p><strong>〜んです</strong></p>
<ul>
<li><p>回答使用「〜んですか」的疑问句来说明理由时使用</p>
<p>  例如：</p>
<p>  「どうしたんですか。」你怎么了？</p>
<p>  ······「ちょっと気分が悪いんです。」有点不舒服。</p>
</li>
<li><p>说话人对自己所说的事情附加理由时使用</p>
<p>  例如：</p>
<p>  「よくカラオケにいきますか。」你经常去卡拉 OK 吗？</p>
<p>  ······「いいえ、あまり行きません。カラオケは好きじゃないんです。」不，不怎么去，我不喜欢卡拉 OK。</p>
</li>
</ul>
<p>  <strong><em>注意：只是叙述事实而不是说明理由时，不用「〜んです」。</em></strong></p>
</li>
<li><p><strong>〜んですが、〜</strong></p>
<p>  「〜んですが」有提起话头的作用，后面一般接表示委托、劝诱或请求许可等的表达方式。这时的「が」是作为开场白后的接续词使用的。若「〜んですが」后面接的内容是说话双方都明白的话可以省略。</p>
<p>  例如：</p>
<p>  「頭が痛いんですが、帰ってもいいですか。」我头有点疼，可以回去吗？</p>
<p>  「お湯が出ないんですが······」还没有热水······</p>
</li>
</ul>
</li>
<li><p><strong>动词 て 形 + <span style="color: red;">いただけませんか</span>（表示 “<em>能帮我······吗？</em>”）</strong></p>
<p> 这是较「〜てください」更为礼貌（更委婉）的提出请求的句型。</p>
<p> 例如：「いい先生を紹介していただけませんか。」您能帮我介绍一位好老师吗？</p>
</li>
<li><p><strong>疑问词 + 动词 た 形 + <span style="color: red;">らいいですか</span>（表示 “<em>······（做）好呢？</em>”）</strong></p>
<p> <strong>表示希望对方出主意、提建议或者给予指示。</strong></p>
<p> 「动词 た 形 らいいですよ」这一句型可以用于给对方出主意或提建议。</p>
<p> 例如：</p>
<p> 「国会議事堂を見学したいんですが、どうしたらいいですか。」我想去参观国会议事堂，应该怎么做呢？</p>
<p> ······「直接いったらいいですよ。」直接去就可以了。</p>
</li>
<li><p><strong>名词（对象） + <span style="color: red;">は</span> + { 好きです / 嫌いです / 上手です / 下手です / あります }</strong></p>
<p> 之前学过的把用助词「を」表示的直接宾语作为主题提示的用法。而作为「好きです」等的对象的用助词「が」来表示的名词也可以作为主题来提示。</p>
<p> <strong>实际上这一用法是搭配否定式来用的，肯定时使用助词「が」，而否定时使用助词「は」。</strong></p>
</li>
</ol>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>本课学习了口语表达「〜んです」的用法，以及「〜ていただけませんか」「疑问词 たらいいですか」等句型的使用方法。</p>
<hr>
<h4 id="第二十七课"><a href="#第二十七课" class="headerlink" title="第二十七课"></a>第二十七课</h4><ol>
<li><p><strong>可能动词</strong></p>
<p> 之前学过一个「名词 / 动词字典形 + ことができます」的句型来表示可能的形式。本课学习另外一种表示可能的形式，即可能动词。<strong>可能动词的活用与 II 类动词一致</strong>。另外，「分かります」本身就有 “可能” 的意思，所以不需要变为可能动词。</p>
<p> 将动词从字典型变为可能动词需要添加助动词「〜れる / 〜られる」。规则如下：</p>
<ul>
<li><p><span style="color: red;">I 类动词：「ます 形」イ 段变 エ 段（即「動詞辞書形」ウ 段变 エ 段）。</span></p>
</li>
<li><p><span style="color: red;">II 类动词：「ます 形」去 「ます」再加 「られ」（即「動詞辞書形」去「る」加「られ」）。</span></p>
</li>
<li><p><span style="color: red;">III 类动词：「きます / くる」变为「こられます / こられる」；「します / する」变为「できます / できる」</span></p>
<p>I 类动词变化的过程（使用动词字典形来说明）：首先将字典形变为「ない 形」，例如 「いきます」变为「いかない」，然后去掉「ない」再加「れる」，即「いかれる」，我们知道「か」和「れ」的罗马音分别为「ka」和「re」，那么取「ka」的「k」和「re」的「e」组合在一起即为「け」，即变为了「いける」。</p>
</li>
</ul>
</li>
<li><p><strong>可以使用可能动词的句子</strong></p>
<ul>
<li><p><strong>可能动词表示的是状态，而不是动作</strong>。可能动词的对象原则上要用<strong>助词「が」</strong>来表示，所以助词「を」需要变为「が」。<strong>「を」以外的助词不需要变</strong>。</p>
<p>  例如：</p>
<p>  「私は日本語（<s>を</s>）が話せます。」我能说日语。</p>
<p>  「一人で病院へ行けませんか。」你能一个人去医院吗？</p>
</li>
<li><p>可能动词用来表示<strong>行为者的能力</strong>和<strong>某一状态下的某行为的可能性</strong>。</p>
<p>  「私は漢字が読めます。」我会念汉字。（表示我的能力）</p>
<p>  「この銀行でドルが換えられます。」这家银行可以兑换美元。</p>
</li>
</ul>
</li>
<li><p><strong><span style="color: red;">見えます</span> 和 <span style="color: red;">聞（き）こえます</span></strong></p>
<p> 「見えます」和「聞こえなす」表示<strong>并非是本人的意志</strong>，而是某一对象物自然地进入视野，或某一声音自然地传到耳朵里。其对象使用<strong>助词「が」</strong>来表示。当表示有意识地去注意某事时，不能使用「見えます」「聞こえます」，应该使用可能动词。</p>
<p> 例如：「新幹線から富士山が見えます。」从新干线上可以看到富士山。</p>
</li>
<li><p><strong><span style="color: red;">できます</span></strong></p>
<p> 在这里的「できます」有<strong>产生</strong>、<strong>完成</strong>、<strong>干完</strong>、<strong>能做</strong>等意思。</p>
<p> 例如：「駅の前に大きいスーパーができました。」车站前新开了一家新超市。</p>
</li>
<li><p><strong><span style="color: red;">しか</span></strong></p>
<p> 「しか」接在<strong>名词</strong>、<strong>数量词</strong>等的后面，与表示否定的词一起使用，用来<strong>强调除了接「しか」的词语之外，其他的全部否定</strong>（也可以说是表示 ”仅仅” 的意思）。接在带有助词「が」和「を」的名词之后时，要<strong>去掉这两个助词</strong>。但是如果是「が」和「を」以外的助词，则可以直接接在这个助词之后。「しか」比较含蓄的表达了 “不很充分” 这个含义。</p>
<p> <strong><em>注意：「しか」只能与否定词一起使用，而「だけ」则是不管否定词还是肯定词都能搭配使用。</em></strong></p>
<p> 例如：「漢字しか書けません。」只会写汉字。</p>
</li>
<li><p><strong>名词 + <span style="color: red;">は</span>（对比）</strong></p>
<p> 助词「は」除了表示主题，还可以表示<strong>对比</strong>。</p>
<p> 例如：「ワインは飲みますが、ビールは飲みません。」我和葡萄酒，但不喝啤酒。</p>
</li>
<li><p><strong>用来提示带有助词的词语的「は」</strong></p>
<p> 助词「は」在接续带有助词「が」「を」的名词时，需要将「が」「を」去掉后再加「は」，而接续带有其他助词的名词时则直接加「は」即可。</p>
<p> 例如：「日本では馬を見ることができません。」在日本看不到马。</p>
</li>
</ol>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>本课学习了一个很重要的动词即可能动词的用法。</p>
<hr>
<h4 id="第二十八课"><a href="#第二十八课" class="headerlink" title="第二十八课"></a>第二十八课</h4><ol>
<li><p><strong>动词1 ます形 + <span style="color: red;">ながら</span> + 动词2</strong></p>
<p> 这个句型表示在进行动词2 的动作的同时进行动词1 的动作。<strong>动词2 是主要动作（即主句）</strong>。</p>
<p> 例如：「テレビを見ながら朝ご飯を食べます。」一边看电视一边吃早饭。</p>
<p> 这个句型也可以表示<strong>在某一期间一直持续做着两件事</strong>。</p>
<p> 例如：「働きながら、日本語を勉強しています。」一边工作一边学习日语。</p>
</li>
<li><p><strong>动词 て形 + <span style="color: red;">います</span></strong></p>
<p> 这个句型可以用于表示<strong>习惯性地反复进行某行为</strong>，这一行为发生在说话人说此话之前时，需要使用「〜ていました」。</p>
<p> 例如：「子どものとき、毎朝ジョギングをしていました。」我小时候每天早上都跑步。</p>
</li>
<li><p><strong>普通形し、普通形し、〜</strong></p>
<ul>
<li><p>要<strong>就主题列举两个以上类似的事情</strong>时使用本句型。这里所说的类似指的是比如叙述的事情<strong>同是优点</strong>或者<strong>同是缺点</strong>。</p>
<p>  另外，由于这个句型包含着说话人不止想说一件事，还想加上另外一件事的心情，所以常常用助词「も」。为了使这一心情更明确，通常会在最后一个理由的叙述前加上「それに」。</p>
<p>  例如：「田中さんは真面目だし、日本語も上手だし、それに経験もたくさんあります。」田中很认真，日语也很好，而且经验丰富。</p>
</li>
<li><p>「〜し、〜し」也可以用于表示后续部分的理由。</p>
<p>  如果结论很明确，有时也会只列举理由，而省略其他部分。</p>
<p>  最后一个「し」有时会用表示理由的「から」来代替。</p>
<p>  例如：</p>
<p>  「どうして日本のアニメが好きなんですか。」为什么喜欢日本的动画片？</p>
<p>  ······「話も面白いし、音楽もすてきですから。」因为情节很有意思，而且音乐也很棒。</p>
</li>
</ul>
</li>
<li><p><strong><span style="color: red;">それで</span></strong></p>
<p> 「それで」用于把前面所叙述的事情作为理由，来讲述由此而引出的结论。</p>
<p> 「将来小説家になりたいです。それで今はアルバイトをしながら小説を書いています。」将来想当个小说家，所以现在一边打工，一边写小说。</p>
</li>
<li><p><strong>〜とき + 助词</strong></p>
<p> 之前学过的「とき」是名词，所以后面是可以接助词的。</p>
<p> 例如：「勉強するときは、音楽を聞きません。」学习的时候不听音乐。</p>
</li>
</ol>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p>本课学习了「ながら」「〜し、〜し」等句型的用法（又学了一个表示列举的句型）。</p>
<hr>
<h4 id="第二十九课"><a href="#第二十九课" class="headerlink" title="第二十九课"></a>第二十九课</h4><ol>
<li><p><strong>动词 て形 + <span style="color: red;">います</span></strong></p>
<p> 这个句型也可以<strong>表示因某一动作而产生的结果状态一直持续着</strong>。</p>
<p> 可以使用这种用法的动词是像「開きます」「閉まります」这样的<strong>自动词</strong>，其动作发生之前和之后会起变化的动词。</p>
<p> <strong>另外，在直接描述眼前的状态时，主体使用助词「が」表示。将主体作为主题来提示时使用助词「は」。</strong></p>
<p> 例如：「窓が割れています。」窗户碎了。</p>
</li>
<li><p><strong>动词 て形 + { <span style="color: red;">しまいました</span> / <span style="color: red;">しまいます</span> }</strong></p>
<p> <strong>「〜てしまいました」表示动作已经完了。「〜てしまいます」表示在将来的某个时刻，动作会完。「〜てしまいました」也可以用来表示说话人后悔和遗憾的心情。</strong></p>
<p> <strong><em>注意：动词 て形如果需要使用「ある」，则需替换为「でる」。</em></strong></p>
<p> 例如：</p>
<p> 「漢字の宿題はもうやってしまいました。」汉字作业已经做完了。</p>
<p> 「パスポートをなくしてしまいました。」把护照弄丢了。</p>
</li>
<li><p><strong>名词（场所）+ <span style="color: red;">に</span> + { 行きます / 来ます / 帰ります }</strong></p>
<p> 可以用<strong>表示到达点的助词「に」</strong>来代替表示方向的助词「へ」。像「行きます」「来ます」「帰ります」这样的移动动词，可以使用「场所 + へ」也可以使用「场所 + に」。</p>
<p> 例如：</p>
<p> 「どこかで財布を落としてしまったんです。」不知在哪里把钱包弄丢了。</p>
<p> ······「それは大変ですね。すぐ交番に行かないと。」那可遭了，得赶紧去派出所。</p>
</li>
<li><p><strong>それ / その / そう</strong></p>
<p> 之前学过用指示代词指示所在场所内的物品，本课所学的这三个指示代词用于指代对方所说的话或文章中出现的内容。</p>
<ul>
<li><p>对话中（可以指对方刚刚说过的内容）</p>
<p>  「<strong>どこかで財布を落としてしまった</strong>んです。」不知在哪里把钱包弄丢了。</p>
<p>  ······「<strong>それ</strong>は大変ですね。すぐ交番に行かないと。」那可遭了，得赶紧去派出所。</p>
</li>
<li><p>文章中（可以指前面句子中出现的内容）</p>
<p>  「一人でコンサートや展覧会に出かけると、いいでしょう。そのとき会った人が将来の恋人になるかもしれません。」一个人去音乐会和展览会也不错嘛，或许那时遇到的人会成为将来的恋人呢。</p>
</li>
</ul>
</li>
<li><p><strong>ありました</strong></p>
<p> 「[鞄が]ありましたよ。」[包]找到了。</p>
<p> 这里的「ありました」是表示说话人发现了 “有包” 这一事实，而不是 “以前那里有包” 的意思。</p>
</li>
<li><p><strong>どこかで / どこかに</strong></p>
<p> 「どこか」「なにか」后面的助词「へ」「を」可以省略。「どこかで」「どこかに」后面的助词「で」「に」不能省略。</p>
<p> 例如：「どこかに電話がありますか。」哪儿有电话？</p>
</li>
</ol>
<h5 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h5><p>本课主要学习的是自动词与他动词的用法。</p>
<hr>
<h4 id="第三十课"><a href="#第三十课" class="headerlink" title="第三十课"></a>第三十课</h4><ol>
<li><p><strong>动词 て形 + <span style="color: red;">あります</span></strong></p>
<p> 这个句型表示<strong>有人为了某种目的而进行的某一行为的结果仍然存在</strong>。所用的动词为<strong>他动词</strong>。</p>
<ul>
<li><p><strong>名词1 + <span style="color: red;">に</span> + 名词2 + <span style="color: red;">が</span> + 动词 て形 + あります</strong></p>
<p>  例如：「机の上にメモが置いてあります。」桌子上放着留言条。</p>
</li>
<li><p><strong>名词2 + <span style="color: red;">は</span> + 名词1 + <span style="color: red;">に</span> + 动词 て形 + あります</strong></p>
<p>  将名词2 作为主题提示时使用助词「は」。</p>
<p>  例如：「今月の予定はカレンダーに書いてあります。」这个月的计划写在月历上。</p>
</li>
<li><p>「〜てあります」与「〜ています」的区别</p>
<p>  当「〜てあります」与「〜ています」使用成对的自动词和他动词时，<strong>「〜ています」只是单纯的叙述持续的状态</strong>，而「〜てあります」则表示<strong>变成那样的状态是由于某个人的行为而产生的结果</strong>。</p>
<p>  例如：</p>
<p>  「窓が<span style="color: red;">閉まっています</span>。」窗户关着。</p>
<p>  「窓が<span style="color: red;">閉めてあります</span>。」窗户关上了。</p>
</li>
</ul>
</li>
<li><p><strong>动词 て形 + <span style="color: red;">おきます</span></strong></p>
<ul>
<li><p>表示在<strong>某一时间之前结束必要的动作、行为（即事先做好准备）</strong>。</p>
<p>  例如：</p>
<p>  「旅行のまえに、切符を買っておきます。」去旅行前先买好票。</p>
</li>
<li><p>表示<strong>以备下次使用而完成必要的动作或采取临时的措施（也可以理解为事先做好准备）</strong>。</p>
<p>  例如：</p>
<p>  「はさみを使ったら、元の所に戻しておいてください。」剪刀用完后，请放回原位。</p>
</li>
<li><p>表示<strong>把成为结果的状态一直保持下去</strong>。</p>
<p>  <strong><em>注意：在口语中「〜ておきます」经常念做「〜ときます」。</em></strong></p>
<p>  例如：</p>
<p>  「明日会議がありますから、椅子はこのままにしておいてください。」明天还有会，椅子就那样放着吧。</p>
</li>
</ul>
</li>
<li><p><strong>まだ + 肯定（表示 “还······”）</strong></p>
<p> 这个「まだ」表示 “还” 的意思，表示<strong>动作和状态仍在继续</strong>。</p>
<p> 例如：「まだ雨が降っています。」雨还在下。</p>
</li>
<li><p><strong><span style="color: red;">とか</span></strong></p>
<p> 「とか」与「や」一样用于表示列举，<strong>区别是「とか」可以加在最后一个名词之后并且更加的口语化</strong>。</p>
<p> 例如：「懐中電灯とか、ラジオとか······」手电筒、收音机什么的。</p>
</li>
<li><p><strong>格助词 + <span style="color: red;">も</span></strong></p>
<p> 助词「も」接在带有助词「が」和「を」的名词之后时，要将助词「が」和「を」去掉。接在这两个助词以外的助词之后时，则直接接在其后（助词「へ」可以去掉也可以保留）。</p>
<p> 例如：</p>
<p> 「ほか<span style="color: red;">にも</span>色々あります。」还有很多其他各种各样的。</p>
<p> 「どこ<span style="color: red;">[へ]も</span>行きません。」哪儿也不去。</p>
</li>
</ol>
<h5 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h5><p>本课学习的是「〜てあります」与「〜ておきます」的句型，要注意「〜てあります」与上一课的「〜ています」的区别。</p>
]]></content>
      <categories>
        <category>日语</category>
      </categories>
      <tags>
        <tag>日语</tag>
        <tag>语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Thinking in Java 笔记</title>
    <url>/Java/Thinking-in-Java-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h5 id="对象导论"><a href="#对象导论" class="headerlink" title="对象导论"></a>对象导论</h5><ol>
<li>访问控制的第一个存在原因就是让客户端程序员无法接触到他们不该接触的部分，这些部分对数据类型的内部操作来说是必须的，但并不是用户解决特定问题所需的接口的一部分。<a id="more"></a></li>
<li>访问控制的第二个存在原因就是允许库设计者可以改变内部的工作方式而不用担心会影响到客户端程序员。</li>
<li>因为是在使用现有的类合成新的类，所以这种概念被称为 “组合” ，如果组合是动态发生的，那么它通常被称为 “聚合” 。组合通常被视为 “拥有（ has a ）” 关系。</li>
<li>继承：简单的可以理解为青出于蓝而胜于蓝</li>
<li>两种方法使子类与父类具有差异性：① 新增父类没有的方法（需要考虑是否父类也有需要这些新增的方法的可能性）② 覆盖父类中已有的方法</li>
<li>纯粹替代（替代原则）</li>
<li>前期绑定、后期绑定<ul>
<li>前期绑定：在程序执行前根据编译时类型绑定</li>
<li>后期绑定：当向对象发送消息时，被调用的代码直到运行时才能确定，编译器确保被调用方法的存在，并对调用参数和返回值执行类型检查（无法提供此类保证的语言被称为是弱类型的），但是并不知道将被执行的确切代码</li>
</ul>
</li>
<li>把将子类看作是他的父类的过程称为 “向上转型”</li>
<li>并发需要考虑共享资源的问题</li>
<li>事务处理：保证一个客户插入的新数据不会覆盖另一个客户插入的新数据，也不会在将其添加到数据库的过程中丢失</li>
</ol>
<hr>
<h5 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h5><ol>
<li>“==” 和 “!=” 比较的是对象的引用。<code>equals()</code> 的默认行为也是比较引用。</li>
<li>窄化转化（高精度转换为低精度，例如 long 转为 int ）与扩展转换（低精度转换为高精度，例如 int 转换为 long ）。</li>
<li>在进行窄化转换时，Java 默认是不会进行四舍五入操作的，也就是说直接舍弃掉小数部分只保留整数部分。如果需要四舍五入，则要使用 <code>Math.round()</code> 方法对数字进行操作。</li>
<li>低位数值（如 int ）在与高位数值（如 long ）进行运算时，结果会按高位来进行输入（输入 long 类型的结果）。</li>
<li>在进行运算时要注意溢出。</li>
</ol>
<hr>
<h5 id="初始化和清理"><a href="#初始化和清理" class="headerlink" title="初始化和清理"></a>初始化和清理</h5><ol>
<li>只能在构造器中使用 <code>this</code> 来调用其他构造器，并且这个调用在构造器中只能调用一次，并且这个调用一定是在起始处，并且禁止在非构造方法中使用 <code>this</code> 调用构造器。</li>
<li>引用计数模式、停止-复制模式、标记-清扫模式。自适应清理。</li>
<li>在类的内部，变量定义的先后顺序决定了初始化的顺序，即使变量定义分散在方法定义之间，他们仍旧会在任何方法（包括构造器）被调用之前初始化。</li>
<li>可变参数（Object… args）本质上是一个数组，如若传 0 个参数给可变参数列表，这是可行的。在 JDK1.5 之前没有可变参数特性时，会使用（Object[] args）这样的形式来实现可变参数。</li>
<li>可变参数列表使得重载过程变得复杂了，可以通过增加一个非可变参数来解决这个问题。</li>
</ol>
<hr>
<h5 id="访问权限控制"><a href="#访问权限控制" class="headerlink" title="访问权限控制"></a>访问权限控制</h5><ol>
<li><code>package</code> 关键字和 <code>import</code> 关键字允许做的是将单一的全局命名空间分割开，使得无论多少人使用，都不会出现名称冲突的问题。</li>
<li>访问权限的控制通常被称为是具体实现的隐藏，把数据和方法包装进类当中，以及具体实现的隐藏，共同被称为封装。其结果是一个同时带有特征和行为的数据类型。</li>
</ol>
<hr>
<h5 id="复用类"><a href="#复用类" class="headerlink" title="复用类"></a>复用类</h5><ol>
<li>初始化引用有四种方法：<ul>
<li>在定义对象的地方，这意味着他们总是能够在构造器被调用之前被初始化（也就是定义了就直接初始化）</li>
<li>在类的构造器中（也就是在构造方法中对本类所拥有的属性或其他的进行初始化）</li>
<li>在正要使用对象之前，这种方法被称为惰性初始化（即延迟初始化 Delayed initialization ），在生成对象不值得及不必每次都生成对象的情况下，这种方式可以减少额外的负担</li>
<li>使用实例初始化（ new 一个对象）</li>
</ul>
</li>
<li>当创建了一个子类的对象，该对象包含了一个父类的子对象，这个对象与用父类直接创建的对象是一样的。所以在子类的构造方法中第一件应该做的事就是调用父类的构造方法（即 <code>super.constructor()</code> ）</li>
<li>复用类的三种方法：组合、继承、代理<ul>
<li>代理：在类中放置一个成员对象，并暴露该成员对象的所有方法（调用）</li>
</ul>
</li>
<li>到底是使用组合还是继承，一个最清晰的办法是问一问自己是否需要从新类向基类进行向上转型；如果需要向上转型，那么继承是必要的；如果不需要，则应当好好考虑是否需要继承</li>
<li>一个既是 <code>static</code> 又是 <code>final</code> 的域只占据一段不能改变的存储空间</li>
<li>给引用添加 <code>final</code> 时，意味着这个引用无法再指向另一个新的对象，但是已经指向的对象内部的成员变量是允许修改的</li>
<li>空白 <code>final</code> ：声明为 <code>final</code> 但是又未给定初值的域。（如 <code>public final String s;</code> ）空白 <code>final</code> 必须在使用之前被初始化（意味着必须在构造器中初始化）</li>
<li><code>final</code> 参数：在参数列表中以声明方式将参数指明为 <code>final</code> ，这一特性主要用来向匿名内部类传递数据</li>
<li><code>final</code> 类中的所有方法都隐式的指定为 <code>final</code>，因为无法覆盖他们。所以在 <code>final</code> 类中可以给方法添加 <code>final</code> 修饰词，但是这样没意义</li>
<li>构造器也是 <code>static</code> 方法，尽管 <code>static</code> 关键字并没有显式地写出来，因此更准确的讲，类是在其任何 <code>static</code> 成员被访问时加载的</li>
</ol>
<hr>
<h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><ol>
<li><p>将一个方法同一个方法主体关联起来称为 “绑定”</p>
<ul>
<li>若在程序执行前进行绑定（如果有的话，由编译器和连接程序实现），叫做<strong>前期绑定</strong></li>
<li>在运行时根据对象类型进行绑定叫做<strong>后期绑定</strong>，也叫做<strong>动态绑定</strong>或者<strong>运行时绑定</strong></li>
<li>Java 中除了 <code>static</code> 方法和 <code>final</code> 方法（ <code>private</code> 方法属于 <code>final</code> 方法）之外，其他所有方法都是后期绑定</li>
</ul>
</li>
<li><p>我们所做的修改，不会对程序中其他不应受影响的部分造成破坏</p>
</li>
<li><p>:star:注意：调用构造器的顺序：</p>
<ol>
<li>在其他任何事物发生之前，将分配给对象的存储空间初始化成二进制的零</li>
<li>调用基类构造器。这个步骤会不断地反复递归下去，首先是构造这种层次结构的根，然后是下一层导入类，依此类推，直到最底层的导出类</li>
<li>按声明顺序调用成员变量的初始化方法</li>
<li>调用导出类构造器的主体</li>
</ol>
</li>
<li><p>销毁对象的顺序应与声明对象的顺序相反。若某个类中的成员对象也存在于其他一个或多个类中（共享的情况），那就不能简单的进行销毁，这种情况应当使用 “引用计数” 来跟踪仍旧访问着共享对象的数量</p>
</li>
<li><p>由于在构造器中调用某个动态绑定的方法会造成所有数据可能为零的情况（原因参考调用构造器顺序中的第一点），所以在编写构造器时，要尽可能的遵循这一条规则：“<strong>用尽可能简单的方法使对象进入正常状态，如果可以的话，避免调用其他方法</strong>”。在构造器内部唯一能够安全调用的方法是基类中的 <code>final</code> 方法（也适用于 <code>private</code> 方法，因为 <code>private</code> 方法自动属于 <code>final</code> 方法），因为这些方法不能被覆盖，也就不存在在基类构造器中调用导出类中对基类的某个方法的覆盖</p>
</li>
<li><p>协变返回类型：在导出类中的被覆盖方法可以返回基类方法的返回类型的某种导出类型</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Grain&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wheat</span> <span class="keyword">extends</span> <span class="title">Grain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Wheat&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mill</span> </span>&#123;</span><br><span class="line">    <span class="function">Grain <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Grain();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WheatMill</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 覆盖父类的 process() 方法</span></span><br><span class="line">    <span class="comment">// 并将返回值修改成 Grain 类的子类 Wheat</span></span><br><span class="line">    <span class="function">Wheat <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wheat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用继承表达行为间的差异，并用字段表达状态上的变化（状态模式）</p>
</li>
<li><p>运行时类型识别（RTTI : Runtime type infomation ）</p>
<ul>
<li>向下转型对类型进行检查时，如果类型不对，会抛出一个 <code>ClassCastException</code> （类转型异常）</li>
</ul>
</li>
</ol>
<hr>
<h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><ol>
<li>创建一个能够根据所传递的参数对象的不同而具有不同行为的方法，叫做 “策略模式”</li>
<li>适配器中的代码将接收你所拥有的接口，并产生你所需要的接口（适配器模式）</li>
<li>使用接口的核心原因：为了能够向上转型为多个基类<ul>
<li>使用接口的第二个原因：防止客户端程序员创建该类的对象（抽象类也能做到）</li>
<li>如果要创建一个不带任何方法定义以及成员变量的基类，那么就应该使用接口而不是抽象类</li>
</ul>
</li>
<li>恰当的原则是应当优先选择类而不是接口，从类开始，如果接口的必需性变得非常明确，那么就进行重构</li>
<li>尽量避免在组合的不同接口中使用相同的方法名</li>
<li>使用工厂方法模式的常见原因是创建框架</li>
</ol>
<hr>
<h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h5><ol>
<li><p>在内部类中生成外部类的对象的引用需要使用 <code>OuterClass.this</code> ；要想创建某个内部类的对象需要使用外部类对象才能创建</p>
<ul>
<li><p>在拥有外部类对象之前是不可能创建内部类对象的，因为内部类对象会连接到创建他的外部类对象上。如果创建的是<strong>静态内部类</strong>，那么就不需要对外部类对象的引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        <span class="comment">// 使用外部类对象创建内部类对象</span></span><br><span class="line">        Inner inner = outer.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>定义一个匿名内部类并且希望他使用一个在其外部定义的对象，那么编译器会要求其参数引用是 <code>final</code> 的</p>
</li>
<li><p>匿名内部类中的实例初始化（构造器效果）：使用非静态代码块来实现（因为每次创建对象都会执行）</p>
<ul>
<li><p>匿名内部类中的实例初始化方法无法重载，所有有且仅有一个构造器</p>
</li>
<li><p>基类需要的是有参构造器：将基类需要的参数传递给基类的构造器即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getProduct</span><span class="params">(<span class="keyword">final</span> <span class="keyword">float</span> widget)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Product() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> cost;</span><br><span class="line">            <span class="comment">// 非静态代码块（相当于匿名内部类的构造器）</span></span><br><span class="line">            &#123;</span><br><span class="line">                cost = Math.round(widget);</span><br><span class="line">                <span class="keyword">if</span> (cost &gt; <span class="number">100</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;超重！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Product!&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>不需要内部类与外部类有联系时，可以使用关键字 <code>static</code> 来声明内部类，通常称为嵌套类</p>
<ul>
<li>普通内部类对象隐式地保存了一个引用，指向创建他的外部类对象</li>
<li>当内部类是 <code>static</code> 时意味着：<ul>
<li>要创建嵌套类的对象，并不需要外部类的对象</li>
<li>不能从嵌套类的对象中访问非静态的外部类对象</li>
<li>普通内部类的字段与方法，只能放在类的外部层次上，所以普通内部类中不能有 <code>static</code> 数据和 <code>static</code> 字段，也不能包含嵌套类。但是嵌套类中可以包含上述所有</li>
</ul>
</li>
</ul>
</li>
<li><p>接口内部的类由于是自动 <code>public</code> 和 <code>static</code> 的，所以甚至可以在接口内部实现接口本身</p>
</li>
<li><p>一个内部类被嵌套多少层不重要，反正都能访问所有在他外面的外部类的所有成员</p>
</li>
<li><p>使用内部类最重要的原因是：每个内部类都能独立的继承自一个（接口的）实现，所以无论外部类是否已经继承了某个（接口的）实现，对于内部类都没有影响</p>
</li>
<li><p>如果使用内部类，可以获得一些如下所示的特性：</p>
<ul>
<li>内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外部类对象的信息相互独立</li>
<li>在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类</li>
<li>创建内部类对象的时刻不依赖于外部类对象的实现</li>
<li>内部类没有 “is-a” 关系，他就是一个独立的实体</li>
</ul>
</li>
<li><p>闭包（ closure ）：是一个可调用的对象，他记录了一些信息（持有上下文中某部分信息），这些信息来自于创建它的作用域</p>
<ul>
<li>内部类是面向对象的闭包，因为他不仅包含了外部类对象（创建内部类作用域）的信息，还持有一个指向外部类对象的引用，在此作用域内，内部类有权操作所有的成员（包括 <code>private</code> 成员）</li>
<li><strong>回调（ callback ）：通过回调，对象能够携带一些信息，这些信息允许他在稍后的某个时刻调用初始的对象</strong></li>
<li>回调的价值在于他的灵活性，可以在运行时动态决定需要调用什么方法</li>
</ul>
</li>
<li><p>模板方法模式：模板方法包括算法的基本结构，并且会调用一个或多个可覆盖方法，以完成算法的动作。设计模式总是将变化的事物与不变的事物分离开，在模板方法模式中，模板方法是保持不变的事物，而那些可覆盖的方法就是变化的事物</p>
</li>
<li><p>主要用来响应事件的系统叫做 “事件驱动系统”</p>
</li>
<li><p>内部类允许：</p>
<ul>
<li>控制框架的完整实现是由单个的类创建的，从而使得实现的细节被封装了起来，内部类用来表示解决问题所必须的各种动作</li>
<li>内部类能够很容易的访问外部类的任意成员，所以可以避免这种实现变得笨拙</li>
</ul>
</li>
<li><p>内部类的继承：</p>
<ul>
<li>内部类的构造器必须连接到指向外部类对象的引用</li>
<li>所以在继承内部类时必须要有一个已经初始化了的外部类的对象，也就是要在内部类的子类的构造器中调用包含内部类的外部类对象的初始化方法 <code>enclosingClassReference.super()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部类和内部类原型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承内部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendInnerClass</span> <span class="keyword">extends</span> <span class="title">Outer</span>.<span class="title">Inner</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造方法中传递一个外部类的引用</span></span><br><span class="line">    <span class="comment">// 并且调用这个引用生成一个可连接的外部类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExtendInnerClass</span><span class="params">(Outer outer)</span> </span>&#123;</span><br><span class="line">        outer.<span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExtendInnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        ExtendInnerClass extendInnerClass = <span class="keyword">new</span> ExtendInnerClass(outer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个新类继承自外部类时，重新定义外部类里面的内部类（也就是覆盖他们），实际上是覆盖不了的，除非在新类中创建一个内部类并指定他继承自外部类里面的内部类</p>
</li>
<li><p>局部内部类不能有访问说明符，因为他不是外部类的一部分，但是他可以访问当前代码块里的常量以及外部类的所有成员。局部内部类允许有以类名命名的构造器</p>
<ul>
<li>使用局部内部类而不是匿名内部类的原因是<strong>需要一个已命名的构造器，或者需要重载构造器</strong>，而匿名内部类只能用于实例初始化</li>
<li>使用局部内部类而不是匿名内部类的另一个原因就是<strong>需要不止一个该内部类的对象</strong></li>
</ul>
</li>
<li><p>内部类编译文件命名规则（<code>.class</code> 文件）：<code>外部类类名$内部类类名.class</code></p>
<ul>
<li>匿名内部类编译文件只会简单地产生一个数字作为标识符，例如 <code>外部类类名$1.class</code>、<code>外部类类名$2.class</code> 。如果是嵌套的内部类，只需用 <code>$</code> 将其连接在其外部类后面既可</li>
</ul>
</li>
</ol>
<hr>
<h5 id="通过异常处理错误"><a href="#通过异常处理错误" class="headerlink" title="通过异常处理错误"></a>通过异常处理错误</h5><ol>
<li><p>异常情形：是指阻止当前方法或作用域继续执行的问题</p>
</li>
<li><p>监控区域：他是一段可能产生异常的代码，并且后面跟着处理这些异常的代码</p>
</li>
<li><p>重抛异常会将异常抛给上一级环境中的异常处理程序，同一个 <code>try</code> 块的后续 <code>catch</code> 子句将被忽略。如果只是将当前异常对象重新抛出，那么 <code>printStackTrace()</code> 方法显示的将是原来异常抛出点的调用栈的信息，而不是重新抛出点的信息，若想更新这个信息，可以调用 <code>fillInStackTrace()</code> 方法，这样就将返回一个新的 <code>Throwable</code> 对象，他是通过把当前调用栈信息填入原来那个异常对象而建立的（原有的调用栈信息将会丢失）</p>
</li>
<li><p>由于异常对象都是在堆上建立的，故垃圾回收器会自动将其回收</p>
</li>
<li><p><code>Exception</code> 是可以被抛出的基本类型，在 Java 类库、用户方法以及运行时故障中都有可能抛出 <code>Exception</code> 型异常；<code>Error</code> 用来表示编译时和系统错误</p>
</li>
<li><p>如果不捕获 <code>RuntimeException</code> 类型的异常而直达 <code>main()</code> 方法，那么在程序退出前会调用异常的 <code>printStackTrace()</code> 方法</p>
</li>
<li><p>只能在代码中忽略 <code>RuntimeException</code> 类型的异常，因为 <code>RuntimeException</code> 代表的是编程错误：</p>
<ul>
<li>无法预料的错误（比如使用 null 引用）</li>
<li>应该在代码中检查的错误（比如数组越界）</li>
</ul>
</li>
<li><p>派生类构造器不能捕获基类构造器抛出的异常</p>
</li>
<li><p>异常限制对构造器不起作用</p>
</li>
<li><p>对于在构造阶段可能会抛出异常，并且要求清理的类，最安全的使用方式是使用嵌套的 <code>try-catch</code> 语句。基本原则是：<strong>在创建需要清理的对象后，立即进入一个 <code>try-finally</code> 语句块</strong></p>
</li>
<li><p>异常处理的一个重要原则是：<strong>只有在你知道如何处理的情况下才去捕获异常</strong>。<strong>异常处理的一个重要目标就是把错误处理的代码同错误发生的地点相分离</strong></p>
</li>
<li><p>非检查异常通常指的是 <code>RuntimeException</code> ，也就是运行时异常</p>
</li>
<li><p>可以将被检查的异常包装进 <code>RuntimeException</code> 中</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WrapCheckedException 中 throwRuntimeException() 方法可以抛出各种异常</span></span><br><span class="line"><span class="comment">// 但是都被包装在 RuntimeException 中</span></span><br><span class="line"><span class="comment">// 所以在调用 throwRuntimeException() 方法时并不会要求捕获异常</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WrapCheckedException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throwRuntimeException</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException();</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;WTF?&quot;</span>);</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OtherException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TurnOffChecking</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WrapCheckedException wce = <span class="keyword">new</span> WrapCheckedException();</span><br><span class="line">        wce.throwRuntimeException(<span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                    wce.throwRuntimeException(i);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> OtherException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (OtherException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;OtherException &quot;</span> + e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException re) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> re.getCause();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;FileNotFoundException &quot;</span> + e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;IOException &quot;</span> + e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Throwable &quot;</span> + e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>应当在以下情况使用异常：</p>
<ul>
<li>在恰当的级别处理问题（在知道该如何处理的情况下采取捕获这个异常）</li>
<li>解决问题并且重新调用产生异常的方法</li>
<li>进行少许修补，然后绕过异常发生的地方继续执行</li>
<li>用别的数据进行计算，以代替方法预计会返回的值</li>
<li>把当前运行环境下能做的事情尽量做完，然后把相同的异常重抛到更高层</li>
<li>把当前运行环境下能做的事情尽量做完，然后把不同的异常重抛到更高层</li>
<li>终止程序</li>
<li>进行简化</li>
<li>让类库和程序更安全</li>
</ul>
</li>
</ol>
<hr>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><ol>
<li><p>使用 “+” 操作符连接字符串原理：构建一个 StringBuilder 对象，使用 StringBuilder 对象的 <code>append()</code> 方法来连接 “+” 操作符的每一个部分，最后将 StringBuilder 对象连接好的字符串通过 <code>toString()</code> 方法返回。所以如果要连接的字符串较长，则应该直接使用 StringBuilder 来进行连接（尤其是在循环中，因为如果直接使用 “+” 操作符来连接，每一次循环都会创建一个 StringBuilder 对象），并且 StringBuilder 还支持直接预先为其指定大小</p>
</li>
<li><p>如果希望 <code>toString()</code> 方法打印出对象的内存地址，应该使用 Object 类的 <code>toString()</code> 方法，即 <code>super.toString()</code> 。因为如果使用 this 关键字来打印对象的内存地址的话，可能会发生自动类型转换（通常是因为 “+” 操作符），而自动类型转换会调用 this 的 <code>toString()</code> 方法，这样就会导致无意识的递归而出错</p>
</li>
<li><p>Formatter 类可用于格式化字符串与翻译数据，格式化修改语法：<br> <code>%[argument_index$][flags][width][.precision]conversion</code></p>
<ul>
<li>width 用来控制域的长度</li>
<li>可以用 “-” 符号来改变对齐方向（默认右对齐）</li>
<li>precision 用来指定最大尺寸，例如小数点后的位数，字符串的长度等</li>
</ul>
</li>
<li><p><code>String.format()</code> 内部也是创建一个 Formatter 对象来格式化字符串的</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">format</span><span class="params">(String format, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Formatter().format(format, args).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h5 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h5><ol>
<li>所有的类都是在对其第一次使用时，动态加载到 JVM 中的，当程序创建第一个对类的静态成员的引用时，就会加载这个类，这个证明构造器也是类的静态方法，即使在构造器之前并没有使用 <code>static</code> 关键字。所以使用 new 操作符创建类的新对象也会被当作对类的静态成员的引用</li>
<li>如果一个类还没被加载，那么可以使用 <code>Class.forName(&quot;类名&quot;)</code> 来加载他</li>
<li>使用 <code>.class</code> 来创建对 Class 对象的引用时，不会自动初始化该 Class 对象</li>
<li>为了使用类而做的准备工作实际上包含三个步骤：<ol>
<li>加载。这是由类加载器执行的，该步骤将查找字节码（通常在 classpath 所指定的路径中查找，但这并非是必需的），并从这些字节码中创建一个 Class 对象</li>
<li>链接。在链接阶段将验证类中的字节码，为静态域分配存储空间，并且如果必需的话，将解析这个类创建的对其他类的所有引用</li>
<li>初始化。如果该类具有超类，将对其初始化，执行静态初始化和静态初始化块</li>
</ol>
</li>
<li>初始化被延迟代理对静态方法（构造器隐式的是静态的）或者非常数静态域进行首次引用时才进行</li>
<li>如果一个 <code>static final</code> 值是编译器常量，那么这个值不需要对类进行初始化就可以被读取。但是，如果只是将一个域设为 <code>static final</code> ，就不足以确保这种行为。如果一个 <code>static</code> 域不是 <code>final</code> 的，那么在对他进行访问时，总是要求在被读取前，要先进行链接（为这个域分配存储空间）和初始化（初始化该存储空间）</li>
<li>已知的 RTTI （ Runtime Type Identification ）形式有：<ol>
<li>传统的类型转换，由 RTTI 确保类型转换的正确性，如果执行了一个错误的类型转化，就会抛出一个 ClassCastException 异常</li>
<li>代表对象的类型的 Class 对象，通过查询 Class 对象可以获取运行时所需的信息</li>
<li><code>instanceof</code> 关键字</li>
</ol>
</li>
<li><code>instanceof</code> 与 “==” 区别：<code>instanceof</code> 保持了类型的概念，他指的是 ”你是这个类吗？或者你是这个类的派生类吗？“；而 “==” 就没有考虑继承，他或者是这个确切的类型，或者不是</li>
<li>RMI（远程方法调用）</li>
<li>RTTI 和反射的区别：对 RTTI 来说，编译器在编译时打开和检查 <code>.class</code> 文件（可以普通的调用对象的所有方法）；对于反射机制来说，<code>.class</code> 文件在编译时是不可获取的，所以是在运行时打开和检查 <code>.class</code> 文件</li>
<li>有时引入空对象的思想将会很有用，他可以接收传递给他的所代表的对象的消息，但是将返回表示为实际上并不存在任何 “真实对象” 的值。空对象最有用之处在于他更靠近数据，因为对象表示的是问题空间内的实体</li>
<li>在任何时刻，只要你想要将额外的操作从 “实际” 对象中分离到不同的地方，特别是当你希望能够很容易地做出修改，从没有使用额外操作转为这些操作，或者反过来时，代理就显得很有用（设计模式的关键就是封装修改————因此你需要修改事物以证明这种模式的正确性）</li>
<li>动态代理可以将所有调用重定向到调用处理器，因此通常会调用处理器的构造器传递一个 “实际“ 对象的引用，从而使得调用处理器在执行其中介任务时，可以将请求转发</li>
<li>空对象可以接受传递给他的所代表的对象的消息，但是将返回表示为实际上并不存在任何 ”真实“ 对象的值。用这种方式的好处是可以假定所有的对象都是有效的，从而不需要去检查 <code>null</code> 。空对象可以看作是策略模式的一种特例，空对象的一种变体称为空迭代器模式，他使得在组合层次结构中遍历各个节点中的操作对客户端透明（客户端可以使用相同的逻辑来遍历组合和叶子节点）</li>
<li>空对象的逻辑变体是模拟对象和桩。模拟对象和桩都只是假扮可以传递实际信息的存活对象，而不是像空对象一样可以称为 <code>null</code> 的替代物</li>
<li>模拟对象和桩之间的差异在于程度不同。模拟对象往往是轻量级和自测试的，通常很多模拟对象被创建出来是为了处理各种不同的测试情况，桩只是返回桩数据，他通常是重量级的，并且经常在测试之间被复用，桩可以根据他们被调用的方式，通过配置进行修改，因此桩是一种复合对象，他要做很多事情，而对于模拟对象来说，如果需要做很多事情，通常会创建大量小而简单的模拟对象</li>
<li><code>interface</code> 关键字的一个重要目标是允许下隔离构件，从而降低耦合，但是通过 RTTI 是可以调用接口实现类中并不在接口中声明的方法的。解决这个问题的方法：① 直接将这个不在接口中声明的方法进行声明 ② 使用包访问权限，这样可以防止在包外部的客户端使用，但是使用反射仍然能够调用包访问权限的方法，甚至是 <code>private</code> 权限的方法，只需要在 Method 对象上调用 <code>setAccessible(true)</code> 就能使用所有方法</li>
<li>使用 <code>javap -private 类名</code> 会显示这个类的所有信息</li>
<li>即使是私有内部类和匿名内部类也依旧会被反射获取到信息，而 <code>final</code> 域实际上在遭遇修改时是安全的，运行时系统会在不抛出异常的情况下接受任何修改尝试，但实际上不会发生任何修改</li>
<li>多态与 RTTI：RTTI 允许通过匿名基类的引用来发现类型信息，很有可能会导致多个 <code>switch</code> 语句的产生，而使用多态机制则仅调用一次既可以。面向对象编程语言的目的是让我们在凡是可以使用的地方都使用多态机制，只有在必需的地方使用 RTTI</li>
</ol>
<hr>
<h5 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h5><ol>
<li><p>Java 泛型的核心概念：告诉编译器想使用什么类型的对象，然后编译器来处理一切细节</p>
</li>
<li><p>元组：是将一组对象直接打包存储于其中的一个单一对象，这个容器对象允许读取其中元素，但是不允许向其添加新的对象（也就是数据传送对象或者信使）</p>
</li>
<li><p>泛型方法使得该方法能够独立于类而产生变化，所以无论何时，只要可以，就应该尽量使用泛型方法，也就是说，如果使用泛型方法可以取代将整个类泛型化，那么就应该只使用泛型方法。另外，对于一个 <code>static</code> 的方法而言，无法访问泛型类的类型参数，所以，若 <code>static</code> 方法需要使用泛型参数，就必需使其成为泛型方法</p>
</li>
<li><p>当使用泛型类时，必须在创建对象时就指定其类型参数的值，而使用泛型方法时，通常不必指明参数类型，因为编译器会自己找出具体类型，这称为类型参数推断</p>
</li>
<li><p>类型推断只对赋值操作有效，其他时候并不起作用，如果你将一个泛型方法调用的结果作为参数，传递给另一个方法，这时编译器并不会执行类型推断，在这种情况下，编译器认为：调用泛型方法后，其返回值被赋给一个 Object 类型的变量</p>
</li>
<li><p>在泛型方法中，可以显式地指明类型。显式地指明类型必须在点操作符与方法名之间插入尖括号（菱形操作符），然后把类型置于尖括号中。如果是在定义该方法的类的内部，必须在点操作符之前使用 <code>this</code> 关键字；如果是 <code>static</code> 方法，必须在点操作符之前加上类名，只有在编写非赋值语句才需要这样的额外说明</p>
</li>
<li><p>泛型的一个重要好处是能够简单而安全的创建复杂的模型</p>
</li>
<li><p>在泛型代码内部，无法获取任何有关泛型参数类型的信息</p>
</li>
<li><p>Java 泛型是使用擦除来实现的，这意味着当你在使用泛型时，任何具体的类型信息都被擦除了，唯一知道的是在使用一个对象。使用擦除来实现是因为要兼容以前未泛型化的类库，Java 为了这种兼容性而使用了擦除来实现泛型化，但这也导致了很多问题。（<a href="http://gafter.blogspot.com/">Neal Gafter</a>）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a cheat way to create generic array</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericArrayWithTypeToken</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericArrayWithTypeToken</span><span class="params">(Class&lt;T&gt; type, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用强制转换的以及反射的方式创建泛型数组</span></span><br><span class="line">        array = (T[]) Array.newInstance(type, size);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, T item)</span> </span>&#123;</span><br><span class="line">        array[index] = item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回整个数组</span></span><br><span class="line">    <span class="keyword">public</span> T[] rep() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>边界 <code>&lt;T extends Object&gt;</code> 声明 T 必须具有类型 Object 或者从 Object 导出的类型</p>
</li>
<li><p>泛型类型参数将擦除到他的第一个边界，编译器实际上会把参数类型替换为他的擦除</p>
</li>
<li><p>只有当你希望使用的类型参数比某个具体类型（以及他的所有子类型）更加 ”泛化“ 时，也就是说，当你希望代码能够跨多个类工作时，使用泛型才会有所帮助</p>
</li>
<li><p>擦除的核心动机是他使得泛化的客户端可以使用非泛化的类库，反之亦然，这经常被称为 ”迁移兼容性“</p>
</li>
<li><p>在泛型中所有动作都发生在边界处————对传递进来的值进行额外的编译期检查，并插入对传递出去的值的转型（checkcast）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成某个类的对象</span></span><br><span class="line"><span class="comment">// 这个类必须是 public 的并且有一个默认的构造器（无参构造器）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BasicGenerator</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> type.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;该类禁止外部初始化！&quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Generator&lt;T&gt; <span class="title">create</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BasicGenerator&lt;T&gt;(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于在泛型中创建数组，推荐使用 <code>Array.newInstance()</code> 方式；泛型方法返回值前的 <code>&lt;T&gt;</code> 代表返回值类型可以与参数中的类型不一致</p>
</li>
<li><p>若需要获取泛型的类型信息，则需要引入类型标签来获得（泛型类中加入一个 <code>Class&lt;T&gt; type</code> 的属性，然后在构造器中进行初始化）</p>
</li>
<li><p>创建一个 <code>new T()</code> 无法实现的一部分原因是因为擦除，另一部分原因是因为编译器无法验证 T 具有默认（无参）构造器。解决这个问题有两种方式，一种是使用显式的工厂，并将限制其类型，使得只能接受实现了这个工厂的类；另一种方法就是模板方法模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用显式工厂并限制其类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FactoryInterface</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T x;</span><br><span class="line">    <span class="keyword">public</span> &lt;F extends FactoryInterface&lt;T&gt;&gt; Foo(F factory) &#123;</span><br><span class="line">        x = factory.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以有其他工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerFactory</span> <span class="keyword">implements</span> <span class="title">FactoryInterface</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Foo&lt;Integer&gt;(<span class="keyword">new</span> IntegerFactory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 模板方法模式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericWithCreate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T element;</span><br><span class="line">    </span><br><span class="line">    GenericWithCreate() &#123;</span><br><span class="line">        element = create();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creator</span> <span class="keyword">extends</span> <span class="title">GenericWithCreate</span>&lt;<span class="title">Order</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Order <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Order();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(element.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Creator creator = <span class="keyword">new</span> Creator();</span><br><span class="line">        creator.testFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>PECS 原则</p>
<ul>
<li>如果要从集合中读取类型 T 的数据，并且不能写入，可以使用 <code>? extends</code> （Producer Extends）</li>
<li>如果要向集合中写入类型 T 的数据，并且不需要读取，可以使用 <code>? super</code> （Consumer Super）</li>
<li>如果既要存又要取，那么就不要使用任何通配符</li>
<li><code>extends</code> 确定的是上界，所以可读；（比如 Fruit 有两个子类：Apple 和 Orange，那么为了防止一个 Apple 容器中插入 Orange 元素，所以拒绝写入）</li>
<li><code>super</code> 确定的是下界，所以可写；</li>
</ul>
</li>
<li><p>捕获转换</p>
<ul>
<li>向一个使用 <code>&lt;?&gt;</code> 的方法传递原生类型，对编译器来说，可能会推断出实际的参数类型，使得这个方法可以回转并调用另一个使用这个确切类型的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function2 中将实际的类型参数传递给 function1 来使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CaptureConversion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">function1</span><span class="params">(Holder&lt;T&gt; holder)</span> </span>&#123;</span><br><span class="line">        T t = holder.get();</span><br><span class="line">        System.out.println(t.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function2</span><span class="params">(Holder&lt;?&gt; holder)</span> </span>&#123;</span><br><span class="line">        function1(holder);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Holder raw = <span class="keyword">new</span> Holder&lt;Integer&gt;(<span class="number">1</span>);  </span><br><span class="line">        function2(raw);</span><br><span class="line">        </span><br><span class="line">        Holder rawBasic = <span class="keyword">new</span> Holder();</span><br><span class="line">        function2(rawBasic);</span><br><span class="line">        </span><br><span class="line">        Holder&lt;?&gt; wildcarded = <span class="keyword">new</span> Holder&lt;Double&gt;(<span class="number">1.0</span>);</span><br><span class="line">        function2(wildcarded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Holder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">        value = val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">        value = val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.equals(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title>みんなの日本語（一）</title>
    <url>/%E6%97%A5%E8%AF%AD/%E3%81%BF%E3%82%93%E3%81%AA%E3%81%AE%E6%97%A5%E6%9C%AC%E8%AA%9E%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<center><strong><span style="font-size: 22px;">文法记录与总结</span></strong></center>

<h4 id="第一课"><a href="#第一课" class="headerlink" title="第一课"></a>第一课</h4><a id="more"></a>

<ol>
<li><p><strong>名词1 <span style="color: red;">は</span> 名词2 <span style="color: red;">です</span></strong></p>
<ul>
<li><p>助词「は」</p>
<p>  助词「は」表示其前面的名词（名词1）是句子的主题。说话人用「は」来提示想说的主题。在「は」后面加入各种各样的叙述构成句子。</p>
<p>  例如：「私はマイク・ミラーです。」我是迈克・米勒。</p>
<p>  <strong><em>注意：助词「は」读作「わ」。</em></strong></p>
</li>
<li><p>「です」</p>
<p>  名词加上「です」构成谓语。「です」在表示判断、断定的意思的同时，也表示说话人对听话人礼貌的态度。「です」在否定句与过去式中要发生变化。</p>
</li>
</ul>
</li>
<li><p><strong>名词1 <span style="color: red;">は</span> 名词2 <span style="color: red;">じゃ（では）ありません</span></strong></p>
<p> 「じゃ（では）ありません」是「です」的否定形。在<strong>日常会话</strong>中使用<strong>「じゃ」</strong>，在正式场合以及书面语中使用「では」。</p>
<p> <strong><em>注意：「では」中的「は」读作「わ」。</em></strong></p>
</li>
<li><p><strong>名词1 <span style="color: red;">は</span> 名词2 <span style="color: red;">ですか</span></strong></p>
<ul>
<li><p>助词「か」</p>
<p>  <strong>助词「か」</strong>表示说话人<strong>不肯定或者疑问</strong>的语气，「か」放在句尾构成疑问句。疑问句句尾语调一般为升调。</p>
</li>
<li><p>询问陈述的内容是否正确的疑问句</p>
<p>  <strong>句子的语序不变，在句尾加上助词「か」构成疑问句</strong>，这是询问陈述的内容是否正确的疑问句。肯定回答需要先说「はい」，否定回答需要先回答「いいえ」。</p>
</li>
<li><p>带有疑问词的疑问句</p>
<p>  句子的语序不变，把<strong>想要询问的内容替换为疑问词</strong>，句尾加「か」。</p>
</li>
</ul>
</li>
<li><p><strong>名词<span style="color: red;">も</span></strong></p>
<p> 助词「も」用于将相同的事物作为前提加以陈述时。</p>
<p> 例如：</p>
<p> 「ミラーさんは会社員です。グプタさんも会社員です。」米勒是公司职员，古普也是公司职员。</p>
</li>
<li><p><strong>名词1 <span style="color: red;">の</span> 名词2</strong></p>
<p> 当前面的名词1 修饰后面的名词2 时，用「の」来连接两个名词。在本课的范围内，<strong>名词1 表示名词2 的属性</strong>。</p>
</li>
<li><p><strong><span style="color: red;">〜さん</span></strong></p>
<p> 在日语中，听话人和第三者的姓名后要加「さん」。因为「さん」是用来表达敬意的，所以不能加在说话人自己的姓名之后。称呼小孩子一般使用「ちゃん」来代替「さん」，用来表示亲昵的态度。如果知道听话人的姓名的话，一般是在他的姓氏之后加上「さん」，而不用「あなた」。</p>
<p> <strong><em>注意：「あなた」用于称呼与自己有着非常亲密的关系的人（如夫妻、恋人等），如果在除此之外的场合使用，会给对方不太礼貌的印象。</em></strong></p>
</li>
<li><p><strong>{ あの人は誰ですか。 / あの方はどなたですか。}（询问那个人是谁的问法。后者为礼貌用法。）</strong></p>
</li>
<li><p><strong>{ ～は何歳ですか。 / 〜はおいくつですか。 }（询问某人年龄的问法。后者为礼貌用法。）</strong></p>
</li>
</ol>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>本课主要学习了肯定句、否定句、一般疑问句以及特殊疑问句的句式。</p>
<hr>
<h4 id="第二课"><a href="#第二课" class="headerlink" title="第二课"></a>第二课</h4><ol>
<li><p><strong><span style="color: red;">これ / それ / あれ</span></strong></p>
<p> 「これ」「それ」「あれ」作为名词使用，指代物体。</p>
<p> 「これ」指<strong>离说话人近</strong>的物体。</p>
<p> 「それ」指<strong>离听话人近</strong>的物体。</p>
<p> 「あれ」指<strong>离说话人和听话人都比较远</strong>的物体。</p>
</li>
<li><p><strong><span style="color: red;">この / その / あの</span> + 名词</strong></p>
<p> <strong>修饰名词时</strong>使用「この」「その」「あの」。距离与「これ」「それ」「あれ」一致。</p>
</li>
<li><p><strong><span style="color: red;">そうです</span></strong></p>
<p> 名词句中，在回答<strong>询问是否的疑问句</strong>时，<strong>肯定回答常常使用「そう」</strong>，可以回答说「はい、そうです」。否定回答时一般不用「そう」，而多用<strong>「ちがいます」（不是）</strong>，或者直接告知正确的答案。</p>
</li>
<li><p><strong><span style="color: red;">〜か、〜か</span></strong></p>
<p> 这是对两个及两个以上的并列疑问句进行选择回答的<strong>选择疑问句</strong>。回答时不用加「はい」或「いいえ」，直接重复自己选好的句子即可。</p>
<p> 例如：</p>
<p> 「これは「９」ですか、「７」ですか。」这是 “9”，还是 “7”？</p>
<p> ······「「９」です。」是 “9”。</p>
</li>
<li><p><strong>名词1 + <span style="color: red;">の</span> + 名词2</strong></p>
<p> 除第一课中的用法以外，还有如下用法：</p>
<ul>
<li><p>名词1 用来说明名词2 <strong>与什么事物有关系</strong></p>
<p>  例如：</p>
<p>  「これはコンピューターの本です。」这是计算机的书。</p>
</li>
<li><p>名词1 表示名词2 的<strong>所属</strong></p>
<p>  例如：</p>
<p>  「これは私の本です。」这是我的书。</p>
</li>
</ul>
</li>
<li><p><strong>代替名词使用的 「の」</strong></p>
<p> 答语中，「の」代替了问句中出现的名词，如下例子所示，将「の」放在「佐藤さん」后面，相当于省略了「名词1 の 名词2」，即省略了「鞄」。这里的「の」<strong>可以用于替代物品，但不能用于替代人</strong>。</p>
<p> 例如：</p>
<p> 「あれは誰の鞄ですか。」那是谁的包？</p>
<p> ······「佐藤さんのです。」是佐藤的。</p>
</li>
<li><p><strong><span style="color: red;">お〜</span></strong></p>
<p> 「お」可以接续名词，<strong>表示郑重的语气</strong>，例如「おみやげ」。</p>
</li>
<li><p><strong><span style="color: red;">そうですか</span></strong></p>
<p> 在听到新的信息时，用这句话来<strong>表示知道了</strong>，句尾语调为降调。</p>
</li>
</ol>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>本课主要学习的是「これ・この」「それ・れの」「あれ・あの」等词的用法，以及两个及两个以上的并列疑问句的提问方式及回答方式。对第一课的 「名词1 の 名词2」的用法进行了扩展。</p>
<hr>
<h4 id="第三课"><a href="#第三课" class="headerlink" title="第三课"></a>第三课</h4><ol>
<li><p><strong><span style="color: red;">ここ / そこ / あそこ / こちら / そちら / あちら</span></strong></p>
<p> 「ここ」「そこ」「あそこ」表示<strong>场所</strong>。</p>
<p> 「ここ」指的是<strong>说话人所在的场所</strong>，「そこ」指的是<strong>听话人所在的场所</strong>，「あそこ」指的是<strong>离说话人和听话人都比较远的场所</strong>。</p>
<p> 「こちら」「そちら」「あちら」表示方向，但也可以代替「ここ」「そこ」「あそこ」来表示场所，可以表示更为郑重的语气。</p>
<p> <strong><em>注意：说话人把听话人视为与自己处在同一场所时，两者所在的场所用「ここ」表示，离两者所在场所稍远的场所用「そこ」表示，更远的场所用「あそこ」表示。</em></strong></p>
</li>
<li><p><strong>名词 + <span style="color: red;">は</span> + 场所 です</strong></p>
<p> 这个句型可以用来表示<strong>场所、物体、人</strong>等<strong>存在的地方</strong>。</p>
<p> 例如：</p>
<p> 「お手洗いはあそこです。」洗手间在那边。</p>
</li>
<li><p><strong><span style="color: red;">どこ / どちら</span></strong></p>
<p> 「どこ」是<strong>询问场所</strong>的疑问词，「どちら」是<strong>询问方向</strong>的疑问词。「どちら」也可用于询问场所，语气较「どこ」更为郑重。</p>
<p> 另外，在<strong>询问国家、公司、学校等所属场所和组织的名称</strong>时，使用疑问词<strong>「どこ」或「どちら」</strong>，而不用「なん」。「どちら」比「どこ」的语气更为郑重。</p>
</li>
<li><p><strong>名词1 + <span style="color: red;">の</span> + 名词2</strong></p>
<p> 当名词1 是<strong>国家名称</strong>，名词2 是<strong>产品名称</strong>，「名词1 + の」表示该产品是这个国家制造的。当名词1 是<strong>公司名称</strong>，名词2 是<strong>产品名称</strong>时，「名词1 + の」表示该产品是这个公司制造的。在疑问句中这两种情况都使用疑问词<strong>「どこ」</strong>。</p>
</li>
<li><p><strong><span style="color: red;">こ / そ / あ / ど</span>（指示代词）</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>こ</th>
<th>そ</th>
<th>あ</th>
<th>ど</th>
</tr>
</thead>
<tbody><tr>
<td>物</td>
<td>これ</td>
<td>それ</td>
<td>あれ</td>
<td>どれ</td>
</tr>
<tr>
<td>物、人</td>
<td>この + 名词</td>
<td>その + 名词</td>
<td>あの + 名词</td>
<td>どの + 名词</td>
</tr>
<tr>
<td>场所</td>
<td>ここ</td>
<td>そこ</td>
<td>あそこ</td>
<td>どこ</td>
</tr>
<tr>
<td>方向、场所（郑重）</td>
<td>こちら</td>
<td>そちら</td>
<td>あちら</td>
<td>どちら</td>
</tr>
</tbody></table>
</li>
<li><p><strong><span style="color: red;">お〜</span></strong></p>
<p> 接头词「お〜」放在与听话人或第三者有关的事物之前，<strong>表达说话人的敬意</strong>。</p>
<p> 例如：</p>
<p> 「お国はどちらですか。」您是从哪儿来的？</p>
</li>
</ol>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p>本课主要学习了 こ / そ / あ / ど 等指示代词的用法。</p>
<hr>
<h4 id="第四课"><a href="#第四课" class="headerlink" title="第四课"></a>第四课</h4><ol>
<li><p><strong><span style="color: red;">今 〜時〜分です</span></strong></p>
<p> 在数字后面加上量词「時」「分」表示时刻。</p>
<p> 「分」前面的数字是 <strong>2、5、7、9</strong> 时，「分」读作「ふん」；是 <strong>1、3、4、6、7、8、10</strong> 时读作「ぷん」。「ぷん」前面的 <strong>1、6、8、10</strong> 分别读作<strong>「いっ」「ろっ」「はっ」「じゅっ（じっ）」</strong>。</p>
<p> 询问时间时，在「じ」「ぷん」前面加上「なん」。</p>
<p> 例如：</p>
<p> 「今何時ですか。」现在几点？</p>
<p> ······「７時１０分です。」7点10分。</p>
</li>
<li><p><strong>动词 <span style="color: red;">ます</span> / 动词 <span style="color: red;">ません</span> / 动词 <span style="color: red;">ました</span> / 动词 <span style="color: red;">ませんでした</span></strong></p>
<ul>
<li><p>「动词 ます」是句子的谓语。「ます」<strong>表示说话人对听话人礼貌的态度</strong>。</p>
<p>  例如：「私は毎日勉強します。」我每天学习。</p>
</li>
<li><p>「动词 ます」用来<strong>叙述现在的习惯、真理或将来会发生的事情、行动</strong>。它的否定形和过去时的变化形式如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>非过去（现在、未来）</th>
<th>过去</th>
</tr>
</thead>
<tbody><tr>
<td>肯定</td>
<td>おきます</td>
<td>おきました</td>
</tr>
<tr>
<td>否定</td>
<td>おきません</td>
<td>おきませんでした</td>
</tr>
</tbody></table>
</li>
<li><p><strong>疑问句不改变语序，用疑问词替换要询问的内容，在句尾加「か」</strong>。<strong>回答时重复疑问句中的动词</strong>。「そうです」和「ちがいます」不能作为动词谓语疑问句的回答。</p>
</li>
</ul>
</li>
<li><p><strong>名词（时间） + <span style="color: red;">に</span> + 动词</strong></p>
<p> 在表示时间的名词后加上<strong>助词「に」</strong>，来<strong>表示动作进行的时间</strong>。</p>
<p> <strong><em>注意1：这里的助词「に」强调的是目的性。</em></strong></p>
<p> <strong><em>注意2：表示时间的名词后面不加「に」，如：「今日、明日、昨日、先月」等。「～曜日、朝、昼、晩、夜」等名词后可以加「に」也可以不加。</em></strong></p>
</li>
<li><p><strong>名词1 + <span style="color: red;">から</span> + 名词2 + <span style="color: red;">まで</span></strong></p>
<ul>
<li><p>「から」表示<strong>起点（时间、场所）</strong>，「まで」表示<strong>终点（时间、场所）</strong>。</p>
<p>  例如：「大阪から東京まで３時間かかります。」从大阪到东京要 3 个小时。</p>
</li>
<li><p>「から」和「まで」经常一起使用，但也<strong>可以分别单独使用</strong>。</p>
<p>  例如：「９時から働きます。」9 点开始工作。</p>
</li>
<li><p>在表示主题开始和结束的时间和日期时，可以在「〜から」「〜まで」「〜から〜まで」之后加「です」。</p>
<p>  例如：「昼休みは１２時からです。」午休从 12 点开始。</p>
</li>
</ul>
</li>
<li><p><strong>名词1 + <span style="color: red;">と</span> + 名词2</strong></p>
<p> 名词并列时，名词与名词之间用「と」连接。</p>
<p> 例如：「銀行の休みは土曜日と日曜日です。」银行周六和周日休息。</p>
</li>
<li><p><strong><span style="color: red;">〜ね</span></strong></p>
<p> 助词「ね」接在句尾，可以表示说话人希望得到听话人的同意或说话人对某一事物加以<strong>确认、叮嘱</strong>的语气。</p>
</li>
</ol>
<h5 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h5><p>本课学习了时间的说法以及时间的问法，也学了「动词 ます 形」的用法及时态。并且第一次接触到助词「に」的使用，以及「〜から〜まで」的使用。</p>
<hr>
<h4 id="第五课"><a href="#第五课" class="headerlink" title="第五课"></a>第五课</h4><ol>
<li><p><strong>名词（场所） + <span style="color: red;">へ</span> + { 行きます / 来ます / 帰ります  }</strong></p>
<p>  使用表示移动的动词时（即移动动词），移动的方向用<strong>助词「へ」</strong>来表示。<strong>这里的助词「へ」强调的是方向性。</strong></p>
<p> <strong><em>注意：助词「へ」读作「え」。</em></strong></p>
<p> 例如：「東京へ行きます。」去东京。</p>
</li>
<li><p><strong><span style="color: red;">どこ[へ]も</span> + { 行きません / 行きませんでした }</strong></p>
<p>  对疑问词所问范畴内的一切全部加以否定时，在疑问词后加<strong>助词「も」</strong>并且动词也使用其否定形。</p>
<p> 例如：「何も行きません。」哪儿也不去。</p>
</li>
<li><p><strong>名词（交通工具） + <span style="color: red;">で</span> + { 行きます / 来ます / 帰ります }</strong></p>
<p>  <strong>助词「で」表示方法、手段。</strong>接在表示交通工具的名词之后与移动动词一起使用时，<strong>表示用什么交通手段进行移动</strong>。</p>
<p> <strong><em>注意：步行直接用「歩いて」，并且不加助词「で」。</em></strong></p>
<p> 例如：</p>
<p> 「電車で帰ります。」坐电车回来的。</p>
<p> 「駅から歩いて帰りました。」从车站走回来的。</p>
</li>
<li><p><strong>名词（人 / 动物） + <span style="color: red;">と</span> + 动词</strong></p>
<p>  用<strong>助词「と」</strong>表示与自己一起行动的人或动物。</p>
<p> <strong><em>注意：一个人单独行动时，要用「一人で」，并且不加助词「と」。</em></strong></p>
<p> 例如：</p>
<p> 「友達と東京へ行きます。」和朋友一起去东京。</p>
<p> 「一人で大阪へ行きます。」一个人去大阪。</p>
</li>
<li><p><strong><span style="color: red;">いつ</span></strong></p>
<p>  询问时间时，除了使用「何時」「何曜日」「何月何日」这样的以「なん」构成的疑问词以外，还可以使用疑问词「いつ」。</p>
<p> <strong><em>注意：「いつ」之后不需要再加助词「に」。</em></strong></p>
<p> 例如：</p>
<p> 「いつ広島へ行きますか。」什么时候去广岛？</p>
<p> ······「来週行きます。」下周去。</p>
</li>
<li><p><strong><span style="color: red;">〜よ</span></strong></p>
<p>  <strong>助词「よ」</strong>接在句尾，<strong>用于将对方不知道的事情或者说话人自己的判断、意见等告诉对方</strong>。</p>
<p> 例如：「北海道に馬が沢山いますよ。」北海道有很多马呢。</p>
</li>
<li><p><strong><span style="color: red;">そうですね</span></strong></p>
<p> 「そうですね」用于表示对对方所说的事情赞同或者有同感。</p>
<p><strong><em>注意：「そうですね」是在表示说话人对自己原本也这样认为或者早就知道的事情表示赞同或者有同感时使用。而「そうですか」则是在表示说话人原本不知道，而现在知道了这一新信息之后对其表示认可、理解时使用。要注意将这两句话区别开。</em></strong></p>
</li>
</ol>
<h5 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h5><p>本课主要学习的是去某地这一用法。同时也学习了助词「へ」、助词「も」、助词「で」、助词「と」、助词「よ」等的用法。</p>
<hr>
<h4 id="第六课"><a href="#第六课" class="headerlink" title="第六课"></a>第六课</h4><ol>
<li><p><strong>名词 + <span style="color: red;">を</span> + 动词（他动词）</strong></p>
<p>  他动词的宾语用助词「を」表示。</p>
<p> <strong><em>注意：「を」只用于表示助词。</em></strong></p>
<p> 例如：「ジュースを飲みます。」喝果汁。</p>
</li>
<li><p><strong>名词 + <span style="color: red;">を</span> + <span style="color: red;">します</span></strong></p>
<p>  「します」可以接在很多名词之后，使其作为宾语，意思是<strong>做该名词所表示的内容</strong>。</p>
<ul>
<li><p>运动、游戏等</p>
<p>  「サッカーをします」踢足球</p>
</li>
<li><p>集会、活动等</p>
<p>  「パーティーをします」开派对</p>
</li>
<li><p>其他的</p>
<p>  「宿題をします」做作业</p>
<p>  「電話をします」打电话</p>
</li>
</ul>
</li>
<li><p><strong><span style="color: red;">何をしますか</span></strong></p>
<p>  这是询问要做什么的疑问句。</p>
<p> 例如：</p>
<p> 「昨日何をしましたか。」昨天干什么了？</p>
<p> ······「日本語を勉強しました。」学了日语。</p>
</li>
<li><p><strong><span style="color: red;">なん</span> 和 <span style="color: red;">なに</span></strong></p>
<p>  「なん」与「なに」的意思相同，但是需要根据情况来判断到底应该使用哪一个。</p>
<ul>
<li><p>使用「なん」的情况</p>
<p>  [1] 后续单词的词头为「た行」「だ行」「な行」时需要使用「なん」。</p>
<p>  [2] 带有量词时需要使用「なん」</p>
</li>
<li><p>除了使用「なん」的情况以外，其他时候都使用「なに」</p>
</li>
</ul>
<p> <strong><em>注意：「なんで」除了可以询问手段、方法等，还可以用于询问理由。当需要明确地表示是在询问手段、方法时，可以用「なにで」。</em></strong></p>
</li>
<li><p><strong>名词（场所） + <span style="color: red;">で</span> + 动词</strong></p>
<p>  <strong>助词「で」</strong>接在表示场所的名词后面，<strong>表示动作发生的场所</strong>。</p>
<p> 例如：「駅で新聞を買います。」在车站买报纸。</p>
</li>
<li><p><strong>动词 ませんか</strong></p>
<p>  <strong>表示邀请听话人一起来做某事</strong>。（有劝诱的意思。）</p>
<p> 例如：</p>
<p> 「一緒に大阪へ行きませんか。」一起去大阪好吗？</p>
<p> ······「ええ、いいですね。」嗯，好哦。</p>
</li>
<li><p><strong>动词 ましょう</strong></p>
<p>  表示积极地提议、邀请。也可以表示积极地响应对方的提议、邀请。</p>
<p> <strong><em>注意：「動詞 ませんか」的语气比「動詞 ましょう」更为尊重对方。</em></strong></p>
<p> 例如：「ちょっと休みましょう。」休息一下吧。</p>
</li>
<li><p><strong><span style="color: red;">〜か</span></strong></p>
<p>  「か」是说话人在得到自己所不知道的新信息时之后表示认可、理解时的表达方式。与「そうですか」中的「か」是相同的含义。</p>
<p> 例如：</p>
<p> 「土曜日大阪へ行きました。」周六去了大阪。</p>
<p> ······「大阪ですか。いいですね。」大阪吗，挺好的呀。</p>
</li>
</ol>
<h5 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h5><p>本课主要学习的为「どこで何をします」也就是在哪儿干了什么事的用法。助词「で」可以表示动作发生的场所。</p>
<hr>
<h4 id="第七课"><a href="#第七课" class="headerlink" title="第七课"></a>第七课</h4><ol>
<li><p><strong>名词（工具 / 手段） + <span style="color: red;">で</span> + 动词</strong></p>
<p>  <strong>助词「で」</strong>表示手段、方法。</p>
<p> 例如：</p>
<p> 「箸で食べます。」用筷子吃饭。</p>
<p> 「日本語でレポートを書きます。」用日语写报告。</p>
</li>
<li><p><strong>词 / 句 + <span style="color: red;">は</span> + <span style="color: red;">～語で</span> + <span style="color: red;">なんですか</span></strong></p>
<p>  需要询问某个词或者某个句子用某种语言怎么说时使用这个句型来进行提问。</p>
<p> 例如：</p>
<p> 「Thank you」は日本語で何ですか。”Thank you“ 用日语怎么说？</p>
<p> ······「ありがとう」です。是「ありがとう」。</p>
</li>
<li><p><strong>名词1（人） + <span style="color: red;">に</span> + 名词2 + <span style="color: red;">を</span> + あげます 等</strong></p>
<p>  「あげます」「貸します」「教えます」等动词是<strong>提供事物、信息</strong>的意思，需要有接受这些事物、信息的对象。<strong>这个接受对象用助词「に」来表示。</strong></p>
<p> 例如：「山田さんに英語を教えます。」我教山田英语。</p>
</li>
<li><p><strong>名词1（人） + <span style="color: red;">に</span> + 名词2 + <span style="color: red;">を</span> + もらいます 等</strong></p>
<p>  「もらいます」「借ります」「習います」等动词是<strong>得到事物、信息</strong>的意思，需要有提供这些事物、信息的对象。<strong>这个提供对象用助词「に」来表示。</strong></p>
<p> <strong><em>注意：在这个句型中也可以使用「から」来代替「に」。尤其是当提供对象并不是个人，而是公司、学校等组织时，不要用「に」而要用「から」。</em></strong></p>
<p> 例如：</p>
<p> 「ワンさんに中国語を習います。」我跟小王学汉语。</p>
<p> 「銀行からお金を借りました。」我从银行贷了款。</p>
</li>
<li><p><strong><span style="color: red;">もう</span> + 动词 ました</strong></p>
<p>  「もう」是 “已经” 的意思，与「動詞 ました」一起使用，表示<strong>此时的行为已经结束了</strong>。</p>
<p> <strong>询问某个行为是否已经结束了的时候</strong>，使用<strong>「もう 動詞ましたか」</strong>这个句型。</p>
<p> 在回答时，如果行为已经结束了（即肯定回答），那么使用「はい、もう 動詞ました」。</p>
<p> 若还未结束（即否定回答），则使用「いいえ、まだ 動詞て いません」或者「いいえ、まだです」。</p>
<p> <strong><em>注意：在回答询问行为是否结束的问句时，否定回答不要使用「いいえ、動詞ませんでした」。因为「動詞ませんでした」是过去没有做过某件事的意思，不能作为这个问句的回答。</em></strong></p>
<p> 例如：</p>
<p> 「もう荷物を送りましたか。」行李已经寄走了吗？</p>
<p> ······「はい、[もう]送りました。」是的，已经寄走了。</p>
<p> ······「いいえ、まだ送っていません。」没有，还没寄。</p>
<p> ······「いいえ、まだです。」没有，还没有。</p>
</li>
<li><p><strong>助词的省略</strong></p>
<p>在会话中，当从前后关系就可以明白语意时，经常会省略助词。</p>
<p>例如：「このスポーン[は]、素敵ですね。」这把勺子真漂亮啊！ </p>
</li>
</ol>
<h5 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h5><p>本课学习了助词「で」的用法以及使用授受动词（即「あげます」「もらいます」等）的句型的使用方法。</p>
<hr>
<h4 id="第八课"><a href="#第八课" class="headerlink" title="第八课"></a>第八课</h4><ol>
<li><p><strong>形容词</strong></p>
<p> 形容词可以做句子的谓语，在「名词 は 形容词 です」这样的句子中<strong>表示名词的状态或者用来修饰名词</strong>。形容词分为「な形」与「い形」两种。</p>
</li>
<li><p><strong>名词 + は + { な 形容词 / い 形容词 } + です</strong></p>
<p> 非过去肯定的形容词句以「です」结尾。「です」表示对听话人礼貌的态度。在接续「です」的时候，「な形容词」不加「な」，「い形容词」直接使用即可。</p>
<p> <strong><em>注：本课并未涉及到过去时</em></strong></p>
<table>
<thead>
<tr>
<th></th>
<th>な形容词</th>
<th>い形容词</th>
</tr>
</thead>
<tbody><tr>
<td>肯定</td>
<td>親切<span style="color: red;">です</span></td>
<td>高い<span style="color: red;">です</span></td>
</tr>
<tr>
<td>否定</td>
<td>親切<span style="color: red;">じゃ（では）ありません</span></td>
<td>高<span style="color: red;">くないです</span></td>
</tr>
</tbody></table>
<ul>
<li><p>な形容词</p>
<p>  <strong>非过去否定形去「な」加「じゃ（では）ありません」。</strong></p>
<p>  「な形容词」的结构说明：</p>
<p>  比如「しずか [だ]」，其中<span style="color: red;">「しずか」</span>为这个词的<span style="color: red;">词干</span>，<span style="color: red;">隐含的「だ」</span>才是这个词的<span style="color: red;">词尾</span>。</p>
</li>
<li><p>い形容词</p>
<p>  <strong>非过去否定形去「い」加「くないです」。或者加「くありません」</strong></p>
<p>  <strong><em>注意：「いいです」的否定形是「よくないです」。</em></strong></p>
<p>  「い形容词」的结构说明：</p>
<p>  比如「しろい」，其中<span style="color: red;">「しろ」</span>为这个词的<span style="color: red;">词干</span>，<span style="color: red;">「い」</span>为这个词的<span style="color: red;">词尾</span>。</p>
<p>形容词句的疑问句与名词句、动词句的形式一样，回答时要用形容词来回答。</p>
<p>例如：</p>
<p>「北京は寒いですか。」北京冷吗？</p>
<p>······「はい、寒いです。」是的，很冷。</p>
</li>
</ul>
<p> <strong><em>注意：形容词句的回答不能使用「そうです」或「ちがいます」来回答。</em></strong></p>
</li>
<li><p><strong>{ な 形容词 + な + 名词 } / { い 形容词 + 名词 }</strong></p>
<p> 形容词修饰名词时，放在名词前。注意「な形容词」修饰名词时需要加「な」。</p>
<p> 例如：「富士山は高い山です。」富士山是一座高山。</p>
</li>
<li><p><strong><span style="color: red;">～が、〜</span></strong></p>
<p> <strong>「が」表示转折</strong>。在同一主语的形容词句中，说话人前半句的评价应与后半句的评价相反。</p>
<p> 例如：「日本の食べ物はおいしいですが、高いです。」日本的食物很好吃，但是价格很贵。</p>
</li>
<li><p><strong><span style="color: red;">どても / あまり</span></strong></p>
<p> 「とても」和「あまり」都是<strong>表示程度的副词</strong>，在修饰形容词时放在形容词前。「とても」用在肯定句中表示 “很” 的意思；「あまり」用于否定句则表示 “不太······” 的意思。</p>
<p> 例如：</p>
<p> 「これはとても有名な映画です。」这是一部很有名的电影。</p>
<p> 「あの店はあまり高いです。」那家店价格不太高。</p>
</li>
<li><p><strong>名词 + <span style="color: red;">は</span> + <span style="color: red;">どうですか</span></strong></p>
<p> <strong>向对方询问其所经历过的事情、访问过的场所、见过的人的印象、意见和感想时</strong>，使用这个句型。</p>
<p> 例如：</p>
<p> 「日本の生活はどうですか。」（在）日本的生活怎么样？</p>
<p> ······「忙しいです。」很忙。</p>
</li>
<li><p><strong>名词1 + <span style="color: red;">は</span> + <span style="color: red;">どんな</span> + 名词2 + <span style="color: red;">ですか</span></strong></p>
<p> 「どんな」是<strong>询问人或物的状态和性质的疑问词</strong>，修饰名词。</p>
<p> 例如：</p>
<p> 「あの店はどんな店ですか。」那家店是家什么样的店？</p>
<p> ······「日本料理の店です。」是家日本料理店。</p>
</li>
<li><p><strong><span style="color: red;">そうですね</span></strong></p>
<p> 本课中的「そうですね」是表示说话人正在思考对方的问题。</p>
<p> <strong><em>注意：需要与之前的表示同意或有同感的用法区别开。</em></strong></p>
</li>
</ol>
<h5 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h5><p>本课主要学习的是形容词非过去肯定与否定的形式变化。</p>
<hr>
<h4 id="第九课"><a href="#第九课" class="headerlink" title="第九课"></a>第九课</h4><ol>
<li><p><strong>{ 名词 + <span style="color: red;">が</span> + { <span style="color: red;">あります</span> / <span style="color: red;">わかります</span> } } / { 名词 + <span style="color: red;">が</span> + { 好きです / 嫌いです / 上手です / 下手です } }</strong></p>
<p> 形容词和一部分动词的宾语用助词「が」来表示。</p>
<p> 例如：</p>
<p> 「私は日本語少し分かります。」我懂一点儿日语。</p>
<p> 「私は日本料理が好きです。」我喜欢日本菜。</p>
</li>
<li><p><strong><span style="color: red;">どんな</span> + 名词</strong></p>
<p> 回答带有「どんな」疑问词的疑问句时，可以举出具体名称来回答。</p>
<p> 例如：</p>
<p> 「どんな料理が好きですか。」你喜欢什么菜？</p>
<p> ······「日本料理が好きです。」喜欢日本菜。</p>
</li>
<li><p><strong>よく / だいたい / たくさん / 少し / あまり / 全然</strong></p>
<p> <strong>这些副词在修饰动词时需要放在动词前。</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>表示程度的副词</th>
<th>表示数量的副词</th>
</tr>
</thead>
<tbody><tr>
<td>和肯定形一起使用</td>
<td><span style="color: red;">よく</span>　分かります<br /><span style="color: red;">だいたい</span>　分かります<br /><span style="color: red;">少し</span>　分かります</td>
<td><span style="color: red;">たくさん</span>　あります<br /><span style="color: red;">少し</span>　あります</td>
</tr>
<tr>
<td>和否定形一起使用</td>
<td><span style="color: red;">あまり</span>　分かりません<br /><span style="color: red;">全然</span>　分かりません</td>
<td><span style="color: red;">あまり</span>　ありません<br /><span style="color: red;">全然</span>　ありません</td>
</tr>
</tbody></table>
<p> 例如：「英語がよく分かります。」精通英语。</p>
<p> <strong><em>注意：「少し」「全然」「あまり」也可以修饰形容词。</em></strong></p>
<p> 例如：「あの映画は全然面白くないです。」那部电影一点儿意思也没有。</p>
</li>
<li><p><strong><span style="color: red;">～から、〜</span></strong></p>
<p> <strong>「から」之前的前半句是后半句的原因（即前因 后果）。</strong>也可以将「～から」放在句尾来说明理由。</p>
<p> 例如：</p>
<p> 「時間がありませんから、新聞を読みません。」因为没有时间，所以不看报纸。</p>
<p> 「毎朝新聞を読みますか。」每天早上看报纸吗？</p>
<p> ······「いいえ、読みません。時間がありませんから。」不，不看。因为没有时间。</p>
</li>
<li><p><strong><span style="color: red;">どうして</span></strong></p>
<p> 「どうして」是询问原因的疑问词。在答语的句尾接「から」来表示理由。</p>
<p> 例如：</p>
<p> 「どうして仕事をしませんか。」为什么不工作。</p>
<p> ······「休みですから。」因为休息。</p>
<p> <strong><em>注意：在询问对方所说事情的原因时，也可以使用「どうしてですか」来代替对方所说的内容。</em></strong></p>
</li>
</ol>
<h5 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h5><p>本课主要学习的是「〜名詞 が〜」的句型，并且了解了几个表示程度与数量的副词的使用方法。</p>
<hr>
<h4 id="第十课"><a href="#第十课" class="headerlink" title="第十课"></a>第十课</h4><ol>
<li><p><strong>名词 + <span style="color: red;">が</span> + { あります / います }（表示某物 / 某人存在于某个不明确的地方）</strong></p>
<p> <strong>「あります」「います」表示某物和某人的存在。</strong>这个句型<strong>将物与人的存在直接告诉对方</strong>，而作为存在主体（即物 / 人）的名词用<strong>助词「が」</strong>表示。</p>
<ul>
<li><p>あります</p>
<p>  用于表示如<strong>事物、植物等不会自己移动</strong>的主体。</p>
<p>  例如：「桜があります。」有樱花树。</p>
</li>
<li><p>います</p>
<p>  用于表示如<strong>人、动物这样可以自己移动</strong>的主体。</p>
<p>  例如：「人がいます。」有一个人。</p>
</li>
</ul>
</li>
<li><p><strong>场所 + <span style="color: red;">に</span> + 名词 + <span style="color: red;">が</span> + { あります / います }（明确地表示在某处有某物 / 某人）</strong></p>
<p> 这个句型用于表示在某一场所有某物或某人存在。物与人存在的场所用<strong>助词「に」</strong>来表示。</p>
<p> <strong>询问存在的物体时用疑问词「なに」；询问存在的人时用疑问词「だれ」。</strong></p>
<p> <strong><em>注意：要注意疑问词后接的助词为「が」。</em></strong></p>
<p> 例如：</p>
<p> 「地下に何がありますか。」</p>
<p> ······「レストランがあります。」</p>
</li>
<li><p><strong>名词 + <span style="color: red;">は</span> + 场所 + <span style="color: red;">に</span> + { あります / います }</strong></p>
<p> 这个句型是<strong>将在某处存在的东西作为主题来陈述其所在场所</strong>的句型。名词放在句首，用<strong>助词「は」</strong>来提示。</p>
<p> <strong><em>注意：这个名词（即存在的东西）必须是说话人和说话人双方都知道的东西。</em></strong></p>
<p> 例如：「東京ディズニーランドは千葉県にあります。」东京迪士尼乐园在千叶县。</p>
<p> <strong><em>注意：这个句型可以使用「名词 + は + 场所 です」来替换。要注意这时「です」之前表示场所的疑问词（どこ），以及名词（千葉県）的后面不加助词「に」。</em></strong></p>
<p> 例如：</p>
<p> 「東京ディズニーランドはどこですか。」东京迪士尼乐园在哪？</p>
<p> ······「千葉県です。」在千叶县。</p>
</li>
<li><p><strong>名词1（物 / 人 / 场所）+ <span style="color: red;">の</span> + 名词2（位置）</strong></p>
<p> <strong>「上」「下」「前」「後ろ」等词可以表示方向和位置</strong>。</p>
<p> 例如：「机の上に写真があります。」桌子上有照片。</p>
<p> <strong><em>注意：这些表示方向和位置的名词与表示场所的名词一样，可以加助词「で」来表示动作发生的场所。</em></strong></p>
<p> 例如：「駅の近くで友達に会いました。」在车站附近遇到了朋友。</p>
</li>
<li><p><strong>名词1 + <span style="color: red;">や</span> + 名词2</strong><br> 之前学过的助词「と」用于列举全部名词，而助词「や」则是用于<strong>选择几个（两个及以上）名词进行列举</strong>。若在列举出的最后一个名词之后<strong>加上「など」</strong>，则表示除了列出来的名词以外还有其他的名词。</p>
<p> 例如：「箱の中に手紙や写真などがあります。」盒子里有信和照片什么的。</p>
</li>
<li><p><strong>アジアストアですか</strong><br> 在实际会话中，像这样不是立即回答，而是在确认了对方问题的重点之后再进行回答的情况比较多。</p>
</li>
</ol>
<h5 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h5><p>本课的重点是如何表述在某处存在某物 / 某人，即「場所に名詞があります / います」这个句型的用法。</p>
<hr>
<h4 id="第十一课"><a href="#第十一课" class="headerlink" title="第十一课"></a>第十一课</h4><ol>
<li><p><strong>数量的说法</strong></p>
<ul>
<li><p>1～10 的数法（ひとつ、ふたつ、みっつ、よっつ、いつつ、むっつ、ななつ、やっつ、ここのつ、とお）</p>
<p>  数物品时使用，11 以上时直接使用数数字的数法来数。</p>
</li>
<li><p>各种量词</p>
<p>  在数人和物的数量时，数的对象不同，所用的量词也不同。量词接在数字后面使用。</p>
<ul>
<li>～人　人数（一人、二人、四人：ひとり、ふたり、よにん）</li>
<li>〜台　机械、交通工具</li>
<li>〜枚　扁平且薄的东西（纸、衬衫、盘子、CD）</li>
<li>〜回　次数</li>
<li>〜分　分钟</li>
<li>〜時間　小时</li>
<li>〜日　天数（与表示日期的说法一致，但「１日」读作「いちにち」）</li>
<li>〜週間　星期</li>
<li>〜か月　（个）月</li>
<li>〜年　年</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>数量词的用法</strong></p>
<ul>
<li><p>数量词（数词加量词）原则上放在 <strong>“名词 + 助词” 后面</strong>，但是，<strong>表示时间长短的数量词则不受此限制。</strong></p>
<p>  例如：</p>
<p>  「林檎を４つ買いました。」买了4个苹果。</p>
<p>  「国で２か月日本語を勉強しました。」在国内学了两个月的日语。</p>
</li>
<li><p>询问数量的方法</p>
<ul>
<li><p><span style="color: red;">いくつ</span></p>
<p>  用于询问物品（ひとつ、ふたつ）的数量。</p>
</li>
<li><p><span style="color: red;">なん + 量词</span></p>
<p>  除了物品以外其他的东西基本都是使用 「なん + 量词」来询问。</p>
</li>
<li><p><span style="color: red;">どのくらい</span></p>
<p>  询问<strong>时间长短</strong>时使用 「どのくない」。</p>
<p>  例如：</p>
<p>  「大阪から東京までどのくらいかかりますか。」从大阪到东京要多长时间？</p>
<p>  ······「新幹線で２時間半かかります。」坐新干线需要两个半小时。</p>
</li>
</ul>
</li>
<li><p><strong>〜ぐらい</strong></p>
</li>
</ul>
</li>
<li><p><strong>数量词（期间） + <span style="color: red;">に</span> + <span style="color: red;">〜回</span> + 动词</strong></p>
<p> 这是表示频度的用法。</p>
<p> 例如：「１か月に２回映画を見ます。」一个月看两次电影。</p>
</li>
<li><p><strong>数量词 / 名词 + <span style="color: red;">だけ</span></strong></p>
<p> 「だけ」接在数量词或者名词之后，意思是只有这些，不会再有超过于此的了。</p>
<p> 例如：「休みは日曜日だけです。」休息日只有周日。</p>
</li>
</ol>
<h5 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h5><p>本课主要学习的是数量词的使用方法。</p>
<hr>
<h4 id="第十二课"><a href="#第十二课" class="headerlink" title="第十二课"></a>第十二课</h4><ol>
<li><p><strong>名词句、な形容词句的时态：肯定与否定</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>非过去（现在·未来）</th>
<th>过去</th>
</tr>
</thead>
<tbody><tr>
<td>肯定</td>
<td>名词  あめ<span style="color: red;">です</span><br />な形容词  しずか<span style="color: red;">です</span></td>
<td>名词  あめ<span style="color: red;">でした</span><br />な形容词  しずか<span style="color: red;">でした</span></td>
</tr>
<tr>
<td>否定</td>
<td>名词  あめ<span style="color: red;">じゃ（では）ありません</span><br />な形容词  しずか<span style="color: red;">じゃ（では）ありません</span></td>
<td>名词  あめ<span style="color: red;">じゃ（では）ありませんでした</span><br />な形容词  しずか<span style="color: red;">じゃ（では）ありませんでした</span></td>
</tr>
</tbody></table>
</li>
<li><p><strong>い形容词句的时态：肯定与否定</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>非过去（现在·未来）</th>
<th>过去</th>
</tr>
</thead>
<tbody><tr>
<td>肯定</td>
<td>あつ<span style="color: red;">い</span>です</td>
<td>あつ<span style="color: red;">かった</span>です</td>
</tr>
<tr>
<td>否定</td>
<td>あつ<span style="color: red;">くない</span>です</td>
<td>あつ<span style="color: red;">くなかった</span>です</td>
</tr>
</tbody></table>
</li>
<li><p><strong>名词1 + <span style="color: red;">は</span> + 名词2 + <span style="color: red;">より</span> + 形容词 です</strong></p>
<p> 以名词2 为标准来表示名词1 的性质和状态。</p>
<p> 例如：「この車はあの車より大きいです。」这辆车比那辆车大。</p>
</li>
<li><p><strong>问：名词1 + <span style="color: red;">と</span> + 名词2 + <span style="color: red;">と</span> + <span style="color: red;">どちらが </span>+ 形容词 ですか</strong></p>
<p> <strong>答：名词1 / 名词2 + <span style="color: red;">のほうが</span> + 形容词 です</strong></p>
<p> 将两者加以比较时，无论比较的东西是什么，疑问词都用「どちら」。</p>
<p> 例如：</p>
<p> 「サッカーと野球とどちらが面白いですか。」足球和棒球哪个有意思？</p>
<p> ······「サッカーのほうが面白いです。」足球有意思。</p>
</li>
<li><p><strong>问：名词1 [の中] <span style="color: red;">で</span> + { <span style="color: red;">なに / どこ / だれ / いつ</span> } + <span style="color: red;">がいちばん</span> + 形容词ですか</strong></p>
<p> <strong>答：名词2 + <span style="color: red;">がいちばん</span> + 形容词です</strong></p>
<p> 助词「で」表示范围，本句型是要在名词1 的范围中选择形容词所表示的<strong>状态</strong>、<strong>性质</strong>程度最高的<strong>事物</strong>、<strong>地点</strong>、<strong>人物</strong>或<strong>时间</strong>等。注意需要选择相对应的疑问词。</p>
<p> 例如：</p>
<p> 「ヨーロッパでどこが一番よかったですか。」欧洲哪里最好？</p>
<p> ······「スイスが一番よかったです。」瑞士最好。</p>
<p> <strong><em>注意：用来询问形容词句主语的带有疑问词的疑问句，其疑问词后也使用「が」！</em></strong></p>
</li>
<li><p><strong>形容词 の（代替名词使用的 「の」）</strong></p>
<p> 「形容词 の 名词」可以省略为 「形容词の」，「の」来代替前句中已经出现过的名词。</p>
</li>
</ol>
<h5 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h5><p>本课主要学习的是形容词的时态以及「より」等句型的使用方法。</p>
<hr>
<h4 id="第十三课"><a href="#第十三课" class="headerlink" title="第十三课"></a>第十三课</h4><ol>
<li><p><strong>名词 + <span style="color: red;">が</span> + <span style="color: red">欲しいです</span></strong></p>
<p> 表示有想要某物的欲望。「欲しい」是「イ形容词」。「欲しい」的对象用助词「が」表示。</p>
<p> <strong><em>注：这里的名词是指除动作以外的名词。</em></strong></p>
</li>
<li><p><strong>动词「ます形」+ <span style="color: red;">たい</span>です</strong></p>
<p> 这个形式一般用于<strong>表示有想做某种行为的欲望</strong>。「〜たい」的宾语有时用助词「を」表示，也有时用助词「が」表示，「〜たい」的活用方法与「イ形容词」一致。</p>
<p> 例如：「私は天ぷらを（が）食べたいです。」我想吃天妇罗。</p>
<p> <strong>注意：</strong></p>
<p> <strong>[1] 「欲しいです」「〜たいです」不能用于说话人及听话人以外的第三者的欲望！</strong></p>
<p> <strong>[2] 「欲しいですか」「〜たいですか」不能用于劝诱听话人做某事。例如在劝对方喝咖啡时，应当用「コーヒーはいかがですか」或者「コーヒーを飲みませんか」等表达方式！</strong></p>
</li>
<li><p><strong>名词（场所）+ <span style="color: red;">へ</span> + 动词「ます形」/名词（动名词）+ <span style="color: red;">に</span> + { <span style="color: red;">行きます/来ます/帰ります</span> }</strong></p>
<p> 「行きます」「来ます」「帰ります」这些动作的<strong>目的</strong>用助词「に」来表示。</p>
<p> <strong><em>注意：当「に」前的动词为「名词します」或「名词をします」时，要使用「名词 に 行きます/来ます/帰ります」的形式！</em></strong></p>
<p> 注：当节庆活动或音乐会等表示集会、庆典的名词放在「に」前面时，动作的目的一般会被认为是去参与该活动。</p>
</li>
<li><p><strong>どこか/何か</strong></p>
<p> 「どこか」表示<strong>某个地方</strong>，「なにか」表示<strong>某一物品</strong>。</p>
<p> 「どこか」和「なにか」后面的助词「へ」和「を」可以省略。</p>
</li>
<li><p><strong>ご〜</strong></p>
<p> 「ご」表示敬意。</p>
</li>
</ol>
<h5 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h5><p>本课主要学习的是「ほしい」以及「动词 たい 形」以及去某地做某事的句式的使用方法。</p>
<hr>
<h4 id="第十四课"><a href="#第十四课" class="headerlink" title="第十四课"></a>第十四课</h4><ol>
<li><p><strong>动词的类型</strong></p>
<p> 根据动词的活用方法，动词可以分为<strong>三种类型</strong>。</p>
<ul>
<li><p>I 类动词</p>
<p>  这一类动词的 「ます形」的最后音节为 「い段」。</p>
</li>
<li><p>II 类动词</p>
<p>  这一类动词的 「ます形」的最后音节绝大多数为 「え段」，也有一小部分为「い段」。</p>
</li>
<li><p>III 类动词</p>
<p>  这一类动词包含 「します」「动名词 + します」以及「きます」。</p>
</li>
</ul>
<p> <strong><em>注意：实际上判断是几类动词的方法有两种：一种是强行记住这个动词是哪种；另外一种是根据振假名以及送假名来对这个动词进行判断，判断其属于动 I 还是动 II。</em></strong></p>
</li>
<li><p><strong>动词 て 形</strong></p>
<p> 以「て」或「で」结束的动词的活用形叫做「て形」。从「ます形」变成「て形」的方法，根据动词类型的不同分为以下几种：</p>
<ul>
<li><p>I 类动词</p>
<p>  [1] 「ます形」的最后音节为 <span style="color: red;">「い、ち、り」</span>时，将其去掉，然后接<span style="color: red;">「って」</span>（促音便）</p>
<p>  [2] 「ます形」的最后音节为<span style="color: red;">「み、び、に」</span>时，将其去掉，然后接<span style="color: red;">「んで」</span>（拨音便）</p>
<p>  [3] 「ます形」的最后音节为<span style="color: red;">「き、ぎ」</span>时，将其去掉，然后接<span style="color: red;">「いて、いで」</span>（イ音便）</p>
<p>  [4] 「ます形」的最后音节为<span style="color: red;">「し」</span>时，直接接<span style="color: red;">「て」</span></p>
</li>
<li><p>II 类动词</p>
<p>  <strong>「ます形」后直接接 「て」。</strong></p>
</li>
<li><p>III 类动词</p>
<p>  <strong>「ます形」后直接接「て」。</strong></p>
</li>
</ul>
</li>
<li><p><strong>动词 て 形 + <span style="color: red;">ください</span>（表示 “<em>请······</em>”）</strong></p>
<p> 这个句型用于<strong>指示</strong>、<strong>委托</strong>或<strong>劝诱</strong>对方做某件事情。但是，该句型用于委托别人做某事时，语气并不是很客气，所以一般下级对上级时不能使用，并且多与「すみません」一起使用。</p>
</li>
<li><p><strong>动词 て 形 + <span style="color: red;">います</span></strong></p>
<p> 这个句型表示某一动作正在进行。</p>
<p> 例如：「ミラーさんは今電話をかけています。」米勒正在打电话。</p>
</li>
<li><p><strong>动词 ます 形 + <span style="color: red;">ましょうか</span>（表示 “<em>······吧</em>”）</strong></p>
<p> 表示说话人提出要为对方做某事。</p>
</li>
<li><p><strong>名词 + <span style="color: red;">が</span> + 动词</strong></p>
<p> 将自己五官所感的某种现象直接说出来，或客观地传达某件事情时，主语用助词<strong>「が」</strong>表示。</p>
<p> 例如：「雨が降っています。」下着雨呢。</p>
</li>
<li><p><strong>すみませんが</strong></p>
<p> 句末的「が」是用于开场白的语气较轻的接续词。</p>
</li>
</ol>
<h5 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h5><p>本课学习了「动词 て 形」的活用方法以及与「动词 て 形」相关的几个句型。</p>
<hr>
<h4 id="第十五课"><a href="#第十五课" class="headerlink" title="第十五课"></a>第十五课</h4><ol>
<li><p><strong>动词 て 形 + <span style="color: red">もいいですか</span>（表示 “<em>可以······吗</em>” ）</strong></p>
<p> 这个句型用于希望得到许可做某事。</p>
<p> 肯定回答可以直接 「ええ、动词 て 形 + も + いいですよ。」；</p>
<p> 否定回答则有两种，一种比较委婉，一种则比较强硬的表示禁止。</p>
<ul>
<li><p>委婉的否定回答：「すみません、ちょうと······。<em>这里可以放否定的原因</em>」</p>
</li>
<li><p>强硬的表示禁止的否定回答：「いいえ、动词 て 形 + は + いけません。<em>这里可以放否定的原因</em>」</p>
<p>例如：</p>
<p>ここでたばこを吸ってもいいですか。「这里可以抽烟吗？」</p>
<p>······ええ、吸ってもいいですよ。「嗯，可以抽。」</p>
<p>······すみません、ちょうと······。喉が痛いですから。「抱歉，请不要。因为我嗓子有点疼。」</p>
<p>······いいえ、吸ってはいけません。禁煙ですから。「不行，不能抽。因为这里禁烟。」</p>
</li>
</ul>
</li>
<li><p><strong>动词 て 形 + <span style="color: red">は</span> + <span style="color: red">いけません</span>（表示 “<em>不准······</em>” ）</strong></p>
<p> 这个句型表示禁止做某事。</p>
<p> <strong><em>注意：下级或晚辈对上级或长辈说话时不能使用这一用法！</em></strong></p>
<p> 例如：ここでたばこを吸ってはいけません。禁煙ですから。 「这里不准吸烟，因为这里禁烟。」</p>
</li>
<li><p><strong>动词 て 形 + <span style="color: red">います</span></strong></p>
<p> 这个句型除了在第 14 课中说过的表示动作正在进行的用法之外，还有如下两种用法：</p>
<ul>
<li><p>表示状态（主要是使用「〜ています形」的动词）</p>
<p>  例如：私は結婚しています。「我结婚了。」（说明：因为结婚并不是短时间或者说只是那一瞬间的行为，而是从结婚那天开始后，一直处于结婚这个状态，所以应该用 「結婚しています」而不是 「結婚しました」。）</p>
<p>  <strong>注意：</strong></p>
<p>  <strong>[1] 「知っています」的否定形是「知りません」而不是「知っていません」！</strong></p>
<p>  <strong>[2] 「持っています」有两种意思：第一种是现在手里正拿着；另外一种是表示拥有！</strong></p>
</li>
<li><p>表示习惯性的行为（长期重复做同一个动作）、职业或身份等</p>
<p>  例如：妹は大学で勉強しています。「妹妹在上大学。」</p>
</li>
</ul>
</li>
<li><p><strong>名词 + <span style="color: red">に</span> +动词</strong></p>
<p> 助词 「に」可以与 「はいります」「すわります」「のります」「のぽります」「つきます」等动词一起使用，来表示主语因某一个动作的结果而存在于某一场所。</p>
<p> 例如：ここに入ってはいけません。 「这里不得入内。」</p>
</li>
<li><p><strong>名词 1 + <span style="color: red">に</span> + 名词 2 + <span style="color: red">を</span> + 动词</strong></p>
<p> 在这个句式中助词 「に」可以有两种作用：</p>
<ul>
<li><p>动作的结果</p>
</li>
<li><p>名词 2 存在的场所（即名词 1）</p>
<p>例如：ここに車をとめてください。 「请把车停在这里。」</p>
</li>
</ul>
</li>
</ol>
<h5 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h5><p>本课扩展了上一课中关于「动词 て 形」的用法。</p>
]]></content>
      <categories>
        <category>日语</category>
      </categories>
      <tags>
        <tag>日语</tag>
        <tag>语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>みんなの日本語中級（一）</title>
    <url>/%E6%97%A5%E8%AF%AD/%E3%81%BF%E3%82%93%E3%81%AA%E3%81%AE%E6%97%A5%E6%9C%AC%E8%AA%9E%E4%B8%AD%E7%B4%9A%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<center><strong><span style="font-size: 22px;">文法记录与总结</span></strong></center>

<h4 id="第一课"><a href="#第一课" class="headerlink" title="第一课"></a>第一课</h4><a id="more"></a>

<ol>
<li><p><strong>〜てもらえませんか / 〜ていただけませんか / 〜てもらえないでしょうか / 〜ていただけないでしょうか</strong></p>
<p> <span style="color: red;">接続：V て形 + { 〜てもらえませんか / 〜ていただけませんか / 〜てもらえないでしょうか / 〜ていただけないでしょうか }</span></p>
<p> 「〜てもらえませんか / 〜ていただけませんか」用于<strong>说话人郑重地向说话人拜托某事</strong>。</p>
<p> 而「〜てもらえないでしょうか / 〜ていただけないでしょうか」比「〜てもらえませんか / 〜ていただけませんか」更礼貌、委婉。</p>
<p> 例如：</p>
<p> 「ちょっとペンを貸してもらえませんか。」能不能借一下你的笔？</p>
<p> 「コピー機の使い方を教えていただけませんか。」请您教我复印机的使用方法。</p>
<p> 「すみません、子どもが寝ているので、もう少し静かにしてもらえないでしょうか。」对不起，我孩子在睡觉，请稍微安静一些好吗？</p>
<p> 「申し訳ございませんが、子どもを預かっていただけないでしょうか。」实在对不起，能不能帮我照看一下孩子？</p>
<p> <span style="color: red;">参考：「〜ていただけませんか（请求的礼貌表达）」（みんなの日本語初級第２６課）</span></p>
</li>
<li><p><strong>〜のようだ / 〜のような〜 / 〜のように···（比喻、举例）</strong></p>
<p> <span style="color: red;">接続：N の + { ようだ / ような N / { ように V / い A / な A } }</span></p>
<p> <strong>「N1 は N2 のようだ」用于拿 N1 的特点来比喻 N2 的场合</strong>。（比喻、举例）</p>
<p> 例如：</p>
<p> 「あの病院はホテルのようだ。」那个医院像酒店一样。</p>
<p> 「このお酒はジュースのようだ。」这酒像果汁一样。</p>
<p> <strong>有时候用「N2 のような N1」的形式来修饰名词</strong>。</p>
<p> 例如：</p>
<p> 「田中さんはホテルのような病院に入院している。」田中先生住在像酒店似的医院里。</p>
<p> 「私はジュースのようなお酒しか飲まない。」我只喝像果汁一样的酒。</p>
<p> <strong>另外，也可以用「N1 は N2 のように」的形式，放在动词和形容词前面使用</strong>。</p>
<p> 例如：</p>
<p> 「田中さんが入院している病院はホテルのようにきれいだ。」田中先生住的医院像酒店一样漂亮。</p>
<p> 「このお酒はジュースのように甘い。」这酒像果汁一样甜。</p>
<p> <strong>「N2 のような N1」也用 N2 来举例描述 N1 的特征</strong>。</p>
<p> 例如：</p>
<p> 「夫は、カレーのような簡単な料理しか作れません。」我丈夫只能做像咖喱那样的简单菜肴。</p>
<p> 「「アポ」のような外来語は、外国人にはとても難しい。」「アポ」之类的外来语对外国人来说很难懂。</p>
<p> <span style="color: red;">参考：「···ようだ（从某状态得出的判断）」（みんなの日本語初級第４７課）</span></p>
</li>
<li><p><strong>〜ことは / が / を</strong></p>
<p> <span style="color: red;">接続：V 字典形 + こと + { は / が / を }</span></p>
<p> <strong>用「〜こと」来实现名词化</strong>。</p>
<p> 例如：</p>
<p> 「朝早く起きることは健康にいい。」清晨早起有益于健康。</p>
<p> 「田中さんは踊ることが好きです。」田中先生喜欢跳舞。</p>
<p> 「優勝することを目指しています。」争取夺冠。</p>
<p> <span style="color: red;">参考：「V 字典形 + ことができます / ことです」（みんなの日本語初級第１８課）</span></p>
</li>
<li><p><strong>〜を〜と言う</strong></p>
<p> <span style="color: red;">接続：N1 を N2 と言う</span></p>
<p> <strong>把物品或事物 N1 称为 N2</strong>。</p>
<p> 例如：</p>
<p> 「１月１日を元日と言います。」把 1 月 1 日称为「元日（がんじつ）」（元旦）。</p>
<p> 「正月に神社やお寺に行くことを初詣でと言う。」把正月去神社或寺庙，称为「初詣で（はつもうで）（初次参拜）」。</p>
</li>
<li><p><strong>〜という〜</strong></p>
<p> <span style="color: red;">接続：N1 という N2</span></p>
<p> 本句型用于在会话或文章中提到的、听话人可能不知道的事物或人物 N1 的时候。N1 是姓名等专有名词，N2 为普通名词。</p>
<p> 例如：</p>
<p> 「夏目漱石という小説家を知っていますか。」你知道夏目漱石这位小说家吗？</p>
<p> 「昨日、「スター・ウォーズ」という映画を見ました。」昨天看了部名为《星球大战》的电影。</p>
</li>
<li><p><strong>いつ / どこ / なに / だれ / どんなに〜ても</strong></p>
<p> <span style="color: red;">接続：{ V て形 / い A（ー<s>い</s> =&gt; くて） / な A で / N で } + も</span></p>
<p> <strong>在「いつ」「どこ」「何」「だれ」「どんなに」等词汇后面使用「ても」，表示 “无论什么场合，都······”</strong>。</p>
<p> 例如：</p>
<p> 「世界中どこにいても家族のことを忘れません。」在世界的任何地方，都不会忘记家人。</p>
<p> 「何度聞いても同じことしか教えてくれない。」不管问多少次，他只重复同样的回答。</p>
<p> 「だれがなんと言っても考えを変えません。」无论是谁，无论说什么，我的想法都不变。</p>
<p> 「どんなに高くても買いたいです。」无论多贵，我也想买。</p>
<p> <strong>若是名词的时候，使用「どんな N でも」「どの N でも」「どんなに〜 N でも」的形式</strong>。</p>
<p> 例如：</p>
<p> 「どんな人でも優しい心を持っているはずだ。」无论是什么样的人，都该有颗温柔的心。</p>
<p> 「正月になると、どの神社でも人がいっぱいだ。」一到新年，无论哪个神社都挤满了人。</p>
<p> 「どんなに丈夫なかばんでも長く使えば、壊れてしまうこともある。」无论怎样结实的提包，若长期使用都会坏。</p>
<p> <span style="color: red;">参考：「〜ても（逆接）」（みんなの日本語初級第２５課）</span></p>
</li>
<li><p><strong>〜じゃなくて、〜</strong></p>
<p> <span style="color: red;">接続：N1 じゃなくて、N2</span></p>
<p> <strong>「N1 じゃなくて、N2」用于否定 N1，用 N2 代之</strong>。</p>
<p> 例如：</p>
<p> 「これはペンじゃなくて、チョコレートです。食べられますよ。」这不是钢笔，是巧克力，能吃的。</p>
<p> 「京都ではお寺を見ましょうか。」咱们在京都去看寺庙吧。</p>
<p> ······「お寺じゃなくて、若い人が行くようなにぎやかなところに行きたいです。」我不想去寺庙，想逛年轻人去的那种热闹的地方。</p>
</li>
<li><p><strong>···のだ / ···のではない</strong></p>
<p> <span style="color: red;">接続：{ V 普通形 / い A 普通形 / な A 普通形（ー<s>だ</s> =&gt; な） / N 普通形（ー<s>だ</s> =&gt; な） } + { のだ / のではない }</span></p>
<p> <strong>在强调由某种原因产生的结果或由某种依据而得出的判断时，用「···のです」的形式</strong>。</p>
<p> <strong><em>注：だから（理由 / 依据）、それで（结果 / 判断）</em></strong></p>
<p> 例如：</p>
<p> 「３時の飛行機に乗らなければなりません。それで、私は急いでいるのです。」必须乘坐 3 点的飞机，所以我现在很急。</p>
<p> 「彼は日本に留学します。それで日本語を勉強しているのです。」他要去日本留学，所以，在学习日语。</p>
<p> <strong>「···のではない」用于否定谓语以外的成分</strong>。</p>
<p> 例如：</p>
<p> 「このレポートは一人で書いたのではありません。」这个报告不是一个人写的。</p>
<p> <strong><em>上句否定的是「一人で」而不是谓语「書いた」</em></strong>。</p>
</li>
<li><p><strong>何人も、何回も、何枚も···</strong></p>
<p> <strong>「なん + 助数詞（人、回、枚···） + も」强调数量之多</strong>。</p>
<p> 例如：</p>
<p> 「マンションの前にパトカーが何台も止まっています。」公寓前面停放了好几辆警车。</p>
</li>
</ol>
<hr>
<h4 id="第二课"><a href="#第二课" class="headerlink" title="第二课"></a>第二课</h4><ol>
<li><p><strong>〜たら、〜た</strong></p>
<p> <span style="color: red;">接続：V たら、{ V / A } た</span></p>
<ul>
<li><p><strong>「X たら、Y た」表示动作 X 结束之后，发生了 Y 的结果（导致了 Y 的结果）</strong>。</p>
<p>  例如：</p>
<p>  「薬を飲んだら、元気になりました。」服药以后，就康复了。</p>
<p>  「カーテンを変えたら、部屋が明るくなった。」更换了窗帘之后，房间就变得明亮了。</p>
</li>
<li><p><strong>有时表示动作 X 之后，发现了 Y 的意思（意外）</strong>。</p>
<p>  例如：</p>
<p>  「家に帰ったら、猫がいなかった。」回到家，发现猫不在了。</p>
<p>  「かばんを開けたら、財布がなくなっていた。」打开提包，发现钱包没了。</p>
<p>  「５０年前の古いお酒を飲んでみたら、おいしかった。」尝了尝 50 年前的陈酿，发现味道还不错。</p>
</li>
</ul>
<p> <strong>「X と、Y た」也可以表示上述两个的意思</strong>。</p>
<p> 例如：</p>
<p> 「薬を飲むと、元気になりました。」服药以后，就康复了。</p>
<p> 「家に帰ると、猫がいなかった。」一回到家，就发现猫不在了。</p>
<p> <span style="color: red;">参考：「〜たら（假定）」「〜たら（完了）」（みんなの日本語初級第２５課）</span></p>
</li>
<li><p><strong>〜というのは〜のことだ / 〜というのは···ということだ</strong></p>
<p> <span style="color: red;">接続：N というのは + { N の / 句子（普通形） } + ことだ</span></p>
<p> <strong>「X というのは〜のことだ」「X というのは···ということだ」是用来说明某个词 X 的意思时的表达形式。</strong></p>
<p> 例如：</p>
<p> 「３Kというのは汚い、きつい、危険な仕事のことだ。」所谓 3 K 是指脏活、累活和危险活的意思。</p>
<p> 「PCというのはパソコンのことです。」所谓 PC 是指个人电脑的意思。</p>
<p> 「禁煙というのはタバコを吸ってはいけないということです。」所谓「禁煙」就是说不许吸烟的意思。</p>
<p> 「駐車違反というのは車を止めてはいけない場所に車を止めたということです。」所谓「駐車違反」是指把车停在了不允许停车的场所。</p>
</li>
<li><p><strong>···という〜</strong></p>
<p> <span style="color: red;">接続：句子（普通形） + という N（表示说话和思考的名词）</span></p>
<p> <strong>「話（事情）、うわさ（传言）、考え（想法）、意見（意见）、意志（意志）、批判（批判）、ニュース（消息）」等表示说话及思考的名词的内容时，使用「···という〜」的表达形式。</strong></p>
<p> 例如：</p>
<p> 「昔ここは海だったという話を知っていますか。」这里曾经是大海，这事你知道吗？</p>
<p> 「田中さんがもうすぐ会社を辞めるといううわさを聞きました。」听到了传言说田中先生很快就要辞职了。</p>
<p> 「カリナさんは、研究室は禁煙にしたほうがいいという意見を持っている。」卡莉娜的意见是，研究室最好禁烟。</p>
</li>
<li><p><strong>···ように { 言う / 注意する / 伝える / 頼む }</strong></p>
<p> <span style="color: red;">接続：{ V 字典形 / V ない形（ーない） } + ように + V（言う、注意する、伝える、頼む）</span></p>
<p> <strong>间接的引用指示或委托内容时使用。如果直接表达指示或委托时则使用「〜なさい」及「〜てはいけません」「〜てください」的句型。</strong></p>
<p> 例如：</p>
<p> 「学生に図書館で物を食べないように注意しました。」我提醒了学生不要在图书馆里吃东西。</p>
<p> ······「学生に「図書館で物を食べてはいけません」と注意しました。」我提醒了学生：“不要在图书馆里吃东西”。</p>
<p> 「この仕事を今日中にやるように頼まれました。」叫我在今天之内把这个工作做完。</p>
<p> ······「「この仕事を今日中にやってください」と頼まれました。」（某人）对我说：“请在今天之内把这个工作做完”。</p>
<p> 「子どもたちに早く寝るように言いました。」我叫孩子们快点睡觉。</p>
<p> ······「子どもたちに「早く寝なさい」と言いました。」我对孩子们说：“快点睡觉啦”。</p>
<p> <strong><em>另外、「〜なさい」是指示和命令的表达形式。用于像父母对孩子等有限的场合。也用于考试里的指示句等。</em></strong></p>
</li>
<li><p><strong>〜みたいだ / 〜みたいな〜 / 〜みたいに···（比喻、举例）</strong></p>
<p> <span style="color: red;">接続：N + { みたいだ / みたいな N / みたいに { V / い A / な A } }</span></p>
<p> <strong>「〜ようだ」和「〜みたいだ」意思虽然一样，但「〜みたいだ」用于比较随意一点的口语</strong>。</p>
<p> 例如：</p>
<p> 「わあ、このお酒、ジュースみたいだね。」哇·····，这个酒好像果汁啊。</p>
<p> 「私はジュースみたいなお酒しか飲まない。」我只喝果汁那样的酒。</p>
<p> 「このお酒はジュースみたいに甘いよ。」这个酒好像果汁那样甜啊。</p>
<p> 「夫は、カレーみたいな簡単な料理しか作れません。」我先生只会做咖喱那样简单的菜。</p>
<p> <span style="color: red;">参考：「〜のようだ / 〜のような〜 / 〜のように···」（みんなの日本語中級第１課）</span></p>
</li>
<li><p><strong>〜ところ</strong></p>
<p> <strong>表达「〜とき」的意思，但使用范围很有限，如「お忙しいところ」「お休みのところ」「お急ぎのところ」「お疲れのところ」等。在求人办事或向他人表示感谢时使用</strong>。</p>
<p> 例如：</p>
<p> 「お忙しいところ、すみません。ちょっとお願いがあるんですが。」很抱歉在您正忙的时候打扰了。我有件事想请您帮个忙。</p>
<p> 「お休みのところ、手伝ってくださって、ありがとうございました。」您在休息的时候专门来帮我，非常感谢。</p>
</li>
</ol>
<hr>
<h4 id="第三课"><a href="#第三课" class="headerlink" title="第三课"></a>第三课</h4><ol>
<li><p><strong>〜（さ）せてもらえませんか / 〜（さ）せていただけませんか / 〜（さ）せてもらえないでしょうか / 〜（さ）せていただけないでしょうか</strong></p>
<p> <span style="color: red;">接続：V（さ）せて + { もらえませんか / いただけませんか / もらえないでしょうか / いただけないでしょうか }</span></p>
<p> <strong>本句型表示说话人请求听话人允许自己「〜すること」（做某件事）</strong>。</p>
<p> 例如：</p>
<p> 「すみません。このパンフレットをコピーさせてもらえませんか。」对不起，能否让我复印一下这本简介？</p>
<p> 「月曜日の店長会議で報告させていただけませんか。」能否让我在星期一的店长会议上汇报？</p>
<p> 「一度、工場を見学させていただけないでしょうか。」能否让我（们）参观一下工厂？</p>
<p> <strong>礼貌程度逐渐上升：「〜させてもらえませんか」=&gt;「〜させていただけませんか」=&gt;「〜させていただけないでしょうか」。总之，语气越委婉越有礼貌。</strong></p>
<p> <span style="color: red;">参考：「〜させていただけませんか（请求的礼貌表达）」（みんなの日本語初級第４８課）</span></p>
</li>
<li><p><strong>···ことにする</strong></p>
<p> <span style="color: red;">接続：{ V 字典形 / V ない形（ーない） } + ことにする</span></p>
<p> <strong>用「V する / V しないことにする」来表示当事人决定做或不做某件事</strong>。</p>
<p> 例如：</p>
<p> 「来年結婚することにしました。」我决定明年结婚。</p>
<p> 「今晩は外で食事をすることにしよう。」今晚咱们在外面吃饭吧。</p>
</li>
<li><p><strong>···ことにしている</strong></p>
<p> <span style="color: red;">接続：{ V 字典形 / V ない形（ーない） } + ことにしている</span></p>
<p> <strong>用「V する / V しないことにしている」来表示以前就决定并一直遵守的某种习惯</strong>。</p>
<p> 例如：</p>
<p> 「毎週日曜日の夜は外で食事をすることにしている。」我每周日晚一般在外面吃饭。</p>
<p> 「ダイエットしているので、お菓子を食べないことにしている。」因为在减肥，所以我一直就不吃点心。</p>
</li>
<li><p><strong>···ことになる</strong></p>
<p> <span style="color: red;">接続：{ V 字典形 / V ない形（ーない） } + ことになる</span></p>
<p> <strong>用「V する / V しないことになる」的句型表示由客观因素造成做或不做某事。这一点与「ことにする」是由自己做决定不同，「ことになる」表示的是与自己的意志无关的决定。</strong></p>
<p> 例如：</p>
<p> 「来月アメリカへ出張することになりました。」已经定了我下个月去美国出差。</p>
<p> 「中国へは田中さんが行くことになるでしょう。」大概会派田中先生去中国吧。</p>
<p> <strong>不过，即便是自己做的决定，有时为了避免太突出个人的意志，也委婉地使用「ことになる」。</strong></p>
<p> 例如：</p>
<p> 「部長、実は、今年の秋に結婚することになりました。結婚式に出席していただけないでしょうか。」部长，我们今年秋天要结婚了，可以请您出席我们的婚礼吗？</p>
</li>
<li><p><strong>···ことになっている</strong></p>
<p> <span style="color: red;">接続：{ V 字典形 / V ない形（ーない） } + ことになっている</span></p>
<p> <strong>「V する / V しないことになっている」的句型，表示按预订计划、规章等决定的事情</strong>。</p>
<p> 例如：</p>
<p> 「明日の朝９時から試験を行うことになっています。」定于明天上午 9 点开始考试。</p>
<p> 「家では夜９時以降はテレビをつけないことになっている。」我们家一般 9 点以后就不开电视了。</p>
</li>
<li><p><strong>〜てほしい / 〜ないでほしい</strong></p>
<p> <span style="color: red;">接続：{ V 字典形 / V ない形（ーないで） } + ほしい</span></p>
<ul>
<li><p><strong>用「N に V てほしい」的形式来表示说话人希望他人（N）做某事（V）</strong>。</p>
<p>  例如：</p>
<p>  「私は息子に優しい人になってほしいです。」我希望儿子成为一个温柔的人。</p>
<p>  <strong>当「N に」所指的人是谁很清楚时，这部分也可以省略</strong>。</p>
<p>  例如：</p>
<p>  「このごろ自転車を利用する人が多いが、規則を守って乗ってほしい。」近来骑自行车的人多了，我希望（大家）骑车时遵守交通规则。</p>
<p>  <strong>当说话人不希望对方做某事时，使用否定形「V ないでほしい」的形式表达</strong>。</p>
<p>  例如：</p>
<p>  「こんなところにごみを捨てないでほしい。」希望不要把垃圾扔在这里。</p>
<p>  <strong>如果是针对对方的行为使用这种说法，就带有请求或命令的语气，为了避免这种过于直接的口吻，会经常在句尾加上「のですが / んですが」等</strong>。</p>
<p>  例如：</p>
<p>  「すみません、ちょっと手伝ってほしいんですが。」对不起，希望你能帮一下忙，可以吗？</p>
</li>
<li><p><strong>本句型也可以用于不是针对人的动作和行为，这时候就不是「N に」而是「N が」了</strong>。</p>
<p>  例如：</p>
<p>  「早く春が来てほしい。」希望春天早点到来。</p>
<p>  「明日は雨が降らないでほしい。」希望明天不要下雨。</p>
</li>
</ul>
</li>
<li><p><strong>〜そうな〜 / 〜そうに···</strong></p>
<p> <span style="color: red;">接続：{ V ます形 / い A（ー<s>い</s>） / な A } + { そうな N / そうに V }</span></p>
<p> <strong>接在动词后的「V ます形ーそうだ」与接在形容词后的「A そうだ」的意思不同。「V そうだ」表达的是预计动作发生的可能性很高和动作要发生的征兆</strong>。</p>
<p> 例如：</p>
<p> 「ミラーさん、シャツのボタンが取れそうですよ。」米勒先生，你衬衣的扣子快要掉了哟。</p>
<p> 「雨が降りそうなときは、洗濯しません。」看样子快要下雨的时候，我不洗衣服。</p>
<p> <strong>而「A そうだ」表示的是外表上看起来 “是······样子”</strong>。</p>
<p> 例如：</p>
<p> 「ワンさんの隣にいる学生はまじめそうですね。」坐在小王旁边的学生看样子很认真。</p>
<p> 「このケーキはおいしそうですね。」这蛋糕看样子很好吃。</p>
<p> 「子どもたちが楽しそうに遊んでいます。」看样子孩子们玩得很愉快。</p>
<p> <strong>当表示预计和征兆的「V そうだ」和表示外观的「A そうだ」修饰名词时，就会变成「そうな N」的形式，修饰动词时会变成「そうに V」的形式</strong>。</p>
<p> 例如：</p>
<p> 「雨が降りそうなときは、洗濯しません。」看样子快要下雨的时候，我不洗衣服。</p>
<p> 「おいしそうなケーキがありますね。」有看样子很好吃的蛋糕。</p>
<p> 「子どもたちが楽しそうに遊んでいます。」看样子孩子们玩得很愉快。</p>
<p> <span style="color: red;">参考：「〜そうだ（预测、看样子）」（みんなの日本語初級第４３課）</span></p>
</li>
<li><p><strong>～なさそう</strong></p>
<p> <span style="color: red;">接続：{ い A（ー<s>い</s> =&gt; く） / { な A（ー<s>だ</s> =&gt; では（じゃ）） / N（ー<s>だ</s> =&gt; では（じゃ）） } } + なさそう</span></p>
<p> <strong>这是「A そうだ」的否定形式，表示 “看样子不是······” 的意思</strong>。</p>
<p> 例如：</p>
<p> 「あの映画はあまり面白くなさそうですね。」那部电影看样子不太有趣。</p>
<p> 「この機械はそんなに複雑じゃ（では）なさそうです。」这台机器看起来没那么复杂。</p>
<p> 「彼は学生ではなさそうです。」看样子他不是学生。</p>
</li>
<li><p><strong>〜そうもない</strong></p>
<p> <span style="color: red;">接続：V ます形 + そうもない</span></p>
<p> <strong>「V ますーそうだ」的否定形式，表示 “看样子不会发生 V” 的意思</strong>。</p>
<p> 例如：</p>
<p> 「今日は仕事がたくさんあるので、５時に帰れそうもありません。」因为今天工作很多，看样子 5 点回不去了。</p>
<p> 「この雨はまだやみそうもないですね。」这场雨看样子还不会停。</p>
</li>
<li><p><strong>〜たあと、···</strong></p>
<p><span style="color: red;">接続：V たあと、···</span></p>
<p><strong>「V たあと、···」表示在前一动作或状态（V）之后，又会接着发生某项动作或状态</strong>。</p>
<p>例如：</p>
<p>「じゃ、来週の月曜日会議が終わった { あと / あとで }、お会いしましょうか。」那么，等下周一的会议结束后，我们见面吧。</p>
<p><strong>当「···」的后续部分里有「いる」「ある」等时，就不同「あとで」了</strong>。</p>
<p>例如：</p>
<p>「日曜日は朝食を食べたあと、どこへも行かず家でテレビを見ていました。」周日吃过早饭后，我哪儿也没去，在家看电视了。</p>
<p>「授業が終わったあと、学生が２、３人まだ教室に残っていました。」下课后，还有两三个学生留在教室里。</p>
</li>
</ol>
<hr>
<h4 id="第四课"><a href="#第四课" class="headerlink" title="第四课"></a>第四课</h4><ol>
<li><p><strong>···ということだ（伝聞）</strong></p>
<p> <span style="color: red;">接続：句子（普通形） + ということだ</span></p>
<ul>
<li><p><strong>「X ということだ」是和「X そうだ」相似的传闻表达，用于传达其他人所说的内容或人们普遍的看法</strong>。</p>
<p>  例如：</p>
<p>  「山田さんから電話があったのですが、約束の時間に少し遅れるということです。」山田先生来电话说要比约定时间晚来一会儿。</p>
<p>  「近所にいた人の話によると、トラックから急に荷物が落ちたということです。」据在场的人说，从卡车上突然掉下了行李。</p>
<p>  <strong>也有「とのことです」的形式，但偏向书面语</strong>。</p>
<p>  例如：</p>
<p>  「（手紙文）先日、ワンさんに会いました。ワンさんから先生によろしくとのことです。」（书信文）前几天见着王先生了，他托我向老师您问好。</p>
</li>
<li><p><strong>「X ということですね」有时也用于再次向对方确认目前所听到的内容</strong>。</p>
<p>  例如：</p>
<p>  「部長に３０分ほど遅れると伝えてください。」请转告部长我要晚到 30 分钟左右。</p>
<p>  ······「はい、わかりました。３０分ほど遅れるということですね。」好，知道了。是晚到 30 分钟左右，对吧。</p>
</li>
</ul>
</li>
<li><p><strong>···の / ···の？</strong></p>
<p> <span style="color: red;">接続：句子（普通形） + { の / の？ }</span></p>
<p> <strong>是比「···のですか」更加随意的说法，用于和熟人说话的时候</strong>。</p>
<p> 例如：</p>
<p> 「どこへ行くの？」去哪儿？</p>
<p> ······「ちょっと郵便局へ。」去趟邮局。</p>
<p> 「元気がないね、先生に叱られたの？」怎么，没精神呢。挨老师批了？</p>
<p> ······「うん。」嗯。</p>
<p> 「どうしたの？」怎么了？</p>
<p> ······「お母さんがいないの。」妈都不在家。</p>
<p> <span style="color: red;">参考：「···のです / んです（强调说明原因、理由、依据时使用。口语的说法是「···んです」，书面语是「···のです」）」（みんなの日本語初級第２６課）</span></p>
</li>
<li><p><strong>〜ちゃう / 〜とく / 〜てる</strong></p>
<p> <span style="color: red;">接続：{ V てしまう =&gt; V ちゃう }、{ V ておく =&gt; V とく }、{ V ている =&gt; V てる }（口语的约音）</span></p>
<ul>
<li><p><strong>「〜てしまう」的口语是「〜ちゃう」</strong>。</p>
<p>  例如：</p>
<p>  「行ってしまいます」=&gt;「行っちゃいます」</p>
<p>  「読んでしまった」=&gt;「読んじゃった」</p>
<p>  「見たしまった」=&gt;「見ちゃった」</p>
</li>
<li><p><strong>「〜ておく」的口语是「〜とく」</strong>。</p>
<p>  例如：</p>
<p>  「見ておきます」=&gt;「見ときます」</p>
<p>  「作っておこう」=&gt;「作っとこう」</p>
<p>  「読んでおいてください」=&gt;「読んどいてください」</p>
</li>
<li><p><strong>「〜ている」的口语是「〜てる」</strong>。</p>
<p>  例如：</p>
<p>  「走っている」=&gt;「走ってる」</p>
<p>  「読んでいる」=&gt;「読んでる」</p>
<p>  「見ていない」=&gt;「見てない」</p>
</li>
</ul>
</li>
<li><p><strong>〜（さ）せられる / 〜される（使役受身）</strong></p>
<p> <span style="color: red;">I 类动词：ない形 + せられる / される</span></p>
<p> <span style="color: red;">II 类动词：ない形 + させられる</span></p>
<p> <span style="color: red;">III 类动词：する =&gt; させられる；くる =&gt; こさせられる</span></p>
<ul>
<li><p><strong>使役加被动的表达</strong>。</p>
<p>  例如：</p>
<p>  「太郎君は掃除をしました。」太郎做了扫除。</p>
<p>  ······（使役文）「先生は太郎君に掃除をさせました。」老师让太郎做扫除。</p>
<p>  ······（使役受身文）「太郎君は先生に掃除をさせられました。」太郎被老师叫去做扫除。</p>
</li>
<li><p><strong>使役被动的基本句形是「N1 は N2 に V させられる」，有时 N2 不一定会出现，但无论出现与否，N1 都并非出于自己的主观意志，而是按照别人的指示行事</strong>。</p>
<p>  例如：</p>
<p>  「昨日の忘年会ではカラオケを{ 歌わせられた / 歌わされた }。」昨天的年会上非让我唱了卡拉 OK。</p>
<p>  「この会議では毎月新しい問題について研究したことを発表させられます。」在这个会议上，让我们汇报每月有关新问题的研究情况。</p>
</li>
</ul>
</li>
<li><p><strong>〜である（である体）</strong></p>
<p> <span style="color: red;">接続１：{ N / な A} + である</span></p>
<p> <span style="color: red;">接続２：〜ている + のである</span></p>
<p> <strong>意思和「〜だ」相同，文体郑重，常用于文章</strong>。</p>
<p> 例如：</p>
<p> 「失敗は成功の母である。」失败是成功之母。</p>
<p> 「このような事件を起こしたことは非常に残念である。」很遗憾发生了这样的事情。</p>
<p> 「ここは去年まで山であった。」这儿去年还是座山。</p>
<p> <strong>「〜のだ」的「である 体」是「〜のである」。</strong></p>
<p> 例如：</p>
<p> 「世界中の人々が地球の平和を願っているのである。」全世界人民都是希望世界和平的。</p>
</li>
<li><p><strong>〜<s>ます</s>、〜<s>ます</s> / 〜く<s>て</s>、〜く<s>て</s>、···（中止形）</strong></p>
<p> <span style="color: red;">接続１：V ます形（ー<s>ます</s>）（います =&gt; おり）</span></p>
<p> <span style="color: red;">接続２：い A：い A（ー<s>い</s> =&gt; く）</span></p>
<p> <span style="color: red;">な A：な A（ーで）</span></p>
<p> <span style="color: red;">N：N（ーで）</span></p>
<ul>
<li><p><strong>动词中顿形（和「ます形」相同），句型「V1 （ます形）、V2」跟「V1（て形）、V2」一样，都是表示动作的相继出现以及并列的句子</strong>。</p>
<p>  例如：</p>
<p>  「朝起きたら、まず顔を洗い、コーヒーを飲み、新聞を読みます。」早上起来先洗脸，再喝咖啡，读报纸。</p>
<p>  「彼とは学生時代、よく遊び、よく話し、よく飲んだ。」在学生时代经常和他一起玩、聊天、喝酒。</p>
</li>
<li><p><strong>「いる」的中顿形是「おり」</strong>。</p>
<p>  例如：</p>
<p>  「兄は東京におり、姉は大阪にいます。」哥哥在东京，姐姐在大阪。</p>
</li>
<li><p><strong>形容词、名词的中顿形可以用来表示并列</strong>。</p>
<p>  例如：</p>
<p>  「マリアさんは、優しく、頭がよく、すばらしい女性だ。」玛丽亚既善良又聪明，是个很出色的女性。</p>
</li>
</ul>
</li>
<li><p><strong>〜（た）がる</strong></p>
<p> <span style="color: red;">接続１：V ます形 + たがる（「たい形」）</span></p>
<p> <span style="color: red;">接続２：{ い A（ー<s>い</s>） / な A } + がる</span></p>
<p> <strong>「N が〜（た）がる」该句型和带有感情的形容词相连接，表示他人的情感流露在表情或行动上。当「〜たい」表示愿望或希望时要变成「〜たがる」</strong>。</p>
<p> 例如：</p>
<p> 「太郎君は友達のおもちゃを欲しがる。」太郎总想要朋友的玩具。</p>
<p> 「このチームが負けると、息子はすごく悔しがる。」每当这个球队输了，儿子总是很沮丧。</p>
<p> 「このごろの若者は、難しい本を読みたがらない。」现在的年轻人不喜欢读难懂的书。</p>
</li>
<li><p><strong>〜（た）がっている</strong></p>
<p> <span style="color: red;">接続１：V ます形 + たがっている</span></p>
<p> <span style="color: red;">接続２：{ い A（ー<s>い</s>） / な A } + がっている</span></p>
<p> <strong>「〜（た）がる」表示总是有某种想法或想要做某事的倾向。而表示正处于某种情感状态时则用「〜たがっている」</strong>。</p>
<p> 例如：</p>
<p> 「太郎君は友達のおもちゃを欲しがっている。」太郎现在就想要朋友的玩具。</p>
<p> 「好きなチームが負けて、息子はすごく悔しがっている。」儿子喜欢的球队输了，他很沮丧。</p>
</li>
<li><p><strong>···こと / ···ということ</strong></p>
<p> <span style="color: red;">接続１：句子（普通形）+ [という]こと + 格助词</span></p>
<p> <span style="color: red;">接続：な A + { なこと / であること }</span></p>
<ul>
<li><p><strong>格助词只接在名词之后，当活用词要充当句子成分时就必须名词化，这时就需要用「···こと + 格助词」的句型，「···こと」的前面接普通形</strong>。</p>
<p>  例如：</p>
<p>  「田中さんが結婚したことを知っていますか。」你知道田中先生已经结婚了吗？</p>
<p>  「これは田中さんの辞書ではないことがわかりました。」我知道了这不是田中先生的字典。</p>
<p>  <strong>以「な 形容词」结句时，句型为「な 形容词 + なこと」、或「な 形容词 + であること」</strong>。</p>
<p>  例如：</p>
<p>  「世界中でこの漫画が有名{ な / である }ことを知っていますか。」知道这本漫画书在全世界都很有名吗？</p>
</li>
<li><p><strong>为了把长而复杂的句子名词化，需要在「こと」前加「という」。「〜ということ」接普通形</strong>。</p>
<p>  例如：</p>
<p>  「二十歳になれば誰でも結婚できるということを知っていますか。」满二十岁的人谁都可以结婚，你知道吗？</p>
<p>  「日本に来てから、家族はとても大切{ だ / である }ということに初めて気がついた。」来到日本才初次感觉到家人是很重要的。</p>
<p>  「この辺りは昔、海{ だった / であった }ということは、あまり知られていない。」人们都不太知道，以前这里曾经是海。</p>
<p><span style="color: red;">参考：「こと」（みんなの日本語初級第２５課、みんなの日本語中級第１課）</span></p>
</li>
</ul>
</li>
<li><p><strong>〜の〜（同格）</strong></p>
<p><strong>表示 N1 和 N2 为同一事物。N1 是表示 N2 属性的名词，并对 N2 进行详细说明。也可以换成「N1 である N2」</strong>。</p>
<p>例如：</p>
<p>「部長の田中をご紹介します。」向您介绍部长田中。</p>
<p>「あさっての金曜日はご都合いかがですか。」后天周五您有空吗？</p>
</li>
<li><p><strong>〜ましたら、··· / 〜まして、···</strong></p>
<p><span style="color: red;">接続：V（礼貌形） + { たら / て }、···</span></p>
<p><strong>「たら」和「て形」能让句子变得客气</strong>。</p>
<p>例如：</p>
<p>「会議が終わりましたら、こちらからお電話させていただきます。」会议结束后，我打电话跟您联系。</p>
<p>「本日は遠くから来てくださいまして、ありがとうございました。」今天您远道而来，真是非常感谢。</p>
</li>
</ol>
<hr>
<h4 id="第五课"><a href="#第五课" class="headerlink" title="第五课"></a>第五课</h4><ol>
<li><p><strong>あ〜 / そ〜（文脈指示（会話））</strong></p>
<p> <strong>「あ〜」「そ〜」等指示词，除了指当场的事物，还指会话或文章中出现的事物。在会话中，对说话人和听话人都直接知道的事物，用「あ（あれ、あの、あそこ···）」。反之，说话人知道而听话人不知道，或者听话人知道而说话人不知道的事物，用「そ（それ、その、そこ）」</strong>。</p>
<p> 例如：</p>
<p> 「さっき、山本さんに会ったよ。」刚才我见到山本先生了。</p>
<p> ······「え、あの人、今日本にいるんですか。」是吗？他（那个人）现在在日本吗？</p>
<p> 「さっき、図書館でマリアさんという人に会ったんだけどね。その人、この学校で日本語を勉強したんだって。」刚才，在图书馆遇到那个叫玛丽亚的人了。听说她（那个人）在这个学校学过日语。</p>
<p> ······「そうですか。その人は何歳ぐらいですか。」是吗？她（那个人）多大？</p>
</li>
<li><p><strong>そ〜（文脈指示（文章））</strong></p>
<p> <strong>文章中，指前面出现过的事物时，用「そ（それ、その、そこ···）」</strong>。</p>
<p> 例如：</p>
<p> 「会社を出たあと、駅のレストランで夕食を食べました。そのとき、財布を落としたんだと思います。」我出公司之后，在车站的餐厅吃了晚饭。我想是那个时候掉的钱包。</p>
<p> 「イギリスの人気小説が日本語に翻訳されました。それが今年日本でベストセラーになりました。」一本在英国人气火爆的小说被翻译成日语。它成为今年日本最畅销的书。</p>
</li>
<li><p><strong>···んじゃない？</strong></p>
<p> <span style="color: red;">接続：{ { V 普通形 / い A 普通形 } / { な A 普通形（ー<s>だ</s> =&gt; な） / N 普通形（ー<s>だ</s> =&gt; な） } } + [んじゃないですか] / んじゃない？</span></p>
<p> <strong>「···んじゃないですか」是「···のではありませんか」的比较随意的说法。在无需客气的场合，叙述说话人的想法时使用</strong>。</p>
<p> 例如：</p>
<p> 「元気がないですね。何か困っていることがあるんじゃないですか。」你没精神，是不是有什么为难的事情？</p>
<p> ······「ええ、実は······。」是啊，实际上······。</p>
<p> <strong>当「んじゃないですか」用于亲密场合，有时变成「んじゃない」。在需要礼貌的谈话时，用「のではないでしょうか」</strong>。</p>
<p> 例如：</p>
<p> 「ミラーさん、少し太ったんじゃない。」米勒先生，你有点发福了？</p>
<p> ······「わかりますか。」看得出来？</p>
</li>
<li><p><strong>〜たところ { に / で }</strong></p>
<p> <span style="color: red;">接続：V（移动动词）+ た形 + ところ</span></p>
<p> <strong>表示移动的「行く、渡る、曲がる、出る」等动词，用「V（た形） + ところ」等形式，来表示移动后的地点</strong>。</p>
<p> 例如：</p>
<p> 「あの信号を左へ曲がったところに、郵便局があります。」在那个信号灯左转过去的地方，有个邮局。</p>
<p> 「改札を出て、階段を上ったところで、待っていてください。」出检票口，然后走上台阶，请在那里等。</p>
</li>
<li><p><strong>〜（よ）う（意向形） { とする / しない }</strong></p>
<p> <span style="color: red;">接続：V（よ）う + { とする / しない }</span></p>
<ul>
<li><p><strong>「V（よ）う（意向形）とする / しない」表示正准备要做「V する」的动作。但「V する」尚未做。这种用法通常与「〜とき」「〜たら」一起使用</strong>。</p>
<p>  例如：</p>
<p>  「家を出ようとしたとき、電話がかかってきた。」正要出门的时候，有人打电话来了。</p>
<p>  「雨がやんだので、桜を撮ろうとしたら、カメラの電池が切れてしまった。」雨停了，正想拍樱花的时候，相机居然没电了。</p>
</li>
<li><p><strong>另外，有时候也用于表示尽量做到「V する」的场合。</strong></p>
<p>  例如：</p>
<p>  「父は健康のためにタバコをやめようとしています。」为了健康，父亲正设法戒烟。</p>
<p>  「あの日のことは、忘れようとしても忘れることができません。」那天的事情，努力想忘掉却忘不掉。</p>
</li>
<li><p><strong>「V （意向形）としない」表示无意做「V する」。通常用于叙述其他人的事情。</strong></p>
<p>  例如：</p>
<p>  「妻は紅茶が好きで、お茶やコーヒーを飲もうとしない。」妻子喜欢红茶，一点都不想和绿茶和咖啡。</p>
<p>  「人の話を聞こうとしない人は、いつまでたっても自分の考えを変えることができません。」不想听别人意见的人，无论到什么时候都无法改变自己的想法。 </p>
</li>
</ul>
</li>
<li><p><strong>···のだろうか</strong></p>
<p> <span style="color: red;">接続：{ { V 普通形 / い A 普通形 } / { な A 普通形（ー<s>だ</s> =&gt; な） / N 普通形（ー<s>だ</s> =&gt; な） } } + のだろうか</span></p>
<p> <strong>「X のだろうか」用于自问 X 是否正确的场合。和「どう」「なに」「いつ」等疑问词一起使用，也用于自问自答</strong>。</p>
<p> 例如：</p>
<p> 「この店ではクレジットカードが使えるのだろうか。」这家店能用信用卡吗？</p>
<p> 「大学院に入るためには、どうすればいいのだろうか。」为了考进研究生院，怎么办才好呢？</p>
<p> <strong>也用于向听话人提问。与「X のですか」相比，「X のでしょうか」的提问方式较委婉，不强求听话人回答</strong>。</p>
<p> 例如：</p>
<p> 「すみません、この店ではクレジットカードが使えるのでしょうか」。对不起，这家店可以用信用卡吗？</p>
<p> <strong>没有疑问词的「X のだろうか」，也用于表达 X 不正确或认为不是 X 的场合</strong>。</p>
<p> 例如：</p>
<p> 「このクラスでは日本語で話すチャンスがとても少ない。こんな勉強で会話が上手になるのだろうか。」这个班里讲日语的机会很少。靠这样的学习口语能进步吗？</p>
</li>
<li><p><strong>〜との / での / からの / までの / への〜</strong></p>
<p> <span style="color: red;">接続：N + { 格助词 + の } + N</span></p>
<p> <strong>当附着了「と、で、から、まで、へ」等格助词的词汇要修饰名词时，格助词后面可以连接「の」。但「に」后面不能连接「の」。这种时候需要将「に」换成「へ」，变成「への」</strong>。</p>
<p> 例如：</p>
<p> 「友達との北海道旅行は、とても楽しかったです。」和朋友同行的北海道之旅，很快乐。</p>
<p> 「日本での研究はいかがでしたか。」在日本的研究怎么样了？</p>
<p> 「国の両親からの手紙を読んで、泣いてしまった。」看来国内父母的来信，哭了。</p>
<p> 「先生へのお土産は何がいいでしょか。」送老师什么礼物好呢？</p>
<p> <strong>在「が」「を」后面也不连接「の」</strong>。</p>
<p> 例如：</p>
<p> 「田中さんの欠席を部長に伝えてください。」请转告部长田中先生缺席。</p>
<p> 「大学院で医学の研究をするつもりです。」我打算在研究生院从事医学研究。</p>
</li>
<li><p><strong>···だろう / ···だろうと思う（推量）</strong></p>
<p> <span style="color: red;">接続：{ { V 普通形 / い A 普通形 } / { な A 普通形（ー<s>だ</s> =&gt; な） / N 普通形（ー<s>だ</s> =&gt; な） } } + だろう</span></p>
<ul>
<li><p><strong>「···だろう」是「···でしょう」的普通形，用于简体文章。表示说话人对自己的想法不是很肯定，而是一种推测</strong>。</p>
<p>  例如：</p>
<p>  「アジアの経済はこれからますます発展するだろう。」亚洲的经济，从现在起会有更大发展吧。</p>
<p>  「マリアさんの話を聞いて、ご両親もきっとびっくりされただろう。」听了玛丽亚的话，她的父母肯定也会大吃一惊吧。</p>
</li>
<li><p><strong>在会话中用「と思う」、通常也有「···だろうと思う」的形式</strong>。</p>
<p>  例如：</p>
<p>  「鈴木君はいい教師になるだろうと思います。」我想铃木君会成为好老师吧。</p>
<p>  「この実験にはあと２、３週間はかかるだろうと思います。」我想这个实验还需要两三周吧。</p>
<p><span style="color: red;">参考：「〜でしょう？（确认、推量）」（みんなの日本語初級第２１課、みんなの日本語初級第３２課）</span></p>
</li>
</ul>
</li>
<li><p><strong>···から、〜てください</strong></p>
<p> <span style="color: red;">V（礼貌形） + から、V てください</span></p>
<p> <strong>这时的「···から」不表示原因，而是表示后续句中所委托或指示的前提信息</strong>。</p>
<p> 例如：</p>
<p> 「お金を入れるとボタンに電気がつきますから、それを押してください。」一投币按钮就会亮，请按那个按钮。</p>
<p> 「１０分ぐらいで戻ってきますから、ここで待っていてくれますか。」10 分钟就回来，请就在这里等我好吗？</p>
</li>
<li><p><strong>が / の</strong></p>
<p><strong>在定语句中的主语「が」有时可用「の」代替</strong>。</p>
<p>例如：</p>
<p>「留学生 { が / の } かいた絵を見ました。」看了留学生画的画。</p>
<p>「田中さん { が / の } 作ったケーキはとてもおいしかった。」田中先生做的蛋糕很好吃。</p>
</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>日语</category>
      </categories>
      <tags>
        <tag>日语</tag>
        <tag>语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/%E7%AC%94%E8%AE%B0/Redis/</url>
    <content><![CDATA[<h5 id="NoSQL-入门概述"><a href="#NoSQL-入门概述" class="headerlink" title="NoSQL 入门概述"></a>NoSQL 入门概述</h5><ol>
<li><p>为什么要用 NoSQL（发展历程）<a id="more"></a></p>
<ul>
<li><p>单机 MySQL</p>
<p>  90 年代，一个网站的访问量一般都不大，用单个数据库完全可以应付。更多的都是静态网页，动态交互类型的网站不多。</p>
<p>  <img src="image-20191113233529920.png" alt="image-20191113233529920"></p>
<p>  上述架构下，数据存储的瓶颈：</p>
<ol>
<li>数据量的总大小一台机器放不下时</li>
<li>数据的索引（B+Tree）一个机器的内存放不下时</li>
<li>访问量（读写混合）一个实例不能承受</li>
</ol>
</li>
<li><p>Memcached（缓存）+ MySQL + 垂直拆分</p>
<p>  随着访问量的上升，几乎大部分使用 MySQL 架构的网站在数据库上都开始出现了性能问题，Web 程序不再仅仅专注在功能上，同时也在追求性能。开发者们开始大量的使用缓存技术来缓解数据库的压力，优化数据库的结构和索引。开始比较流行的是通过文件缓存来缓解数据库的压力，但是当访问量继续增大的时候，多台 Web 机器通过文件缓存不能共享，大量的小文件缓存也带来了比较高的 I/O 压力。在这个时候，Memcached 就自然的成为了流行的产品。</p>
<p>  <img src="image-20191113234026571.png" alt="image-20191113234026571"></p>
<p>  Memcached 作为一个独立的分布式的缓存服务器，为多个 Web 服务器提供了 一个共享的高性能缓存服务，在 Memcached 服务器上，又发展了根据 hash 算法来进行多台 Memcached 缓存服务的扩展，然后又出现了一致性 hash 来解决增加或减少缓存服务器导致重新 hash 带来的大量缓存失效的弊端。</p>
</li>
<li><p>MySQL 主从读写分离</p>
<p>  由于数据库的写入压力增加，Memcached 只能缓解数据库的读取压力。读写集中在一个数据库上让数据库不堪重负，大部分网站开始使用主从复制技术来达到读写分离，以提高读写性能和读库的可扩展性。MySQL 的 Master-Salver 模式成为这个时候的网站标配</p>
<p>  <img src="image-20191114001036159.png" alt="image-20191114001036159"></p>
</li>
<li><p>分库分表 + 水平拆分 + MySQL 集群</p>
<p>  在 Memcached 的高速缓存，MySQL 的主从复制，读写分离的基础之上，这时 MySQL 主库的写压力开始出现瓶颈，而数据量的持续猛增，由于 MyISAM 使用表锁，在高并发下会出现严重的锁问题，大量的高并发 MySQL 应用开始使用 InnoDB 引擎代替 MyISAM。同时，开始流行使用分库分表来缓解写压力和数据增长的扩展问题。这个时候，分库分表成了一个热门技术，也就在这个时候，MySQL 推出了还不太稳定的表分区。虽然 MySQL 推出了 MySQL Cluster 集群，但性能也不能很好满足互联网的要求，只是在高可靠性上提供了非常大的保证</p>
<p>  <img src="image-20191114084549893.png" alt="image-20191114084549893"></p>
</li>
<li><p>MySQL 的扩展瓶颈</p>
<p>  MySQL 数据库也经常存储一些大文本字段，导致数据库表非常的大，在做数据库恢复的时候就非常的慢，不容易快速恢复数据库。比如 1000w 4KB 大小的文本就接近 40GB 的大小，如果能把这些数据从 MySQL 省去，MySQL 将变得非常的小。关系数据库很强大，但是它并不能很好的应付所有的应用场景。MySQL 的扩展性差（需要复杂的技术来实现），大数据下 I/O 压力大，表结构更改困难，正是当前使用 MySQL 的开发人员面临的问题</p>
</li>
<li><p>目前的架构</p>
<p>  <img src="image-20191114084908654.png" alt="image-20191114084908654"></p>
</li>
<li><p>为什么 NoSQL</p>
<p>  今天我们可以通过第三方平台（如 Google、FaceBook 等）可以很容易的访问和抓取数据。用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加。我们如果要对这些用户数据进行挖掘，那 SQL 数据库已经不适合这些应用了，NoSQL 数据库的发展能很好的处理这些大的数据</p>
<p>  <img src="image-20191114085118332.png" alt="image-20191114085118332"></p>
</li>
</ul>
</li>
</ol>
<hr>
<ol start="2">
<li>NoSQL 是什么<ul>
<li>NoSQL（NoSQL = Not Only SQL），意为 “不仅仅是 SQL”</li>
<li>泛指非关系型的数据库。随着 Web2.0 网站的兴起，传统的关系型数据库在应付 Web2.0 网站，特别是超大规模和高并发的 SNS 类型的 Web2.0 纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL 数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题，包括超大规模数据的存储。例如 Google 或 FaceBook 每天为他们的用户收集万亿比特的数据。这种类型的数据存储不需要固定的模式，无需多余的操作就可以横向扩展</li>
</ul>
</li>
</ol>
<hr>
<ol start="3">
<li>NoSQL 特点<ul>
<li>易扩展。NoSQL 数据库种类繁多，但是一个共同的特点就是都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展，也在无形之间，在架构的层面上带来了可扩展的能力</li>
<li>大数据量高性能。NoSQL 数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单。一般 MySQL 使用 Query Cache，每次表的更新 Cache 就会失效，是一种大粒度的 Cache，在针对 Web2.0 的交互频繁的应用，Cache 性能不高。而 NoSQL 的 Cache 是记录级的，是一种细粒度的 Cache，所以 NoSQL 在这个层面上来说性能就要高很多</li>
<li>多样灵活的数据模型。NoSQL 无须事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库中，增删字段是一件非常麻烦的事。如果是非常大的数据量的表，增加字段简直就是一个噩梦</li>
<li>传统 RDBMS 与 NoSQL 的区别<ol>
<li>RDBMS<ul>
<li>高度组织化结构化数据</li>
<li>结构化查询语言（SQL）</li>
<li>数据和关系都存储在单独的表中</li>
<li>数据操纵语言，数据定义语言</li>
<li>严格的一致性</li>
<li>基础事务</li>
</ul>
</li>
<li>NoSQL<ul>
<li>代表着不仅仅是 SQL</li>
<li>没有声明性查询语言</li>
<li>没有预定义的模式</li>
<li>Key-Value 存储，列存储，文档存储，图形数据库</li>
<li>最终一致性，而非 ACID 性</li>
<li>非结构化和不可预知的数据</li>
<li>CAP 和 BASE</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<hr>
<ol start="4">
<li><p>NoSQL 数据模型简介</p>
<ul>
<li><p>聚合模型</p>
<ul>
<li><p>Key-Value 键值对</p>
</li>
<li><p>BSON（Binary JSON，是一种类 JSON 的一种二进制形式的存储格式，它和 JSON 一样，支持内嵌的文档对象和数据对象）</p>
</li>
<li><p>列族（顾名思义，是按列存储数据的，最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的 I/O 优势）</p>
<p>  <img src="image-20191114091250370.png" alt="image-20191114091250370"></p>
</li>
<li><p>图形</p>
<p>  <img src="Redis/image-20191114091327132.png" alt="image-20191114091327132"></p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<ol start="5">
<li><p>NoSQL 数据库的四大分类</p>
<ul>
<li><p>Key-Value 键值对：BerkeleyDB、Redis、Tair、Memcache</p>
</li>
<li><p>文档型数据库（BSON 格式较多）：CouchDB、MongoDB</p>
</li>
<li><p>列存储数据库：Cassandra、HBase、分布式文件系统</p>
</li>
<li><p>图关系数据库：Neo4J、InfoGrid（应用于社交网络、推荐系统等，专注于构建关系图谱）</p>
</li>
<li><p>四者对比</p>
<p>  <img src="image-20191114091705816.png" alt="image-20191114091705816"></p>
</li>
</ul>
</li>
</ol>
<hr>
<ol start="6">
<li><p>分布式数据库中 CAP 原理 + BASE</p>
<ul>
<li><p>传统的 ACID。关系型数据库遵循 ACID 原则</p>
<ul>
<li>A（Atomicity）原子性。原子性指的是一个事务中的所有操作要么全部完成，要么全部都放弃，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，那么整个事务就会失败，这时需要回滚。比如银行转账，从 A 账户转 100 元到 B 账户，分为两个步骤：① 从 A 账户中取 100 元；② 存入至 B 账户。这两步要么全部一起完成，要么都失败，如果只完成第一步，第二步失败，钱就会莫名其妙的少了 100 元</li>
<li>C（Consistency）一致性。一致性是指数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束</li>
<li>I（Isolation）独立性。独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。比如有个交易是从 A 账户转 100 元至 B 账户，在这个交易还未完成的情况下，如果此时 B 查询自己的账户，是看不到新增加的 100 元的</li>
<li>D（Durability）持久性。持久性是指事务一旦提交后，它所做的修改将会永久保存在数据库上，即使出现宕机也不会丢失</li>
</ul>
</li>
<li><p>CAP 原理</p>
<ul>
<li>C（Consistency）强一致性</li>
<li>A（Availability）可用性</li>
<li>P（Partition Tolerance）分区容错性</li>
</ul>
</li>
<li><p>CAP 的三选二。CAP 原理是指在分布式存储系统中，最多只能实现 CAP 中的两个。而由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容错性是必须要实现的。故只能在一致性和可用性之间进行权衡，没有 NoSQL 系统能同时保证 CAP 三点。</p>
<ul>
<li><p>CA：保证强一致性和高可用性。传统 Oracle 数据库</p>
</li>
<li><p>AP：保证高可用性和分区容错性。大多数网站架构的选择</p>
</li>
<li><p>CP：保证强一致性和分区容错性。Redis、Mongodb</p>
<p>注：建立分布式架构时必须做出取舍。一致性和可用性之间取一个平衡。大多数 Web 应用其实并不需要强一致性。因此可以选择牺牲强一致性换取分区容错性</p>
</li>
</ul>
</li>
<li><p>经典 CAP 图。CAP 原理的核心是：一个分布式系统不可能同时很好的满足一致性、可用性和分区容错性这三个需求，最多只能同时较好的满足其中的两个。因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三大类</p>
<ul>
<li><p>CA：单点集群，满足一致性、可用性的系统。通常在可扩展性上不强</p>
</li>
<li><p>CP：满足一致性、分区容错性的系统。通常性能不是特别好</p>
</li>
<li><p>AP：满足可用性、分区容错性的系统，通常对一致性的要求较低</p>
<p>  <img src="image-20191114093622639.png" alt="image-20191114093622639"></p>
</li>
</ul>
</li>
<li><p>BASE。BASE 就是为了解决关系数据库强一致性引起的可用性降低而提出的解决方案。它的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上的改观。原因在于大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这些指标，要想获得这些指标，我们必须采用另外一种方式来完成。这里 BASE 就是解决这个问题的办法</p>
<ul>
<li>Basically Available：基本可用</li>
<li>Soft State：软状态</li>
<li>Eventually Consistent：最终一致</li>
</ul>
</li>
<li><p>分布式 + 集群简介</p>
<ul>
<li>分布式系统（Distributed System）：由多台计算机和通信的软件组件通过计算机网络连接（本地网络或广域网）组成。分布式系统是建立在网络之上的软件系统。正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性。因此，网络和分布式系统之间的区别更多的在于高层软件（特别是操作系统），而不是硬件。分布式系统可以应用在不同的平台上，如 PC、工作中、局域网和广域网上等。简单来讲，分布式就是不同的多台服务器上面部署不同的服务模块（工程），它们之间通过 RPC/RMI 来通信和调用，对外提供服务和组内协作</li>
<li>集群：不同的多台服务器上面部署相同的服务模块，通过分布式调度软件进行统一的调度，对外提供服务和访问</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h5 id="Redis-入门介绍"><a href="#Redis-入门介绍" class="headerlink" title="Redis 入门介绍"></a>Redis 入门介绍</h5><ol>
<li>Redis 是什么<ul>
<li><a href="https://redis.io/">Redis</a>：Remote Dictionary Server（远程字典服务器）。完全开源免费的，用 C 语言编写的，遵守 BSD 协议，是一个高性能的（Key-Value）分布式内存数据库，基于内存运行，并支持持久化的 NoSQL 数据库，是当前最热门的 NoSQL 数据库之一，也被称为数据结构服务器</li>
<li>Redis 支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载</li>
<li>Redis 不仅仅支持简单的 Key-Value 类型的数据，同时还提供 List、Set、ZSet、Hash 等数据结构的存储</li>
<li>Redis 支持数据的备份，即 Master-Slave 模式的数据备份</li>
</ul>
</li>
</ol>
<hr>
<ol start="2">
<li>Redis 的作用<ul>
<li>内存存储和持久化：Redis 支持异步将内存中的数据写到硬盘上，同时不影响继续服务</li>
<li>取最新 N 个数据的操作，如可以将最新的 10 条评论的 ID 放在 Redis 的 List 集合中</li>
<li>模拟类似于 HttpSession 这种需要设定过期时间的功能</li>
<li>发布-订阅模式</li>
<li>定时器、计数器</li>
</ul>
</li>
</ol>
<hr>
<ol start="3">
<li>Redis 的安装（以 5.0.6 版本为例，详细可以进官网看）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 建议先进入 /opt 目录再进行下载</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或是手动下载再将文件移入 /opt 目录进行解压</span></span><br><span class="line">wget http://download.redis.io/releases/redis-5.0.6.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">tar -zxvf redis-5.0.6.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入解压目录</span></span><br><span class="line">cd redis-5.0.6</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译(需要安装 GCC)</span></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注：出现 Jemalloc/jemalloc.h: 没有那个文件或目录错误时, </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行 make distclean 再 make</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译完成后执行安装</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>默认安装目录为：/usr/local/bin</p>
<ul>
<li>redis-benchmark：性能测试工具（在 Redis 服务启动后执行）</li>
<li>redis-check-aof：修复格式不正确的 AOF 文件</li>
<li>redis-check-rdb：修复格式不正确的 dump.rdb 文件（老版本叫 redis-check-dump）</li>
<li>redis-cli：客户端操作入口</li>
<li>redis-server：Redis 服务器启动命令</li>
<li>redis-sentinel：Redis 集群使用（哨兵模式）</li>
</ul>
<hr>
<ol start="4">
<li>Redis 启动<ul>
<li>复制一份 redis.conf 到自定义目录</li>
<li>将复制出来的 redis.conf 中的 <code>daemonize no</code> 改为 <code>yes</code>，让 redis 服务在后台启动</li>
<li>使用 <code>redis-server /自定义目录路径/redis.conf</code>命令来启动 Redis 服务器</li>
<li>使用 <code>redis-cli -h IP 地址 -p 端口 -a 密码</code> 来连接至刚刚启动的 Redis 服务器。连接成功后进行 <code>ping</code> 测试（成功会返回 PONG）</li>
<li>在 redis-cli 中使用 <code>SHUTDOWN</code> 命令即可关闭 Redis 服务器。可以通过 <code>ps -ef|grep redis</code> 查询后台是否还有 Redis 服务在运行。单实例关闭：<code>redis-cli SHUTDOWN</code> 。多实例关闭需要指定端口号：<code>redis-cli -p 6379 SHUTDOWN</code></li>
<li>Redis 是单进程的（多进程版本目前已经在规划当中）。单进程模型来处理客户端的请求，对读写事件的响应是通过 epoll 函数的包装来做到的。Redis 的实际处理速度完全依靠主进程的执行效率。Epoll 是 Linux 内核为处理大批量文件描述符而做了改进的 epoll，是 Linux 下多路复用 I/O 接口 select/poll 的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率</li>
<li>Redis 默认有 16 个数据库（见 redis.conf 配置文件中 <code>database 16</code>）。类似数字下标从 0 开始，初始默认使用 0 号库。可以使用 <code>SELECT &lt;dbid&gt;</code> 命令在连接上切换数据库</li>
<li><code>DBSIZE</code> 命令查看当前数据库 Key 的数量</li>
<li><code>FLUSHDB</code> 命令清空当前数据库</li>
<li><code>FLUSHALL</code> 命令清空所有数据库</li>
<li>统一密码管理。16 个数据库都是同样的密码，要么都能连接上，要么一个都连接不上</li>
<li>Redis 索引都是从 0 开始</li>
<li>默认端口为 6379 原因（MERZ）</li>
</ul>
</li>
</ol>
<hr>
<h5 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h5><ol>
<li><p>Redis 五大数据类型</p>
<ul>
<li>String：字符串。String 是 Redis 最基本的数据类型，可以理解成于 Memcached 一模一样的类型，一个 Key 对应一个 Value。String 类型是二进制安全的，意思是 Redis 的 String 可以包含任何数据，比如 JPG 格式的图片或者序列化的对象。一个 Redis String 中 Value 最多可以是 512M</li>
<li>Hash：Redis Hash 是一个键值对的集合。它是一个 String 类型的 field 和 value 的映射表，Hash 特别适合存储对象。类似于 Java 中的 Map&lt;String, Object&gt;</li>
<li>List：Redis List 是最简单的字符串列表，按照插入顺序排序。可以添加一个元素至列表的表头（左边）或者尾部（右边）。底层是一个链表</li>
<li>Set：Redis Set 是 String 类型的无序集合。通过 HashTable 实现</li>
<li>Zset(Sorted Set)：Redis Sored Set 与 Set 一样也是 String 类型元素的集合，且不允许有重复的成员。与 Set 不同的是，每个元素都会关联一个 Double 类型的分数。Redis 通过分数来为集合中的成员进行从小到大的排序。Sorted Set 的成员是唯一的，但是分数却是可以重复的</li>
</ul>
</li>
<li><p><a href="https://redis.io/commands#generic">Redis 键（Key）常用命令</a></p>
</li>
</ol>
<ul>
<li><code>KEYS pattern</code> ：查找所有符合给定模式（pattern）的 Key。常用 <code>KEYS *</code><ul>
<li><code>EXISTS key</code> ：判断某个 Key 是否存在</li>
<li><code>MOVE key db</code> ：将当前数据库的 Key 移动到给定的数据库 db 中</li>
<li><code>EXPIRE key seconds</code> ：为给定 Key 设置过期时间</li>
<li><code>TTL key</code> ：以秒为单位返回 Key 的剩余过期时间。-1 表示永不过期，-2 表示已过期</li>
<li><code>TYPE key</code> ：返回 Key 所存储的值的类型</li>
</ul>
</li>
</ul>
<ol start="3">
<li><p><a href="https://redis.io/commands#string">Redis 字符串（String）常用命令（注：单值单 value）</a></p>
<ul>
<li><code>SET/GET/DEL/APPEND/STRLEN</code></li>
<li><code>INCR/DECR/INCRBY/DECRBY</code> （一定要是数字才能进行加减）</li>
<li><code>GETRANGE/SETRANGE</code> ：<code>GETRANGE</code> 表示获取指定区间范围内的值，类似 <code>BETWEEN...AND</code> 的关系。从 0 到 -1 表示全部。<code>SETRANGE</code> 设置指定区间范围内的值，格式是 <code>SETRANGE key offset value</code> （用 value 参数覆写给定 key 所存储的字符串值，从偏移量 offset 开始）</li>
<li><code>SETEX(set with expire) 键秒值/SETNX(set if not exist)</code> ：<code>SETEX key seconds value</code> 将值 value 关联到 key，并将 key 的过期时间设为 seconds（以秒为单位）。<code>SETNX key value</code> 只有在 key 不存在时设置 key 的值</li>
<li><code>MSET/MGET/MSETNX</code> ：M 表示 more，多个，其他与 <code>SET/GET/SETNX</code> 一致</li>
<li><code>GETSET key value</code> ：将给定的 key 值设为 value，然后返回 key 的旧值（old value）</li>
</ul>
</li>
<li><p><a href="https://redis.io/commands#list">Redis 列表（List）常用命令（注：单值多 value）</a></p>
<ul>
<li><code>LPUSH/RPUSH/LRANGE</code> ：<code>LRANGE key start stop</code> 获取列表指定范围内的元素</li>
<li><code>LPOP/RPOP key</code> ：弹出并获取列表的第一个元素/最后一个元素</li>
<li><code>LINDEX key index</code> ：通过 index 获取列表中的元素</li>
<li><code>LLEN key</code> ：获取列表长度</li>
<li><code>LREM key count value</code> ：弹出列表元素</li>
<li><code>LTRIM key start stop</code> ：对一个列表进行 trim，让列表只保留指定区间内的元素，不在指定区间内的元素都将被删除</li>
<li><code>RPOPLPUSH source destination</code> ：弹出列表中的最后一个元素，并将该元素添加到另一个列表并返回</li>
<li><code>LSET key index value</code> ：通过 index 设定列表元素的值</li>
<li><code>LINSERT key BEFORE/AFTER value1 value2</code> ：在列表的元素前或者元素后插入元素</li>
<li>List 是一个字符串链表，Left、Right 都可以插入添加。如果键不存在，创建新的链表。如果键已存在，新增内容。如果键全移除，对应的键也就消失了。链表的操作无论头尾都效率极高，而中间元素的操作效率就很低</li>
</ul>
</li>
<li><p><a href="https://redis.io/commands#set">Redis 集合（Set）常用命令（注：单值多 value）</a></p>
<ul>
<li><code>SADD/SMEMBERS/SISMEMBER</code> ：见官方文档</li>
<li><code>SCARD key</code> ：获取集合的成员数</li>
<li><code>SREM key member1 member2</code> ：移除集合中一个或多个成员</li>
<li><code>SRANDMEMBER key [count]</code> ：返回集合中一个或多个随机数</li>
<li><code>SPOP key</code> ：移除并返回集合中一个随机元素</li>
<li><code>SMOVE source destination member</code> ：将 member 元素从 source 集合移动到 destination 集合</li>
<li><code>SDIFF</code> ：差集</li>
<li><code>SINTER</code> ：交集</li>
<li><code>SUNION</code> ： 并集</li>
</ul>
</li>
<li><p><a href="https://redis.io/commands#hash">Redis 哈希（Hash）常用命令（注：KV 模式不变，但 V 是一个键值对）</a></p>
<ul>
<li><code>HSET/HGET/HMSET/HMGET/HGETALL/HDEL</code> ：见官方文档</li>
<li><code>HLEN key</code> ：获取 Hash 表中字段数量</li>
<li><code>HEXISTS key field</code> ：查看 Hash 表中 key，指定的字段是否存在</li>
<li><code>HKEYS/HVALS key</code> ：获取 Hash 表中所有字段/获取 Hash 表中所有值</li>
<li><code>HINCRBY/HINCRBYFLOAT key field increment</code> ：为 Hash 表中 key 中的指定字段的整数值/浮点值加上增量 increment</li>
<li><code>HSETNX key field value</code> ：只有当字段 field 不存在时，才会设定 Hash 表字段的值</li>
</ul>
</li>
<li><p><a href="https://redis.io/commands#sorted_set">Redis 有序集合（ZSet/Sorted Set）常用命令</a></p>
<ul>
<li><code>ZADD key score1 member1 [score2 member2]</code> ：向有序集合添加一个或多个成员，或者更新已存在成员的分数</li>
<li><code>ZRANGE key start stop [WITHSCORES]</code> ：通过索引区间返回有序集合指定区间内的成员</li>
<li><code>ZRANGEBYSCORE key start stop [WITHSCORES] [LIMIT]</code> ：<code>(</code> 表示不包含; <code>Limit</code> 是返回限制。通过分数返回有序集合指定区间内的成员</li>
<li><code>ZREM key member [member...]</code> ：移除有序集合中的一个或多个成员</li>
<li><code>ZCARD key/ZCOUNT key min max</code> ：<code>ZCARD</code> 获取有序集合的成员数；<code>ZCOUNT</code> 计算在有序集合中指定区间分数的成员数</li>
<li><code>ZRANK key member</code> ：返回有序集合中指定成员的索引</li>
<li><code>ZSCORE key member</code> ：返回有序集合中，成员的分数值</li>
<li><code>ZREVRANK key member</code> ：返回有序集合中指定成员的排名，有序集成员按分数值递减（从大到小）排序</li>
<li><code>ZREVRANGE key start stop [WITHSCORES]</code> ：返回有序集中指定区间内的成员，通过索引，分数从高到底</li>
<li><code>ZREVRANGEBYSCORE key max min</code> ：返回有序集中指定分数区间内的成员，分数从高到低排序</li>
</ul>
</li>
</ol>
<h5 id="Redis-配置文件-redis-conf"><a href="#Redis-配置文件-redis-conf" class="headerlink" title="Redis 配置文件(redis.conf)"></a>Redis 配置文件(redis.conf)</h5><ol>
<li>配置文件位置：在运行 <code>make</code> 命令的文件夹中，与 src 目录同级</li>
</ol>
<hr>
<ol start="2">
<li>Units：配置文件开头定义了一些基本的度量单位，只支持 bytes，不支持 bit，并且对大小写不敏感</li>
</ol>
<hr>
<ol start="3">
<li>INCLUDES：可以通过 include 导入其他配置文件，redis.conf 作为总的</li>
</ol>
<hr>
<ol start="4">
<li>GENERAL<ul>
<li>daemonize：是否作为守护进程启动，默认为 no</li>
<li>pidfile：指定 pid 文件名，daemonize 为 yes 时，会把 pid 写入 pidfile，默认为 <code>/var/run/redis.pid</code></li>
<li>port：指定 Redis 监听端口，默认为 6379</li>
<li>tcp-backlog：设置 tcp 的 backlog，backlog 其实是一个连接队列，backlog 队列总和 = 未完成三次握手队列 + 已经完成三次握手队列。在高并发环境下需要一个高 backlog 值来避免慢客户端连接问题。注意 Linux 内核会将这个值减小到 <code>/proc/sys/net/core/somaxconn</code> 的值，所以需要确保提高 somaxconn 和 tcp_max_syn_backlog 两个值来达到想要的效果</li>
<li>timeout：当客户端闲置多长时间后关闭连接，如果指定为 0，表示关闭该功能，永不超时</li>
<li>bind：绑定的主机地址，默认为 127.0.0.1。若不绑定任何主机地址，Redis 会监听任何可用连接</li>
<li>tcp-keepalive：检测已连接的客户端是否存活，默认为 300，单位秒。若为 0 则不会进行存活检测。建议设置为 60</li>
<li>loglevel：指定日志级别，默认为 notice。Redis 中有四个日志级别：debug、verbose、notice、warning</li>
<li>logfile：指定日志文件名，默认为 standard output（即设置空字符串），若 logfile 指定为标准输出，而 Redis 又是以守护进程的方式启动，则日志会被发送至 <code>/dev/null</code></li>
<li>syslog-enabled：是否把日志输出到 syslog 中，默认为 no</li>
<li>syslog-ident：指定 syslog 中的日志标志，默认为 redis</li>
<li>syslog-facility：指定 syslog 设备，值必须是 USER 或 LOCAL0 - LOCAL7</li>
<li>databases：数据库数量，默认为 16 个</li>
<li>protected-mode：是否启用保护模式，默认为 yes。若启用保护模式，则 Redis 只接受来自 bind 指令绑定 ip 的连接请求，如果 bind 指令未明确指定 ip，且认证密码也未配置，则只接受来自 127.0.0.1 和 localhost 的连接请求</li>
</ul>
</li>
</ol>
<hr>
<ol start="5">
<li>SNAPSHOTTING<ul>
<li>save：默认有三组：<code>save 900 1</code> 、<code>save 300 5</code> 、<code>save 60 10000</code>。格式为 save &lt;seconds&gt; &lt;changes&gt;，默认的配置意思为：15 分钟内修改了 1 次、5 分钟内修改了 10 次、1 分钟内修改了 10000 次，满足上述条件之一就会触发 RDB 备份。若不想使用 RDB 备份，则可以将所有的 save 指令注释掉，或者改为 <code>save “”</code> ，即传入一个空字符串</li>
<li>stop-writes-on-bgsave-error：默认为 yes。若配置为 no，表示你不在乎数据的一致性或者有其他的手段发现数据的不一致并控制数据的一致性</li>
<li>rdbcompression：默认为 yes。表示是否启用对 RDB 的压缩存储，默认会采用 LZF 算法进行压缩。若不想消耗 CPU 资源来进行压缩，可以将其关闭（但会消耗硬盘空间）。</li>
<li>rdbchecksum：默认为 yes。表示在存储 RDB 快照后，是否启用 CRC64 算法来进行数据校验，这么做会增加大约 10% 的性能损耗，若希望有较大的性能提升，可以关闭数据校验</li>
<li>dbfilename：默认为 <code>dump.rdb</code>。RDB 快照名</li>
<li>dir：默认为当前配置文件所在位置。RDB 快照存储位置</li>
</ul>
</li>
</ol>
<hr>
<ol start="6">
<li>SECURITY<ul>
<li>requirepass：配置访问密码，默认是注释掉的。因为 Redis 认为大多数的 Redis 服务器并不是暴露在外网下的，所以不存在安全问题。若启用了该项并设置了密码，那么在首次连接上 Redis 服务器时需要通过 <code>AUTH &lt;PASSWORD&gt;</code> 来认证才能使用一系列命令</li>
<li>rename-command：重命名命令。可以通过这个指令来将命令重命名，就算认证密码被破解，也无法对 Redis 服务器造成实质性伤害。也可以直接配置空字符串将这个命令禁用。但是更改记录到 AOF 文件的命令和主从复制相关命令的名称可能会出问题</li>
</ul>
</li>
</ol>
<hr>
<ol start="7">
<li>LIMITS<ul>
<li>maxclients：设置同时连接的最大客户端数量。默认为 10000，若已经达到 maxclients 设定的值后还有客户端要连入，则 Redis 会抛出一个 “max number of clients reached” 的错误信息。若 Redis 服务器无法配置进程文件句柄限制时，会将 maxclients 的值设为当前进程文件句柄值减 32 ，因为 Redis 得为自身内部逻辑预留出一些来使用</li>
<li>maxmemory：设置 Redis 可用的内存量（单位为 bytes），一旦达到内存使用上限，Redis 会尝试移除一些数据，移除规则通过 maxmeory-policy 来指定。如果 Redis 无法根据移除规则来移除内存中的数据，或者移除规则设定为 <code>noeviction</code> ，那么 Redis 会针对那些需要申请内存的命令返回错误信息，如 SET、LPUSH 等。但是对于无内存申请的指令，仍然会正常响应，如 GET 等。建议为身份为 Master 的 Redis 服务器（说明它有 Slave）设置内存使用上限时预留出一些内存空间给同步队列缓存，只有在设置移除规则为 <code>noeviction</code> 时才不用考虑这个因素</li>
<li>maxmemory-policy：到达内存上限时采取的移除策略。默认使用 <code>noeviction</code><ul>
<li>volatile-lru：针对设置了过期时间的 key 使用 LRU 算法进行移除</li>
<li>allkeys-lru：使用 LRU 算法移除所有的 key</li>
<li>volatile-lfu：针对设置了过期时间的 key 使用 LFU 算法进行移除</li>
<li>allkeys-lfu：使用 LFU 算法移除所有的 key</li>
<li>volatile-random：随机移除设置了过期时间的 key</li>
<li>allkeys-random：移除随机的 key</li>
<li>volatile-ttl：移除那些 TTL 值最小的 key，即最近要过期的 key</li>
<li>noecivtion：不移除任何 key，对任何写操作返回错误信息</li>
</ul>
</li>
<li>maxmemory-samples：设置样本数量，LRU、LFU、TTL 都不是精确的算法，而是估算值。默认样本数量为 5，可用得出较好的结果；若设为 10 则会非常接近真正的 LRU/LFU 但是会消耗更多的 CPU 资源；若设为 3 则会很快但是结果不会很精确</li>
</ul>
</li>
</ol>
<hr>
<ol start="8">
<li>APPEND ONLY MODE<ul>
<li>appendonly：是否开启 AOF，默认为 no</li>
<li>appendfilename：AOF 文件名，默认为 <code>appendonly.aof</code></li>
<li>appendfsync：持久化同步模式。默认为 <code>everysec</code><ul>
<li>always：每次发生数据变更都会立即记录到硬盘，性能较差但数据完整性较好（慢但最安全）</li>
<li>everysec：每秒同步一次，异步操作，如果一秒内宕机，会有数据丢失（但是恢复很容易）（折中）</li>
<li>no：表示等操作系统将数据缓存同步到硬盘（快）</li>
</ul>
</li>
<li>no-appendfsync-on-rewrite：重写时是否可以使用 appendfsync，使用默认的 no 即可，保证数据的安全性</li>
<li>auto-aof-rewrite-min-size：设置重写的基准值。详细机制见持久化中的 Rewrite 部分</li>
<li>auto-aof-rewrite-percentage：设置重写的基准百分比。当 AOF 日志文件大小到指定的百分比时，Redis 会自动进行重写。这个值指定为 0 时则会禁用自动重写机制。详细机制见持久化中的 Rewrite 部分</li>
</ul>
</li>
</ol>
<hr>
<ol start="9">
<li><p>常用的 redis.conf 配置</p>
<ul>
<li><p>daemonize no</p>
<p>  Redis 默认不是以守护进程的方式运行，可以通过修改该配置项启用守护进程</p>
</li>
<li><p>pidfile /var/run/redis.pid</p>
<p>  当 Redis 以守护进程方式运行时，Redis 默认会把 pid 写入 /var/run/redis.pid 文件，可以通过 pidfile 指定</p>
</li>
<li><p>port 6379</p>
<p>  指定 Redis 监听端口，默认为 6379</p>
</li>
<li><p>bind 127.0.0.1</p>
<p>  绑定的主机地址</p>
</li>
<li><p>timeout 300</p>
<p>  当客户端闲置多长时间后关闭连接，如果指定为 0，表示永不超时</p>
</li>
<li><p>loglevel notice</p>
<p>  指定日志级别，Redis 支持四个日志级别：debug、verbose、notice、warning 等。默认为 notice</p>
</li>
<li><p>logfile “”</p>
<p>  指定日志记录方式，为空字符串则表示使用 standard out。若 Redis 为守护进程方式运行，而这里又配置日志记录方式为 standard out，那么日志将会发送至 /dev/null</p>
</li>
<li><p>databases 16</p>
<p>  设置数据库的数量，默认数据库数量为 16 个，默认数据库为 0，可以使用  <code>SELECT &lt;dbid&gt;</code> 命令在连接上指定数据库 id</p>
</li>
<li><p>save &lt;seconds&gt; &lt;changes&gt;</p>
<p>  指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合。Redis 配置文件中提供了三个条件：</p>
<p>  save 900 1</p>
<p>  save 300 10</p>
<p>  save 60 10000</p>
<p>  分别表示 900 秒（15分钟）内有 1 个更改，300 秒（5 分钟）内有 10 个更改以及 60 秒内有 10000 个更改</p>
</li>
<li><p>rdbcompression yes</p>
<p> 指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 算法压缩，如果为了节省 CPU 资源，可以关闭该选项，但会导致数据库文件变得巨大</p>
</li>
<li><p>defilename “dump.rdb”</p>
<p>  指定本地数据库文件名，默认值为 dump.rdb</p>
</li>
<li><p>dir ./</p>
<p>  指定本地数据库存放目录</p>
</li>
<li><p>salveof &lt;masterip&gt; &lt;masterport&gt;</p>
<p>  设置当本机为 Slave 时，设置 Master 的 IP 地址和端口，在 Redis 启动时，它会自动从 Master 进行数据同步</p>
</li>
<li><p>masterauth &lt;master-password&gt;</p>
<p>  当 Master 设置了认证密码时，Slave 连接至 Master 的密码</p>
</li>
<li><p>requirepass foobared</p>
<p>  设置 Redis 认证密码，默认关闭。如果设置了认证密码，客户端在连接至 Redis 服务器时需要通过 <code>AUTH &lt;password&gt;</code> 命令提供认证密码</p>
</li>
<li><p>maxclients 128</p>
<p>  设置同一时间最大客户端连接数，默认为 10000，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，如果设置 maxclients 0 则表示不做限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回  “max number of clients reached” 错误信息</p>
</li>
<li><p>maxmemory &lt;bytes&gt;</p>
<p>  指定 Redis 最大内存限制，Redis 在启动时会把数据加载至内存中，达到最大内存后，Redis 会尝试清除已过期或即将过期的 Key，当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 放在内存，Value 存放在 swap 区</p>
</li>
<li><p>appendonly no</p>
<p>  指定是否在每次更新操作后进行日志记录，Redis 在默认情况下是异步将数据写入硬盘，如果不开启，可能会在突然断电时导致一段时间内的数据丢失。因为 Redis 本身同步数据文件是根据 save 条件来同步的，所有有的数据会在一段时间内只存在于内存中。默认为 no</p>
</li>
<li><p>appendfilename “appendonly.aof”</p>
<p>  指定更新日志文件名，默认为 “appendonly.aof”</p>
</li>
<li><p>appendfsync everysec</p>
<p>  指定更新日志条件，共有三个可选值：</p>
<p>  no：表示等操作系统将数据缓存同步到硬盘（快）</p>
<p>  always：表示每次更新操作后手动调用 fsync() 将数据写入到硬盘（慢，安全）</p>
<p>  everysec：表示每秒同步一次（折中，默认值）</p>
</li>
<li><p>vm-enable no</p>
<p>  指定是否启用虚拟内存机制，默认为 no。VM 机制将数据分页存放，由 Redis 将访问量较少的页即冷数据 swap 到硬盘上，访问较多的页由硬盘自动 swap 到内存中</p>
</li>
<li><p>vm-swap-file /tmp/redis.swap</p>
<p>  虚拟内存文件路径，默认为 /tmp/redis.swap，不可多个 Redis 实例共享</p>
</li>
<li><p>vm-max-memory 0</p>
<p>  将所有大于 vm-max-memory 的数据存入虚拟内存，无论 vm-max-memory 设置多小，所有索引数据都是内存存储的（Redis 的索引数据就是 Keys），也就是说，当 vm-max-memory 设置为 0 时，其实是所有的 Value 都存在硬盘中，默认为 0</p>
</li>
<li><p>vm-page-size 32</p>
<p>  Redis swap 文件分成了很多的 page，一个对象可以保存在多个 page 上面，但一个 page 上不能被多个对象共享，vm-page-size 是要根据存储的数据大小来设定的，作者建议如果要存储很多小对象，page 大小最好设置为 32 或 64 bytes；如果存储很大的对象，则可以使用更大的 page，如果不确定，就使用默认值</p>
</li>
<li><p>vm-pages 134517728</p>
<p>  设置 swap 文件中的 page 数量，由于页表（一种表示页面空闲或使用的 bitmap）是放在内存中的，在硬盘上每 8 个 pages 将消耗 1 bytes 的内存</p>
</li>
<li><p>vm-max-threads 4</p>
<p>  设置访问 swap 文件的线程数，最好不要超过机器的核心数，如果设置为 0，那么所有的 swap 文件的操作都是串行的，可能会造成比较长时间的延迟。默认为 4</p>
</li>
<li><p>glueoutputbuf yes</p>
<p>  设置在向客户端应答时，是否把较小的包合并为一个包发送，默认开启</p>
</li>
<li><p>hash-max-zipmap-entries 64</p>
<p>  指定在超过一定数量或者最大的元素超过某一临界值时，采用一种特殊的 Hash 算法</p>
</li>
<li><p>hash-max-zipmap-value 512</p>
<p>  同上</p>
</li>
<li><p>activerehashing yes</p>
<p>  指定是否激活重置 Hash，默认为开启</p>
</li>
<li><p>include /path/to/local.conf</p>
<p>  指定包含其他的配置文件，可以在同一主机上多个 Redis 实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</p>
</li>
</ul>
</li>
</ol>
<hr>
<h5 id="Redis-的持久化"><a href="#Redis-的持久化" class="headerlink" title="Redis 的持久化"></a>Redis 的持久化</h5><ol>
<li><p>RDB(Redis Database)：在指定的时间间隔内将内存中的数据集快照写入硬盘，也就是 SnapShot 快照。它恢复时是将快照文件直接读入内存中。Redis 会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件代替上次持久化好的文件。整个过程中，主进程是不进行任何 I/O 操作的，这就确保了极高的性能。如果需要进行大规模的数据恢复，且对于数据恢复的完整性不是很敏感，那 RDB 方式要比 AOF 方式更加的高效。RDB 的缺点是最后一次持久化后的数据可能会丢失</p>
<ul>
<li><p>Fork：Fork 的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</p>
</li>
<li><p>RDB 保存的是 dump.rdb 文件</p>
</li>
<li><p>配置位置：redis.conf 中的 SNAPSHOTTING 部分</p>
</li>
<li><p>如何触发 RDB 快照</p>
<ul>
<li>在客户端做的操作达到配置文件中 SNAPSHOTTING 部分的条件</li>
<li>命令 <code>save</code> 或者 <code>bgsave</code>。<code>save</code> 只管保存，其他的不管，全部阻塞。<code>bgsave</code> 会让 Redis 在后台异步进行快照保存操作，执行期间还可以响应客户端请求，可以通过 <code>lastsave</code> 命令获取最后一次成功执行快照的时间</li>
<li>执行 <code>flushall</code> 命令也会产生 dump.rdb 文件，但里面是空的，无意义</li>
</ul>
</li>
<li><p>如何恢复</p>
<ul>
<li>将备份文件 dump.rdb 移动到 redis 安装目录并启动服务即可</li>
<li><code>CONFIG GET dir</code> 获取目录</li>
</ul>
</li>
<li><p>RDB 优点</p>
<ul>
<li>适合大规模的数据恢复</li>
<li>对数据完整性和一致性要求不高</li>
</ul>
</li>
<li><p>RDB 缺点</p>
<ul>
<li>在一定间隔时间做一次备份，所以如果 Redis 在这期间意外宕机，就会丢失掉最后一次快照后的所有修改</li>
<li>Fork 的时候，内存中的数据被克隆了一份，大约 2 倍的膨胀性需要考虑</li>
</ul>
</li>
<li><p>如何停止</p>
<ul>
<li>动态停止所有 RDB 保存规则的方法：<code>redis-cli config set save “”</code></li>
</ul>
</li>
<li><p>总结</p>
<p>  <img src="image-20191114200004837.png" alt="image-20191114200004837"></p>
</li>
</ul>
</li>
</ol>
<hr>
<ol start="2">
<li><p>AOF(Append Only File)：以日志的形式来记录每个写操作，将 Redis 执行过的所有写指令记录下来（读操作不记录），只许追加文件但不许改写文件，Redis 启动之初会读取该文件重新构建数据，换句话说，Redis 重启的话就根据日志文件的内容将写命令从前到后执行一次以完成数据的恢复工作</p>
<ul>
<li><p>AOF 保存的是 appendonly.aof 文件</p>
</li>
<li><p>配置位置：redis.conf 中的 APPEND ONLY MODE 部分</p>
</li>
<li><p>AOF 启动/修复/恢复</p>
<ul>
<li>正常恢复<ul>
<li>启动：将默认的 appendonly no 改为 yes</li>
<li>将有数据的 AOF 文件复制一份保存到对应目录（<code>config get dir</code>）</li>
<li>恢复：重启 Redis 然后重新加载</li>
</ul>
</li>
<li>异常恢复<ul>
<li>启动：将默认的 appendonly no 改为 yes</li>
<li>备份被写坏的 AOF 文件</li>
<li>修复：<code>redis-check-aof --fix AOF文件名</code> 进行修复</li>
<li>恢复：重启 Redis 然后重新加载</li>
</ul>
</li>
</ul>
</li>
<li><p>Rewrite：AOF 采用文件追加方式，文件必然会越来越大，为了避免出现这种情况，新增了重写机制。当 AOF 文件的大小超过所设定的阈值时，Redis 就会启动 AOF 文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令 <code>bgrewriteaof</code></p>
<ul>
<li>重写原理：AOF 文件持续增长而过大时，会 Fork 出一条新进程来将文件重写（也是先写临时文件最后再 rename），遍历新进程的内存中数据，每条记录有一条 Set 语句。重写 AOF 文件的操作，并没有读取旧的 AOF 文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的 AOF 文件，这一点和快照有点相似</li>
<li>触发机制：Redis 会记录上次重写时的 AOF 文件大小，默认配置是当 AOF 文件大小是上次重写后大小的一倍且文件大于 64M 时触发</li>
</ul>
</li>
<li><p>AOF 优点</p>
<ul>
<li>每修改同步：appendfsync always，同步持久化，每次数据发生变更会立即被记录到硬盘，性能较差但数据完整性较好</li>
<li>每秒同步：appendfsync everysec，异步操作，每秒记录，如果一秒内宕机，会有数据丢失</li>
<li>不同步：appendfsync no，等操作系统进行数据缓存同步到硬盘</li>
</ul>
</li>
<li><p>AOF 缺点</p>
<ul>
<li>相同数据集的数据而言，AOF 文件要远大于 RDB 文件，恢复速度慢于 RDB</li>
<li>AOF 运行效率要慢于 RDB，每秒同步策略较好，不同步效率和 RDB 相同</li>
</ul>
</li>
<li><p>总结</p>
<p>  <img src="image-20191114201748514.png" alt="image-20191114201748514"></p>
</li>
</ul>
</li>
</ol>
<hr>
<ol start="3">
<li>总结<ul>
<li>RDB 持久化方式能够在指定的时间间隔内对数据进行快照存储</li>
<li>AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF 命令以 Redis 协议追加保存每次写的操作到文件末尾。Redis 还能对 AOF 文件进行后台重写，使得 AOF 文件的体积不至于过大</li>
<li>只做缓存：如果只希望数据在服务器运行的时候存在，可以不使用任何持久化方式</li>
<li>同时开启两种持久化方式：在这种情况下，Redis 重启时会优先载入 AOF 文件来恢复原始的数据，因为通常情况下 AOF 文件保存的数据集要比 RDB 保存的数据集完整</li>
<li>RDB 的数据不实时，同时使用两者时服务器重启也只会找 AOF 文件，作者建议不要使用 AOF，因为 RDB 更适合用于备份数据库（AOF 在不断变化不好备份），快速重启，而且不会有 AOF 可能潜在的 bug，留着做一个以防万一的手段</li>
<li>性能建议：因为 RDB 文件只用作后备用途，建议只在 Slave 上持久化 RDB 文件，而且只要 15 分钟备一次就好了，只保留 <code>save 900 1</code> 这条规则。如果开启 AOF，好处是在最恶劣的情况下也只会丢失不超过两秒的数据，启动脚本简单只 load 自己的 AOF 文件就可以了。代价一是带来了持续的 I/O，二是 AOF 重写的最后将重写过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少 AOF 重写的频率，AOF 重写的基础大小默认 64M 太小了，可以设到 5GB 以上。默认超过原大小 100% 大小时重写可以改到适当的数值。如果不开启 AOF，仅靠 Master-Slave Replication 实现高可用性也可以。能省掉一大笔 I/O 也减少了重写时带来的系统波动。代价是如果 Master-Slave 同时宕机，会丢失十几分钟数据，启动脚本也要比较两个 Master-Slave 中的 RDB 文件，载入较新的哪个</li>
</ul>
</li>
</ol>
<hr>
<h5 id="Redis-的事务"><a href="#Redis-的事务" class="headerlink" title="Redis 的事务"></a>Redis 的事务</h5><ol>
<li>事务：可以一次执行多个命令，本质是一组命令的集合。一个事务中的所有命令都会序列化，按顺序地串行化执行而不会被其他命令插入，禁止加塞</li>
</ol>
<hr>
<ol start="2">
<li>事务的作用：一个队列中，一次性、顺序性、排他性地执行一系列命令</li>
</ol>
<hr>
<ol start="3">
<li>Redis 事务常用命令<ul>
<li><code>MULTI</code> ：开启事务</li>
<li><code>EXEC</code> ：执行事务</li>
<li><code>DISCARD</code> ：放弃事务</li>
<li><code>WATCH key [key...]</code> ：监视一个或多个 Key，若在事务执行之前这个（这些）Key 被其他命令所改动，那么事务将会被打断</li>
<li><code>UNWATCH</code> ：取消 <code>WATCH</code> 命令对所有 Key 的监视</li>
</ul>
</li>
</ol>
<hr>
<ol start="4">
<li><p>五种情况</p>
<ul>
<li><p>正常执行</p>
<p>  <img src="image-20191114204225729.png" alt="image-20191114204225729"></p>
</li>
<li><p>放弃事务（类似回滚）</p>
<p>  <img src="image-20191114204238374.png" alt="image-20191114204238374"></p>
</li>
<li><p>事务队列中全都不执行</p>
<p>  <img src="image-20191114204249409.png" alt="image-20191114204249409"></p>
</li>
<li><p>事务队列中谁错谁不执行，其他没错的都执行。与上面的区别是：上面是在输入命令回车之后直接抛出 Error ，而这个是在使用 <code>EXEC</code> 执行事务时才出现的错误</p>
<p>  <img src="image-20191114204258782.png" alt="image-20191114204258782"></p>
</li>
<li><p>watch 监控</p>
<ul>
<li>悲观锁/乐观锁/CAS（Check And Set）<ul>
<li>悲观锁（Pessimistic Lock）：每次去数据库中取数据时都很悲观，认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。传统的关系型数据库中用到了很多这种锁机制，比如行锁、表锁、读锁、写锁等，都是在做操作之前先上锁</li>
<li>乐观锁（Optimistic Lock）：每次去数据库中拿数据时都很乐观，认为别人不会修改，所以不会上锁，但是在更新时会判断一下在此期间别人有没有去更新这个数据，常用的是版本号机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。乐观锁策略：提交版本必须大于当前记录版本才能执行更新</li>
<li>Redis 的 CAS 主要通过 <code>WATCH</code> 命令来实现</li>
</ul>
</li>
<li>例子：银行转账</li>
<li>小结：<code>WATCH</code> 命令，类似乐观锁，事务提交时，如果 Key 的值已经被别的客户端修改，那么整个事务队列都不会被执行。通过 <code>WATCH</code> 命令在事务执行之前监控了多个 Keys ，倘若在监视之后有任何的 Key 的值发生了变化，那么 <code>EXEC</code> 命令执行的事务都将会被放弃，同时返回 Nullmulti-bulk 应答已通知调用者事务执行失败</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<ol start="5">
<li>事务执行流程<ul>
<li>开启：通过 <code>MULTI</code> 命令开启一个事务</li>
<li>入队：将多个命令加入到事务队列中，这些命令并不会立即执行，而是放到等待执行的事务队列中</li>
<li>执行：由 <code>EXEC</code> 命令触发事务</li>
</ul>
</li>
</ol>
<hr>
<ol start="6">
<li>事务的特性<ul>
<li>Redis 部分支持事务（原因见五种情况中的第四种）</li>
<li>单独的隔离操作：事务中的所有命令都会序列化、按顺序的执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断</li>
<li>没有隔离级别的概念：队列中的命令在没有提交之前都不会实际的被执行，因为事务提交之前任何命令都不会被实际执行，也就不存在 “事务内的查询要看到事务里的更新，在事务外查询不能看到” 这个令人万分头疼的问题</li>
<li>不保证原子性：Redis 同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li>
</ul>
</li>
</ol>
<hr>
<h5 id="Redis-的发布-订阅模式"><a href="#Redis-的发布-订阅模式" class="headerlink" title="Redis 的发布-订阅模式"></a>Redis 的发布-订阅模式</h5><ol>
<li><p>发布-订阅模式概念</p>
<ul>
<li><p>是进程间的一种消息通信模式：发布者（pub）发送消息，订阅者（sub）接收消息</p>
<p>  <img src="image-20191114205909477.png" alt="image-20191114205909477"></p>
</li>
</ul>
</li>
</ol>
<hr>
<ol start="2">
<li><a href="https://redis.io/commands#pubsub">发布-订阅模式常用命令</a></li>
</ol>
<hr>
<ol start="3">
<li>说明<ul>
<li>先订阅后发布才能接收到消息</li>
<li>可以一次性订阅多个：<code>SUBSCRIBE c1 c2 c3</code></li>
<li>消息发布：<code>PUBLISH c2 msg</code></li>
<li>订阅多个，通配符 <code>*</code> ，<code>PSUBSCRIBE new*</code></li>
<li>收取消息：<code>PUBLISH new1 redistest</code></li>
</ul>
</li>
</ol>
<hr>
<h5 id="Redis-的复制-Master-Slave-模式"><a href="#Redis-的复制-Master-Slave-模式" class="headerlink" title="Redis 的复制(Master-Slave 模式)"></a>Redis 的复制(Master-Slave 模式)</h5><ol>
<li>Redis 的复制：也就是所说的主从复制，主机数据更新后根据配置和策略，自动同步到备机的 Master-Slave 模式，Master 以写为主，Slave 以读为主</li>
</ol>
<hr>
<ol start="2">
<li>Redis Master-Slave 模式的作用：读写分离；容灾恢复</li>
</ol>
<hr>
<ol start="3">
<li><p>使用方法</p>
<ul>
<li><p>配从（库）不配主（库）</p>
</li>
<li><p>从库配置：<code>SLAVEOF 主库IP 主库端口</code> 。每次与 Master 断开之后，都需要重新连接，除非你配置进 redis.conf 文件。通过 <code>INFO replication</code> 命令查询当前服务器的角色</p>
</li>
<li><p>修改配置文件细节操作</p>
<ul>
<li>拷贝多个 redis.conf 文件</li>
<li>开启以守护进程模式运行（daemonize yes）</li>
<li>指定 pidfile</li>
<li>指定端口</li>
<li>指定 logfile</li>
<li>修改 dump.rdb 文件名</li>
</ul>
</li>
<li><p>常用配置方式</p>
<ul>
<li><p>一主二从</p>
<ul>
<li><p>初始化</p>
<p>  <img src="image-20191114211746320.png" alt="image-20191114211746320"></p>
</li>
<li><p>一个 Master 两个 Slave</p>
<p>  <img src="image-20191114211801138.png" alt="image-20191114211801138"></p>
</li>
<li><p>日志查看</p>
<ul>
<li><p>主机日志</p>
<p>  <img src="image-20191114211813728.png" alt="image-20191114211813728"></p>
</li>
<li><p>备机日志</p>
<p>  <img src="image-20191114211828271.png" alt="image-20191114211828271"></p>
</li>
<li><p><code>INFO replication</code></p>
<p>  <img src="image-20191114211844626.png" alt="image-20191114211844626"></p>
</li>
</ul>
</li>
<li><p>主从问题</p>
<ul>
<li><p>切入点问题？Slave1、Slave2 是从头开始复制还是从切入点开始复制？比如从 K4 进来，那之前的 123 是否也可以复制？</p>
<p>  如果 Slave 是第一次连接或重启了，那么会进行一次全量复制；如果一直保持连接状态则是进行增量复制</p>
</li>
<li><p>从机是否可以写？Set 可否？</p>
<p>  从机只能读，不能进行写操作，Set 也不行</p>
</li>
<li><p>主机 <code>SHUTDOWN</code> 后情况如何？从机是上位还是原地待命？</p>
<p>  原地待命</p>
</li>
<li><p>主机又回来了后，主机新增记录，从机是否还能顺利复制？</p>
<p>  能</p>
</li>
<li><p>其中一台从机宕机之后情况如何？依照原有它能跟上大部队吗？</p>
<p>  如果是通过命令而不是写入配置文件的从机，那么在从机宕机一次后，它会自动还原成 Master 而不再是 Slave。如果是写入配置文件的情况，那么它还是原来的 Slave ，在连接上 Master 时会进行一次全量复制从而保证与 Master 当前的状态一致</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>传递</p>
<ul>
<li>上一个 Slave 可以是下一个 Slave 的 Master，Slave 同样可以接收其他 Slave 的连接和同步请求，那么该 Slave 作为链中下一个 Slave 的 Master，可以有效减轻 Master 的写压力</li>
<li>中途变更转向：会清除之前的数据，重新建立拷贝最新的</li>
<li><code>SLAVEOF 新主库IP 新主库端口</code></li>
</ul>
</li>
<li><p>从机变主机</p>
<ul>
<li><code>SLAVEOF NO ONE</code> </li>
<li>使当前数据库停止与其他数据库的同步，转成主库</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<ol start="4">
<li>复制原理<ul>
<li>Slave 启动成功连接到 Master 后会发送一个 sync 命令</li>
<li>Master 接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集的命令，在后台进程执行完毕后，Master 将传送整个数据文件到 Slave，以完成一次完全同步</li>
<li>全量复制：Slave 服务器在接收到数据库文件数据后，将其存盘并加载到内存中</li>
<li>增量复制：Master 继续将新的所有收集到的修改命令依次传给 Slave，完成同步</li>
<li>只要重新连接一次 Master，一次完全同步（全量复制）将被自动执行</li>
</ul>
</li>
</ol>
<hr>
<ol start="5">
<li>哨兵模式<ul>
<li>哨兵模式是从机变主机的自动版本，能够后台监控主机是否故障，如果故障了会根据投票数自动将从库转换为主库</li>
<li>使用步骤<ul>
<li>准备三个端口不一样的 redis.conf 配置文件（或是三台主机）</li>
<li>自定义的 redis 目录下新建 sentinel.conf 文件</li>
<li>配置哨兵，填写 sentinel.conf 文件<ul>
<li><code>sentinel monitor 被监控数据库名字(任意) MasterIP MasterPort 投票数</code></li>
<li>投票数表示在 Master 宕机后，Slave 投票看让谁接替成为下一个 Master，得票数多的成为下一个 Master</li>
</ul>
</li>
<li>启动哨兵：<code>redis-sentinel /自定义目录/sentinel.conf</code></li>
<li>如果原来的 Master 重新连接，那么它会默认成为当前 Master 的 Slave</li>
</ul>
</li>
<li>一组 sentinel 可以同时监控多个 Master</li>
</ul>
</li>
</ol>
<hr>
<ol start="6">
<li>复制的缺点<ul>
<li>由于所有的写操作都是先在 Master 上操作，然后同步更新到 Slave 上，而从 Master 同步到 Slave 机器会有一定的延迟，当系统繁忙的时候，延迟问题会更加严重，Slave 机器数量的增加也会使这个问题更加严重</li>
</ul>
</li>
</ol>
<hr>
<h5 id="Redis-的-Java-客户端-Jedis"><a href="#Redis-的-Java-客户端-Jedis" class="headerlink" title="Redis 的 Java 客户端 Jedis"></a>Redis 的 Java 客户端 Jedis</h5><ol>
<li>Jedis 需要的 jar 包<ul>
<li>Commons-pool.jar</li>
<li>Jedis.jar</li>
<li>具体版本可以上 <a href="https://mvnrepository.com/artifact/redis.clients/jedis">Maven仓库</a> 查看</li>
</ul>
</li>
</ol>
<hr>
<ol start="2">
<li>Jedis 常用操作与在 redis-cli 中操作一致，就不再赘述</li>
<li>JedisPool<ul>
<li>Jedis 实例应当从 JedisPool 中获取，用完后 Jedis 实例需要返还给 JedisPool。如果 Jedis 在使用过程中出错，则也需要返还给 JedisPool</li>
<li>工具类 JedisPoolUtil 的实现</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 被 volatile 修饰的变量不会被本地线程缓存</span></span><br><span class="line">    <span class="comment">// 对该变量的读写都是直接操作共享内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> JedisPool jedisPool = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> JedisPoolUtil &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取 JedisPool 实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JedisPool <span class="title">getJedisPoolInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == jedisPool) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (JedisPoolUtil.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == jedisPool) &#123;</span><br><span class="line">                    JedisPoolConfig poolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">                    poolConfig.setMaxActive(<span class="number">1000</span>);</span><br><span class="line">                    poolConfig.setMaxIdle(<span class="number">32</span>);</span><br><span class="line">                    poolConfig.setMaxWait(<span class="number">100</span>*<span class="number">1000</span>);</span><br><span class="line">                    poolConfig.setTestOnBorrow(<span class="keyword">true</span>);</span><br><span class="line">                    </span><br><span class="line">                    jedisPool = <span class="keyword">new</span> JedisPool(poolConfig, <span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> jedisPool;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(JedisPool jedisPool, Jedis jedis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != jedis) &#123;</span><br><span class="line">            jedisPool.returnResource(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>JedisPool 配置总结</p>
<ul>
<li><p>JedisPool 的配置参数大部分是由 JedisPoolConfig 的对应项来赋值的</p>
</li>
<li><p>maxActive：控制一个 pool 可分配多少个 Jedis 实例，通过 pool.getResource() 来获取，如果赋值为 -1，则表示不限制；如果 pool 已经分配了 maxActive 个 Jedis 实例，则此时 pool 的状态为 exhausted</p>
</li>
<li><p>maxIdle：控制一个 pool 最多有多少个状态为 idle（空闲） 的 Jedis 实例</p>
</li>
<li><p>whenExhaustedAction：表示当 pool 中的 Jedis 实例都被 allocated 完时，pool 要采取的操作，默认有三种：</p>
<p>  WHEN_EXHAUSTED_FAIL：表示无 Jedis 实例，直接抛出 NoSuchElementException</p>
<p>  WHEN_EXHAUSTED_BLOCK：表示阻塞住，或者达到 maxWait 时抛出 JedisConnectionException</p>
<p>  WHEN_EXHAUSTED_GROW：表示新建一个 Jedis 实例，也就是说设置的 maxActive 无用</p>
</li>
<li><p>maxWait：表示当 borrow 一个 Jedis 实例时，最大的等待时间，如果超过等待时间，则直接抛 JedisConnectionException</p>
</li>
<li><p>testOnBorrow：获得一个 Jedis 实例的时候是否检查连接可用性（ping 一次）。如果为 true，则得到的 Jedis 实例均是可用的</p>
</li>
<li><p>testOnReturn：return 一个 Jedis 实例给 pool 时，是否检查连接可用性（ping 一次）</p>
</li>
<li><p>testWhileIdle：如果为 true，表示有一个 idel object evitor 线程对 idle object 进行扫描，如果 validate 失败，此 object 会被从 pool 中 drop 掉，这一项只在 timeBetweenEvictionRunsMillis 大于 0 时才有意义</p>
</li>
<li><p>timeBetweenEvictionRunsMillis：表示 idle object evitor 两次扫描之间要 sleep 的毫秒数</p>
</li>
<li><p>numTestsPerEvictionRun：表示 idle object evitor 每次扫描的最多的对象</p>
</li>
<li><p>minEvictableIdleTimeMillis：表示一个对象至少停留在 idle 状态的最短时间，然后才能被 idle object evitor 扫描并驱逐，这一项只有在 timeBetweenEvictionRunMillis 大于 0 才有意义</p>
</li>
<li><p>softMinEvictableIdleTimeMillis：在 minEvictableIdleTimeMillis 基础上，加入了至少 minIdle 个对象已经在 pool 里面了。如果为 -1 ，evicted 不会根据 idle time 驱逐任何对象。如果 minEvictableIdleTimeMillis 大于 0，则此项设置无意义，且只有在 timeBetweenEvictionRunsMillis 大于 0 时才有意义</p>
</li>
<li><p>lifo：borrowObject 返回对象时，是采用 DEFAULT_LIFO（last in first out，即类似 cache 的最频繁使用队列），如果为 False，则表示 FIFO 队列</p>
</li>
<li><p>其中 JedisPoolConfig 对一些参数的默认配置如下：</p>
<ul>
<li>testWhileIdle = true</li>
<li>minEvicatableIdleTimeMillis = 60000</li>
<li>timeBetweenEvictionRunsMillis = 30000</li>
<li>numTestsPerEvictionRun = -1</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/Spring/Spring/</url>
    <content><![CDATA[<h5 id="Spring-特点"><a href="#Spring-特点" class="headerlink" title="Spring 特点"></a>Spring 特点<a id="more"></a></h5><ul>
<li>轻量级：Spring 是非侵入性的，即基于 Spring 开发的应用中的对象可以不依赖于 Spring 的 API</li>
<li>依赖注入</li>
<li>面向切面编程</li>
<li>容器：Spring 是一个容器，因为它包含并且管理应用对象的生命周期</li>
<li>框架：Spring 实现了使用简单的组件配置组合成一个复杂的应用，在 Spring 中可以使用 XML 和 Java 注解组合这些对象</li>
<li>一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库（实际上 Spring 自身也提供了展现层的 SpringMVC 和持久层的 Spring JDBC）</li>
</ul>
<hr>
<h5 id="IOC-amp-DI-概述"><a href="#IOC-amp-DI-概述" class="headerlink" title="IOC &amp; DI 概述"></a>IOC &amp; DI 概述</h5><ul>
<li>IOC（ Inversion of Control ）：其思想是反转资源获取的方向。传统的资源查找方式要求组件向容器发起请求查找资源，作为响应，容器适时的返回资源，而应用了 IOC 之后，则是容器主动地将资源推送给它所管理的组件，组件要做的事情仅仅是选择一种合适的方式来接受资源，这种行为也被称为查找的被动形式</li>
<li>DI（ Dependency Injection ）：IOC 的另一种表达方式。即组件以一些预定好的方式，如 Setter 方法，接受来自容器的资源注入，相对 IOC 而言，这种表述更直接</li>
</ul>
<hr>
<h5 id="配置-Bean"><a href="#配置-Bean" class="headerlink" title="配置 Bean"></a>配置 Bean</h5><ul>
<li><p>配置形式：</p>
<ul>
<li><p>基于 XML 文件的形式</p>
<ul>
<li><p>在 XML 文件中通过 bean 节点的来配置 bean</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过全类名的方式来配置 Bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;human&quot;</span> <span class="attr">class</span>=<span class="string">&quot;beans.Human&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>id：Bean 的名称。在 IOC 容器中必须是唯一的。若 id 没有指定，Spring 自动将全限定类名作为 Bean 的名字。id 可以指定多个名字，名字之间可用逗号、分号或空格分隔</p>
</li>
<li><p>class：Bean 的全类名，通过反射的方式在 IOC 容器中创建 Bean，所以要求 Bean 中必须要有一个无参构造器</p>
</li>
</ul>
</li>
<li><p>基于注解的方式</p>
<ul>
<li><p>组件扫描：Spring 能够从 classpath 下自动扫描，侦测和实例化具有特定注解的组件，特定组件包括：</p>
<ul>
<li>@Component：基本注解，标识一个受 Spring 管理的组件</li>
<li>@Repository：标识持久层组件</li>
<li>@Service：标识业务层组件</li>
<li>@Controller：标识控制层组件</li>
</ul>
</li>
<li><p>对于扫描到的组件，Spring 有默认的命名策略：使用非限定类名，第一个字母小写。也可以在注解中通过 value 属性标识组件的名称</p>
</li>
<li><p>在组件类上使用了特定注解后，还需要在 Spring 的配置文件中声明 &lt;context:component-scan&gt;</p>
<ul>
<li><p>base-package 属性指定一个需要扫描的基类包，Spring 容器将会扫描这个基类包中及其子包中的所有类</p>
</li>
<li><p>当需要扫描多个包时，可以使用逗号分隔</p>
</li>
<li><p>如果仅希望扫描特定的类而非基类包下所有类，可使用 resource-pattern 属性过滤特定的类，如：</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;beans&quot;</span> <span class="attr">resource-pattern</span>=<span class="string">&quot;autowire/*.class&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>&lt;context:include-filter&gt;：子节点表示要包含的目标类（与 &lt;context:component-scan&gt; 的 use-default-filters 属性配合使用）</p>
</li>
<li><p>&lt;context:exclude-filter&gt;：子节点表示要排除在外的目标类</p>
</li>
<li><p>&lt;context:component-scan&gt; 下可拥有若干个 &lt;context:include-filter&gt; 与 &lt;context:exclude-filter&gt; 子节点</p>
</li>
<li><p>&lt;context:include-filter&gt; 和 &lt;context:exclude-filter&gt; 支持多种类型的过滤表达式：</p>
<table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">示例</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">annotation</td>
<td align="center">com.XxxAnnotation</td>
<td align="center">所有标注了 XxxAnnotation 的类，该类型采用目标类是否标注了某个注解进行过滤</td>
</tr>
<tr>
<td align="center">assignable</td>
<td align="center">com.XxxService</td>
<td align="center">所有继承或扩展 XxxService 的类，该类型采用目标类是否继承或扩展某个特定类进行过滤</td>
</tr>
<tr>
<td align="center">aspectj</td>
<td align="center">com.aaa.bbb..*Service+</td>
<td align="center">所有类名以 Service 结束的类及继承或扩展它们的类，该类型采用 AspectJ 表达式进行过滤</td>
</tr>
<tr>
<td align="center">regex</td>
<td align="center">com.\aaa\.anno\.*</td>
<td align="center">所有 com.aaa.anno 包下的类，该类型采用正则表达式根据类的类名进行过滤</td>
</tr>
<tr>
<td align="center">custom</td>
<td align="center">com.XxxTypeFilter</td>
<td align="center">采用 XxxTypeFilter 通过代码的方式定义过滤规则，该类必须实现 org.springframework.core.type.TypeFilter 接口</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>组件装配：&lt;context:component-scan&gt; 元素还会自动注册 AutowiredAnnotationBeanPostProcessor 实例，该实例可以自动装配具有 @Autowired 和 @Resource 以及 @Inject 注解的属性</p>
<ul>
<li>@Autowired 注解自动装配具有兼容类型的单个 Bean 属性<ul>
<li>构造器，普通字段（即使是非 public），一切具有参数的方法都可以应用 @Autowired 注解</li>
<li>默认情况下，所有使用 @Autowired 注解的属性都需要被设置，当 Spring 找不到匹配的 Bean 装配属性时，会抛出异常，若某一属性允许不被设置，可以设置 @Autowired 注解的 required 属性为 false</li>
<li>默认情况下，当 IOC 容器里存在多个类型兼容的 Bean 时，通过类型的自动装配将无法工作，此时可以在 @Qualifier 注解里提供 Bean 的名称，Spring 允许对方法的入参标注 @Qualifier 以指定注入 Bean 的名称</li>
<li>@Autowired 注解也可以应用在数组类型的属性上，此时 Spring 将会把所有匹配的 Bean 进行自动装配</li>
<li>@Autowired 注解也可以应用在集合属性上，此时 Spring 读取该集合的类型信息，然后自动装配所有与之兼容的 Bean</li>
<li>@Autowired 注解用在 java.util.Map 上时，若该 Map 的键值为 String，那么 Spring 将自动装配与之 Map 值类型兼容的 Bean，此时 Bean 的名称作为键值</li>
</ul>
</li>
<li>Spring 还支持 @Resource 和 @Inject 注解，这两个注解和 @Autowired 注解的功能类似<ul>
<li>@Resource 注解要求提供一个 Bean 名称的属性，若该属性为空，则自动采用标注处的变量或方法名作为 Bean 的名称</li>
<li>@Inject 注解 和 @Autowired 注解一样也是按类型匹配注入 Bean，但是没有 required 属性（建议使用 @Autowired）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Bean 的配置方式：</p>
<ul>
<li>通过全类名（反射）</li>
<li>通过工厂方法（静态工厂方法 &amp; 实例工厂方法）<ul>
<li>调用静态工厂方法创建 Bean 是将对象创建的过程封装到静态方法中，当客户端需要对象时，只需要简单的调用静态方法，而不需要关心创建对象的细节</li>
<li>要声明通过静态方法创建的 Bean，需要在 Bean 的 class 属性里指定拥有该工厂的方法的类，同时在 factory-method 属性里指定工厂方法的名称，最后，使用 &lt;constrctor-arg&gt; 元素为该方法传递方法参数</li>
<li>实例工厂方法：将对象的创建过程封装到另外一个对象实例的方法里。当客户端需要请求对象时，只需要简单的调用该实例方法而不需要关系对象的创建细节</li>
<li>要声明通过实例工厂方法创建的 Bean，需要在 Bean 的 factory-bean 属性里指定拥有该工厂方法的 Bean，然后在 factory-method 属性里指定该工厂方法的名称，最后使用 &lt;constructor-arg&gt; 元素为工厂方法传递方法参数</li>
</ul>
</li>
<li>FactoryBean<ul>
<li>自定义的 FactoryBean 需要实现 org.springframework.beans.factory.FactoryBean&lt;T&gt; 接口，然后在配置文件中定义一个 Bean，class 为 自定义的 FactoryBean 的全类名，这个 Bean 返回的实例为自定义 FactoryBean 中实现的 getObject() 方法的返回值</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="IOC-容器-BeanFactory-amp-ApplicationContext-概述"><a href="#IOC-容器-BeanFactory-amp-ApplicationContext-概述" class="headerlink" title="IOC 容器 BeanFactory &amp; ApplicationContext 概述"></a>IOC 容器 BeanFactory &amp; ApplicationContext 概述</h5><ul>
<li>在 Spring IOC 容器读取 Bean 配置创建 Bean 实例之前，必须对它进行实例化，只有在容器实例化后，才能从 IOC 容器中获取 Bean 实例并使用</li>
<li>Spring 提供了两种类型的 IOC 容器实现：<ul>
<li>BeanFactory：IOC 容器的基本实现</li>
<li>ApplicationContext：提供了更多的高级特性，是 BeanFactory 的子接口</li>
<li>BeanFactory 是 Spring 框架的基础设施，面向 Spring 本身。ApplicationContext 面向使用 Spring 框架的开发者，几乎所有的应用场合都直接使用 ApplicationContext 而非底层的 BeanFactory</li>
<li>无论使用何种方式，配置文件是相同的</li>
</ul>
</li>
<li>ApplicationContext 主要实现类：<ul>
<li>ClassPathXmlApplicationContext：从类路径下加载配置文件</li>
<li>FileSystemXmlApplicationContext：从文件系统中加载配置文件</li>
</ul>
</li>
<li>ConfigurableApplicationContext 扩展于 ApplicationContext，新增加两个主要方法：refresh() 和 close()，让 ApplicationContext 具有启动、刷新和关闭上下文的能力</li>
<li>ApplicationContext 在初始化上下文时就实例化所有单例的 Bean</li>
<li>WebApplicationContext 是专门为 Web 应用准备的，它允许从相对于 Web 根目录的路径中完成初始化工作</li>
</ul>
<hr>
<h5 id="依赖注入的方式"><a href="#依赖注入的方式" class="headerlink" title="依赖注入的方式"></a>依赖注入的方式</h5><ul>
<li><p>Setter 注入</p>
<ul>
<li><p>通过 setter 方法注入 Bean 的属性值或依赖的对象</p>
</li>
<li><p>属性注入使用 &lt;property&gt; 元素，使用 name 属性指定 Bean 的属性名称，value 属性或 &lt;value&gt; 子节点指定属性值</p>
</li>
<li><p>属性注入是实际应用中最常用的注入方式</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过全类名的方式来配置 Bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;human&quot;</span> <span class="attr">class</span>=<span class="string">&quot;beans.Human&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Spring First&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Constructor 注入</p>
<ul>
<li>通过构造方法注入 Bean 的属性值或者依赖的对象，它保证了 Bean 实例在实例化之后即可使用</li>
<li>构造器注入在 &lt;constructor-arg&gt; 元素里声明属性，&lt;constructor-arg&gt; 中没有 name 属性</li>
<li>使用构造器注入属性值可以指定参数的位置（ index ）和参数的类型 （ type ），以区分重载的构造器</li>
</ul>
</li>
<li><p>注入属性值细节</p>
<ul>
<li>字面值：可用字符串表示的值，可以通过 &lt;value&gt; 元素标签或者 value 属性进行注入。基本数据类型及其封装类、String 等类型都可以采取字面值注入的方式。若字面值中包含特殊字符，可以使用 &lt;![CDATA[]]&gt; 把字面值包裹起来</li>
<li>在 Bean 的配置文件中，可以通过 &lt;ref&gt; 元素或者 ref 属性为 Bean 的属性或者构造器参数指定对 Bean 的引用，也可以在属性或构造器里包含 Bean 的声明，这样的 Bean 称为内部 Bean</li>
<li>可以使用专用的 &lt;null/&gt; 元素标签为 Bean 的字符串或其他对象类型的属性注入 null 值。Spring 支持级联属性的配置（需要先初始化属性再为级联属性赋值）</li>
<li>在 Spring 中可以通过一组内置的 xml 标签（如 &lt;list&gt; 、&lt;set&gt; 、&lt;map&gt;）来配置集合属性。<ul>
<li>配置 java.util.List 类型的属性，需要指定 &lt;list&gt; 标签，在标签里包含一些元素，这些标签可以通过 &lt;value&gt; 指定简单的常量值，也可以通过 &lt;ref&gt; 指定对其他 Bean 的引用，也可以通过 &lt;bean&gt; 指定内置 Bean 定义，还可以通过 &lt;null/&gt; 指定空元素，甚至可以内嵌其他集合。</li>
<li>数组的定义和 List 一样，都使用 &lt;list&gt;。</li>
<li>java.util.Set 需要使用 &lt;set&gt; 标签，定义元素的方法与 &lt;list&gt; 一致。</li>
<li>java.util.Map 通过 &lt;map&gt; 标签定义，&lt;map&gt; 标签里可以使用多个 &lt;entry&gt; 作为子标签，每个条目包含一个键和一个值。必须在 &lt;key&gt; 标签里定义键。因为键和值的类型没有限制，所以可以自由地为它们指定 &lt;value&gt;、&lt;ref&gt;、&lt;bean&gt;、&lt;null&gt; 元素。可以将 Map 的键和值作为 &lt;entry&gt; 的属性定义：简单常量使用 key 和 value 来定义，Bean 引用通过 key-ref 和 value-ref 属性定义。</li>
<li>使用 &lt;props&gt; 定义 java.util.Properties，该标签使用多个 &lt;prop&gt; 作为子标签，每个 &lt;prop&gt; 标签必须定义 key 属性</li>
<li>使用基本的集合标签定义集合时，不能将集合作为独立的 Bean 定义，导致其他的 Bean 无法引用该集合，所以无法在不同 Bean 之间共享集合。可以使用 util schema 里的集合标签定义独立的集合 Bean，需要注意的是必须在 &lt;beans&gt; 根元素里添加 util schema 定义</li>
<li>Spring 从 2.5 开始引入了一个 p 命名空间，可以通过 &lt;bean&gt; 元素属性的方式配置 Bean 的属性（需要先添加 p schema 定义）</li>
</ul>
</li>
</ul>
</li>
<li><p>自动装配</p>
<ul>
<li>XML 配置中的 Bean 自动装配<ul>
<li>Spring IOC 容器可以自动装配 Bean，需要做的仅仅是在 &lt;bean&gt; 的 autowire 属性里指定自动装配的模式</li>
<li>byType（根据类型自动装配）：若 IOC 容器中有多个与目标 Bean 类型一致的 Bean，在这种情况下，Spring 将无法判定哪个 Bean 最适合该属性，所以不能执行自动装配</li>
<li>byName（根据名称自动装配）：必须将目标 Bean 的名称和属性名设置得完全相同</li>
<li>constructor（通过构造器自动装配）：当 Bean 中存在多个构造器时，这种自动装配方式将会很复杂，不建议使用</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="Bean-之间关系"><a href="#Bean-之间关系" class="headerlink" title="Bean 之间关系"></a>Bean 之间关系</h5><ul>
<li>继承<ul>
<li>Spring 允许继承 bean 的配置，被继承的 bean 称为父 bean，继承这个父 bean 的 bean 称为子 bean</li>
<li>子 bean 从父 bean 中继承配置，包括 bean 的属性配置</li>
<li>子 bean 也可以覆盖从父 bean 继承过来的配置</li>
<li>父 bean 可以作为配置模板，也可以作为 bean 实例，若只想把父 bean 作为模板，可以设置 &lt;bean&gt; 的 abstract 属性为 true，这样 Spring 将不会实例化这个 bean</li>
<li>并不是 &lt;bean&gt; 元素里的所有属性都会被继承，比如 autowire 、abstract 等</li>
<li>也可以忽略父 bean 的 class 属性，让子 bean 指定自己的类，而共享相同的属性配置，但此时 abstract 必须设为 true</li>
</ul>
</li>
<li>依赖<ul>
<li>Spring 允许通过 depends-on 属性设定 bean 前置依赖的 bean，前置依赖的 bean 会在本 bean 实例化之前创建好</li>
<li>如果前置依赖多个 bean，则可以通过逗号、空格的方式配置 bean 的名称</li>
</ul>
</li>
</ul>
<hr>
<h5 id="Bean-的作用域"><a href="#Bean-的作用域" class="headerlink" title="Bean 的作用域"></a>Bean 的作用域</h5><ul>
<li>singleton（默认值）：单例，在实例化 IOC 容器时创建，并且整个 IOC 容器的生命周期内只初始化一次</li>
<li>prototype：原型，实例化 IOC 容器时不创建，而是在每次获取这个 bean 时才实例化</li>
<li>Web 环境作用域</li>
</ul>
<hr>
<h5 id="使用外部属性文件"><a href="#使用外部属性文件" class="headerlink" title="使用外部属性文件"></a>使用外部属性文件</h5><ul>
<li><p>在配置文件里配置 bean 时，有时需要在 bean 的配置里混入系统部署的细节信息（比如文件路径、数据源配置信息等），而这些部署细节实际上需要和 bean 配置分离</p>
</li>
<li><p>Spring 提供了一个 PropertyPlaceholderConfigurer 的 BeanFactory 后置处理器，这个处理器允许用户将 bean 配置的部分内容移到属性文件中，可以在 bean 配置文件里使用形式为 ${var} 的变量，PropertyPlaceholderConfigurer 从属性文件中加载属性，并使用这些属性来替换变量</p>
</li>
<li><p>Spring 还允许在属性文件中使用 ${propName}，以实现属性之间的相互引用</p>
</li>
<li><p>注册 PropertyPlaceholderConfigurer ：</p>
<ul>
<li><p>Spring 2.5 之后通过 &lt;context:property-placeholder&gt; 元素导入，例如：</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 需要添加 context Schema 定义 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:db.properties&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<hr>
<h5 id="SpEL"><a href="#SpEL" class="headerlink" title="SpEL"></a>SpEL</h5><ul>
<li><p>Spring 表达式语言，是一个支持运行时查询和操作对象图的表达式语言</p>
</li>
<li><p>语法类似 EL：SpEL 使用 #{…} 作为定界符</p>
</li>
<li><p>SpEL 为 bean 的属性进行动态赋值提供了便利</p>
</li>
<li><p>通过 SpEL 可以实现：</p>
<ul>
<li>通过 bean 的 id 对 bean 进行引用</li>
<li>调用方法以及引用对象中的属性</li>
<li>计算表达式的值</li>
<li>正则表达式的匹配</li>
</ul>
</li>
<li><p>字面量：</p>
<ul>
<li><p>整数：</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;5&#125;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>小数：</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;frequency&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;89.7&#125;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>科学计数法：</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;capacity&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;1e4&#125;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>String 可以使用单引号或者双引号作为字符串的定界符号：</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;&#x27;Chunk&#x27;&#125;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&#x27;#&#123;&quot;Chunk&quot;&#125;&#x27;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Boolean：</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;fasle&#125;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>引用 Bean、属性和方法</p>
<ul>
<li><p>引用其他对象：</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过 value 属性和 SpEL 配置 Bean 之间的引用关系 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;prefixGenerator&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>引用其他对象的属性：</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过 value 属性和 SpEL 配置 suffix 属性值为另一个 Bean 的 suffix 属性值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;sequenceGenerator2.suffix&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>调用其他方法，还可以链式操作：</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过 value 属性和 SpEL 配置 suffix 属性值为另一个 Bean 的方法的返回值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;sequenceGenerator2.toString()&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 方法的连缀 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;sequenceGenerator2.toString().toUpperCase()&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>调用静态方法或静态属性：通过 T() 调用一个类的静态方法，它将返回一个 Class Object，然后再调用相应方法或属性</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initValue&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;T(java.lang.Math).PI&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>SpEL 支持的运算符号：</p>
<ul>
<li>算数运算符：+,-,*,/,^</li>
<li>加号也能用作字符串的连接</li>
<li>比较运算符：&lt;,&gt;,==,&lt;=,&gt;=,lt,gt,eg,le,ge </li>
<li>逻辑运算符：and,or,not,|</li>
<li>三目运算符</li>
<li>正则表达式：matches</li>
</ul>
</li>
</ul>
<hr>
<h5 id="IOC-容器中-Bean-的生命周期"><a href="#IOC-容器中-Bean-的生命周期" class="headerlink" title="IOC 容器中 Bean 的生命周期"></a>IOC 容器中 Bean 的生命周期</h5><ul>
<li>Spring IOC 容器可以管理 Bean 的生命周期，Spring 允许在 Bean 生命周期的特定点执行定制的任务</li>
<li>Spring IOC 容器对 Bean 的生命周期进行管理的过程：<ul>
<li>通过构造器或工厂方法创建 Bean 实例</li>
<li>为 Bean 的属性设置值和对其他 Bean 的引用</li>
<li>调用 Bean 的初始化方法</li>
<li>Bean 可用</li>
<li>当容器关闭时，调用 Bean 的销毁方法</li>
</ul>
</li>
<li>在 Bean 的声明里设置 init-method 和 destroy-method 属性，为 Bean 指定初始化方法和销毁方法</li>
<li>Bean 后置处理器允许在调用初始化方法前后对 Bean 进行额外的处理</li>
<li>Bean 后置处理器对 IOC 容器里的所有 Bean 实例逐一处理，而非单一实例，其典型应用是检查 Bean 属性的正确性或根据特定的标准更改 Bean 的属性</li>
<li>对 Bean 后置处理器而言，需要实现 org.springframework.beans.factory.config.BeanPostProcessor 接口，在初始化方法被调用前后，Spring 将把每个 Bean 实例分别传递给上述接口的 postProcessAfterInitialization(Object, String) 与 postProcessBeforeInitialization(Object, String) 这两个方法</li>
<li>添加了 Bean 后置处理器后 Bean 的生命周期：<ul>
<li>通过构造器或工厂方法创建 Bean 实例</li>
<li>为 Bean 的属性设置值和对其他 Bean 的引用</li>
<li>将 Bean 实例传递给 Bean 后置处理器的 postProcessBeforeInitialization 方法</li>
<li>调用 Bean 的初始化方法</li>
<li>将 Bean 实例传递给 Bean 后置处理器的 postProcessAfterInitialization 方法</li>
<li>Bean 可用</li>
<li>当容器关闭时，调用 Bean 的销毁方法</li>
</ul>
</li>
</ul>
<hr>
<h5 id="Spring-4-x-新特性：泛型依赖注入"><a href="#Spring-4-x-新特性：泛型依赖注入" class="headerlink" title="Spring 4.x 新特性：泛型依赖注入"></a>Spring 4.x 新特性：泛型依赖注入</h5><ul>
<li>Spring 4.x 中可以为子类注入子类对应的泛型类型的成员变量的引用</li>
</ul>
<hr>
<h5 id="整合多个配置文件"><a href="#整合多个配置文件" class="headerlink" title="整合多个配置文件"></a>整合多个配置文件</h5><ul>
<li><p>Spring 允许通过 &lt;import&gt; 将多个配置文件引入到一个文件中，进行配置文件的集成，这样在启动 Spring 容器时，仅需要指定这个合并好的配置文件即可</p>
</li>
<li><p>&lt;import&gt; 元素的 resource 属性支持 Spring 标准的路径资源</p>
<table>
<thead>
<tr>
<th align="center">地址前缀</th>
<th align="center">示例</th>
<th align="center">对应资源类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">classpath:</td>
<td align="center">classpath:spring-mvc.xml</td>
<td align="center">从类路径下加载资源，classpath: 和 classpath:/ 是等价的</td>
</tr>
<tr>
<td align="center">file:</td>
<td align="center">file:/conf/security/spring-shiro.xml</td>
<td align="center">从文件系统目录中加载资源，可采用绝对或相对路径</td>
</tr>
<tr>
<td align="center">http://</td>
<td align="center"><a href="http://xxx.xxx/resources/beans.xml">http://xxx.xxx/resources/beans.xml</a></td>
<td align="center">从 Web 服务器中加载资源</td>
</tr>
<tr>
<td align="center">ftp://</td>
<td align="center"><a href="ftp://xxx.xxx/resources/beans.xml">ftp://xxx.xxx/resources/beans.xml</a></td>
<td align="center">从 FTP 服务器中加载资源</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h5 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h5><ul>
<li>代码混乱与代码分散问题</li>
<li>AOP（ Aspect-Oriented Programming），是一种新的方法论，是对传统 OOP 的补充<ul>
<li>连接点（ join point ）：在程序执行过程中某个特定的点，通常在这些点添加关注点的功能，比如某方法调用的时候或者处理异常的时候，在 Spring AOP 中，一个连接点总是代表一个方法的执行，表示”在什么地方做“。Spring 中只有方法是连接点，属性不能是连接点，也就是说只能切入方法</li>
<li>切入点（ pointcut ）：匹配连接点的断言，通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行，比如在执行某个特定名称的方法时。切入点表达式如何与连接点匹配是 AOP 的核心，Spring 默认使用 AspectJ 切入点语法</li>
<li>通知（ advice ）：在切面的某个特定的连接点上执行的动作。通知有各种类型，其中包括 around、before、after 等通知。以拦截器为通知模型，并维护一个以连接点为中心的拦截器链，表示”具体怎么做“</li>
<li>引入（ introduction ）：也被称为内部类型声明（ inter-type declaration ），为已有的类声明额外的方法或者某个类型的字段。Spring 允许引入新的接口（以及一个对应的实现类）到任何被代理的对象</li>
<li>目标对象（ target object ）：被一个或多个切面所通知的对象，Spring AOP 是通过运行时代理实现的，故这个对象永远是一个被代理对象</li>
<li>织入（ weaving ）：把切面连接到其他的应用程序类型或者对象上，并创建一个被通知的对象的过程。也就是说织入是一个过程，是将切面应用到目标对象从而创建出 AOP 代理对象的过程。这些可以在编译时，类加载时和运行时完成。Spring 在运行时完成织入</li>
<li>切面（ Aspect ）：切面将切入点、引入、目标对象等信息集结在一起，从而定义相应的织入规则，这样一个整体称为切面。一个关注点的模块化，这个关注点可能会横切多个对象，综合表示”在什么地方，要做什么，以及具体如何做“</li>
</ul>
</li>
<li>基于 AspectJ 注解方式<ul>
<li>启用 AspectJ 注解<ul>
<li>在 Spring 应用中使用 AspectJ 注解，必须在 classspath 下包含 AspectJ 类库：aopalliance.jar、aspectj.weaver.jar、spring-aspects.jar</li>
<li>将 aop Schema 添加到 &lt;beans&gt; 根元素中</li>
<li>在 Spring IOC 容器中启用 AspectJ 注解支持，只需要在 Bean 配置文件中定义一个空的 XML 元素 &lt;aop:aspectj-autoproxy&gt;</li>
<li>当 Spring IOC 容器检测到 Bean 配置文件中的 &lt;aop:aspectj-autoproxy&gt; 元素时，会自动为与 AspectJ 切面匹配的 Bean 创建代理</li>
</ul>
</li>
<li>使用 AspectJ 注解声明切面<ul>
<li>在 Spring 中声明 AspectJ 切面，需要在 IOC 容器中将切面声明为 Bean 实例。当在 Spring IOC 容器中初始化 AspectJ 切面之后，Spring IOC 容器就会为那些与 AspectJ 切面相匹配的 Bean 创建代理</li>
<li>在 AspectJ 注解中，切面只是一个带有 @Aspect 注解的 Java 类</li>
<li>通知是标注有某种注解的简单的 Java 方法</li>
<li>AspectJ 支持 5 种类型的通知注解<ul>
<li>@Before：前置通知，在目标方法执行之前执行</li>
<li>@After：后置通知，在目标方法执行之后执行（无论是否出现异常）。注：在后置通知中不能访问目标方法的执行结果</li>
<li>@AfterReturning：返回通知，在目标方法返回结果之后执行。注：返回通知是可以访问到目标方法的执行结果的（注解中的 returning 属性，这个属性的值即为用来传入返回值的参数名称。原始的切点表达式需要出现在 pointcut 属性中）</li>
<li>@AfterThrowing：异常通知，在目标方法抛出异常之后执行。注：可以访问到异常对象，且可以指定在出现特定异常时再执行通知（将 throwing 属性添加到注解中）</li>
<li>@Around：环绕通知，围绕着方法执行<ul>
<li>环绕通知是所有通知类型中功能最全的，能够全面控制连接点，甚至可以控制是否执行连接点</li>
<li>对于环绕通知来说，连接点的参数类型必须是 ProceedingJoinPoint，它是 JoinPoint 的子接口，允许控制何时执行，是否执行连接点</li>
<li>在环绕通知中需要明确调用 ProceedingJoinPoint 的 proceed() 方法来执行被代理的方法，如果忘记这样做就会导致通知被执行了，但是目标方法没有被执行</li>
<li>注意：环绕通知的方法需要返回目标方法执行之后的结果，即调用 joinPoint.proceed(); 的返回值，否则会出现空指针异常</li>
</ul>
</li>
</ul>
</li>
<li>利用方法签名编写 AspectJ 切入点表达式<ul>
<li>execution * com.aaa.Test.*(..)：匹配 Test 中声明的所有方法，第一个 * 表示任意修饰符及任意返回值，第二个 * 表示任意方法，.. 表示匹配任意数量的参数。若目标类和接口与该切面在同一个包内，可以省略包名</li>
<li>execution public * Test.*(..)：匹配 Test 接口的所有 public 方法</li>
<li>execution public double Test.*(..)：匹配 Test 中返回 double 类型数值的方法</li>
<li>execution public double Test.*(double, ..)：匹配第一个参数为 double 类型的方法，.. 匹配任意数量任意类型的参数</li>
<li>execution public double Test.*(double, double)：匹配任意参数类型为 double, double 类型的方法</li>
</ul>
</li>
<li>在 AspectJ 中，切入点表达式可以通过操作符 &amp;&amp;，||，! 等结合在一起<ul>
<li>execution * *.add(int, ..) || execution * *.sub(int, ..)</li>
</ul>
</li>
<li>可以在通知方法中声明一个类型为 JoinPoint 的参数，然后就能访问连接细节，比如方法名称和参数值等</li>
<li>指定切面的优先级<ul>
<li>在同一个连接点上应用不止一个切面时，除非明确指定，否则它们的优先级是不确定的</li>
<li>切面的优先级可以通过实现 org.springframework.core.Ordered 接口或利用 @Order 注解指定</li>
<li>实现 org.springframework.core.Ordered 接口，getOrder() 方法的返回值越小，优先级越高。若使用 @Order 注解，则需要在注解中加入优先级，例如 @Order(1)、@Order(2) 等</li>
</ul>
</li>
<li>重用切入点定义<ul>
<li>在编写 AspectJ 切面时，可以直接在通知注解中写切入点表达式，但是同一个切入点表达式可能会出现在多个通知中</li>
<li>在 AspectJ 中，可以通过 @Pointcut 注解将一个切入点声明成简单的方法，切入点的方法体通常是空的，因为将切入点定义与代码逻辑混在一起是不合理的</li>
<li>切入点方法的访问控制符同时也控制着这个切入点的可见性，如果切入点需要在多个切面中共用，最好将它们集中在一个公共的类中，在这种情况下，它们必须被声明为 public，在引入这个切入点时，必须将类名也包括在内，如果类没有与这个切面放在同一个包里，还需要包含其包名。其他通知利用通过该方法引入该切点</li>
</ul>
</li>
<li>引入通知<ul>
<li>引入通知允许动态的往目标类中插入新的目标方法</li>
<li>在切面中，通过为任意字段添加 @DeclareParents 注解来引入声明</li>
<li>注解类型的 value 属性表示哪些类是当前引入通知的目标，value 属性也可以是一个 AspectJ 类型的表达式，以将一个接口引入到多个类中，defaultImpl 属性中指定这个接口使用的实现类</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>基于 XML 配置的 AOP<ul>
<li>声明切面<ul>
<li>在 &lt;beans&gt; 根元素中导入 aop Schema</li>
<li>在 Bean 配置文件中，所有的 Spring AOP 配置都必须定义在 &lt;aop:config&gt; 元素内部，对于每个切面而言，都要创建一个 &lt;aop:config&gt; 元素来为具体的切面实现引用后的 Bean 实例</li>
<li>切面 Bean 必须有一个标示符，供 &lt;aop:aspect&gt; 元素引用</li>
</ul>
</li>
<li>声明切入点<ul>
<li>切入点使用 &lt;aop:pointcut&gt; 元素声明</li>
<li>切入点必须定义在 &lt;aop:aspect&gt; 元素下，或者直接定义在 &lt;aop:config&gt; 元素下<ul>
<li>定义在 &lt;aop:aspect&gt; 元素下：只对当前切面有效</li>
<li>定义在 &lt;aop:config&gt; 元素下：对所有切面都有效</li>
</ul>
</li>
<li>基于 XML 的 AOP 配置不允许在切入点表达式中用名称引用其他的切入点</li>
</ul>
</li>
<li>声明通知<ul>
<li>在 aop Schema 中，每种通知类型都对应一个特定的 XML 元素</li>
<li>通知元素需要使用 &lt;pointcut-ref&gt; 来引用切入点，或用 &lt;pointcut&gt; 直接嵌入切入点表达式，method 属性指定切面类中通知方法的名称</li>
</ul>
</li>
<li>声明引入<ul>
<li>可以使用 &lt;aop:declare-parents&gt; 元素在切面内部声明引入</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h5><ul>
<li><p>JDBC Template</p>
<ul>
<li><p>为了使 JDBC 更加易于使用，Spring 在 JDBC API 上定义了一个抽象层</p>
</li>
<li><p>作为 Spring JDBC 的核心，JDBC Template 的设计目的是为不同类型的 JDBC 操作提供模板方法，每个模板方法都能控制整个过程，并允许覆盖过程中的特定任务，通过这种方式，可以在尽可能保留灵活性的情况下，将数据库存取的工作量降到最低</p>
</li>
<li><p>常用方法</p>
<ul>
<li>用 SQL 语句和参数更新数据库：<code>public int update(String sql, Object... args) throws DataAccessException</code></li>
<li>批量更新数据库：<code>public int[] batchUpdate(String sql, List&lt;Object[]&gt; batchArgs)</code></li>
<li>查询单行：<code>public &lt;T&gt; T queryForObject(String sql, ParameterizeRiwMapper&lt;T&gt; rm, Object... args) throws DataAccessException</code></li>
<li>便利的 BeanPropertyRowMapper 实现：org.springframework.jdbc.core.BeanPropertyRowMapper&lt;T&gt;</li>
<li>查询多行：<code>public &lt;T&gt; List&lt;T&gt; query(String sql, ParameterizeRiwMapper&lt;T&gt; rm, Object... args) throws DataAccessException</code></li>
<li>单值查询：<code>public &lt;T&gt; T queryForObject(String sql, Class&lt;T&gt; requiredType, Object... args) throws DataAccessException</code></li>
</ul>
</li>
<li><p>简化 JDBC 模板查询</p>
<ul>
<li><p>JdbcTemplate 类被设计成线程安全的，所以可以在 IOC 容器中声明它的单个实例，并将这个实例注入到所有的 DAO 实例中</p>
</li>
<li><p>JDBC Template 也利用了 JDK1.5 的特性（自动装箱、泛型、可变长参数等）来简化开发</p>
</li>
<li><p>Spring JDBC 还提供了一个 JdbcDaoSupport 类来简化 DAO 实现，该类声明了 jdbcTemplate 属性，它可以从 IOC 容器中注入，或者自动从数据源中创建</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注入 JDBC 模板示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;personDAO&quot;</span> <span class="attr">class</span>=<span class="string">&quot;xxx.xxx.PersonDAO&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jdbcTemplate&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 扩展 JdbcDaoSupport 示例 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- public class PersonDAO extends JdbcDaoSupport &#123; &#125; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;personDAO&quot;</span> <span class="attr">class</span>=<span class="string">&quot;xxx.xxx.PersonDAO&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>在 JDBC Template 中使用命名参数</p>
<ul>
<li>在标准的 JDBC 用法中 SQL 参数是用占位符 “?” 来表示的，并且受到位置的限制。定位参数的问题在于，一旦参数的顺序发生改变，就必须改变参数绑定</li>
<li>在 Spring JDBC 中，绑定 SQL 参数的另一种选择是使用命名参数（ named parameter）</li>
<li>命名参数：SQL 按名称（以冒号开头）而不是按位置进行指定，命名参数更易维护，也提升了可读性，命名参数由框架类在运行时用占位符替代</li>
<li>命名参数只在 NamedParameterJdbcTemplate 中得到支持</li>
<li>在 SQL 语句中使用命名参数时，可以在一个 Map 中提供参数值，参数名为键。也可以使用 SqlParameterSource 参数</li>
<li>批量更新时可以提供 Map 或者 SqlParameterSource 的数组</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="Spring-的事务管理"><a href="#Spring-的事务管理" class="headerlink" title="Spring 的事务管理"></a>Spring 的事务管理</h5><ul>
<li><p>事务管理用来确保数据的完整性和一致性</p>
</li>
<li><p>事务就是一系列的动作，它们被当作一个单独的工作单元，这些动作要么全部完成，要么全部都不起作用</p>
</li>
<li><p>事务的四个关键属性（ ACID ）</p>
<ul>
<li>原子性（ atomicity ）：事务是一个原子操作，由一系列动作组成，事务的原子性确保动作要么全部完成要么完全不起作用</li>
<li>一致性（ consistency ）：一旦所有的事务动作完成，事务就被提交，数据和资源就处于一种满足业务规则的一致性状态中</li>
<li>隔离性（ isolation ）：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏</li>
<li>持久性（ durability ）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，通常情况下，事务的结果被写到持久化存储器中</li>
</ul>
</li>
<li><p>Spring 中的事务管理</p>
<ul>
<li><p>Spring 在不同的事务管理 API 之上定义了一个抽象层，而开发者不必了解底层的事务管理 API，就可以使用 Spring 的事务管理机制</p>
</li>
<li><p>Spring 既支持编程式事务管理也支持声明式事务管理</p>
<ul>
<li>编程式事务管理：将事务管理代码嵌入到业务方法中来控制事务的提交和回滚，在使用编程式事务管理时，必须在每个事务操作中包含额外的事务管理代码</li>
<li>声明式事务管理：它将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。Spring 通过 Spring AOP 来进行声明式事务管理</li>
</ul>
</li>
<li><p>Spring 的核心事务管理抽象是 org.springframework.transaction.PlatformTransactionManager</p>
<ul>
<li>org.springframework.jdbc.datasource.DataSourceTransactionManager：在应用程序中只需要处理一个数据源，而通过 JDBC 存取</li>
<li>org.springframework.transaction.jta.JtaTransactionManager：在 JavaEE 应用服务器上用 JTA（ Java Transaction API ）进行事务管理</li>
<li>HibernateTransactionManager：用 Hibernate 框架存取数据库</li>
<li>注：事务管理器以普通的 Bean 形式声明在 Spring IOC 容器中</li>
</ul>
</li>
<li><p>用事务通知声明式地管理事务</p>
<ul>
<li><p>启用声明式事务管理可以通过 tx Schema 中定义的 &lt;tx:advice&gt; 元素声明事务通知，为此需要将 tx Schema 定义添加到 &lt;beans&gt;</p>
</li>
<li><p>声明了事务通知后，需要将其与切入点关联，由于事务通知是在 &lt;aop:config&gt; 元素外声明的，所以它无法直接与切入点关联，必须在 &lt;aop:config&gt; 元素中声明一个增强器通知与切入点关联</p>
</li>
<li><p>由于 Spring AOP 是基于代理的方法，故只能增强 public 方法。故只有 public 方法才能通过 Spring AOP 进行事务管理</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 事务通知声明式管理事务示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookShopService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;xx.xx.BookShopServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookShopDAO&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDAO&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 声明事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 声明事务通知 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;bookShopTxAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 声明事务通知需要通知的方法（即需要进行事务管理的方法） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *.BookShopService.*(..))&quot;</span> <span class="attr">id</span>=<span class="string">&quot;bookShopOperation&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:pointcut</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;bookShopTxAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;bookShopOperation&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>用 @Transactional 注解声明式地管理事务</p>
<ul>
<li><p>除了在带有切入点，通知和增强器的 Bean 配置文件中声明事务以外，Spring 还允许简单的使用 @Transactional 注解来标注事务方法</p>
</li>
<li><p>为了将方法定义为支持事务处理的，可以为方法添加 @Transactional 注解，根据 Spring AOP 的机制，只能标注 public 方法</p>
</li>
<li><p>可以在类级别上添加 @Transactional 注解，应用到类上时，这个类中所有的 public 方法都将支持事务处理</p>
</li>
<li><p>在 Bean 配置文件中启用 &lt;tx:annotation-driven&gt; 元素，并为之指定事务管理器即可</p>
</li>
<li><p>若事务管理器的名称为 transactionManager，则可以在 &lt;tx:annotation-driven&gt; 元素中省略 transaction-manager 属性，因为它会自动检测该名称的事务管理器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- @Transactional 注解声明式管理事务的配置文件示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;xxx.xxx.transaction&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>事务传播属性</p>
<ul>
<li><p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播，Spring 定义了 7 种类型的传播行为</p>
<table>
<thead>
<tr>
<th align="center">传播属性</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">REQUIRED(默认)</td>
<td align="center">若有事务在运行，当前的方法就在这个事务内运行，否则就启动一个新的事务，并在自己的事务内运行</td>
</tr>
<tr>
<td align="center">REQUIRED_NEW</td>
<td align="center">当前的方法必须启动新事务，并在它自己的事务内运行，如果有事务正在运行，应该将它挂起</td>
</tr>
<tr>
<td align="center">SUPPORTS</td>
<td align="center">如果有事务在运行，当前的方法就在这个事务内运行，否则它可以不运行在事务中</td>
</tr>
<tr>
<td align="center">NOT_SUPPORTS</td>
<td align="center">当前的方法不应该运行在事务中，如果有运行的事务，将它挂起</td>
</tr>
<tr>
<td align="center">MANDATORY</td>
<td align="center">当前的方法必须运行在事务内部，如果没有正在运行的事务，就抛出异常</td>
</tr>
<tr>
<td align="center">NEVER</td>
<td align="center">当前的方法不应该运行在事务中，如果有运行的事务，就抛出异常</td>
</tr>
<tr>
<td align="center">NESTED</td>
<td align="center">如果有事务在运行，当前的方法就应该在这个事务的嵌套事务内运行，否则就启动一个新的事务，并在它自己的事务内运行</td>
</tr>
</tbody></table>
</li>
<li><p>事务传播属性可以在 @Transactional 注解的 propagation 属性中定义。也可以在 &lt;tx:advice&gt; 元素中添加 &lt;tx:attributes&gt; 元素，然后在 &lt;tx:attributes&gt; 元素中添加 &lt;tx:method&gt; 元素来设定传播属性</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 事务的传播属性 XML 配置示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;bookShopTxAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;methodName&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRES_NEW&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:method</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>并发事务导致的问题</p>
<ul>
<li>脏读</li>
<li>不可重复读</li>
<li>幻读</li>
</ul>
</li>
<li><p>事务的隔离级别</p>
<ul>
<li><p>Spring 支持的事务隔离级别</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DEFAULT</td>
<td align="center">使用底层数据库的默认隔离级别，对于大多数数据库来说，默认隔离级别都是 READ_COMMITED</td>
</tr>
<tr>
<td align="center">READ_UNCOMMITED</td>
<td align="center">允许事务读取未被其他事务提交的变更，脏读，不可重复读和幻读的问题都会出现</td>
</tr>
<tr>
<td align="center">READ_COMMITED</td>
<td align="center">只允许事务读取已经被其他事务提交的变更，可以避免脏读，但不可重复读和幻读的问题仍然可能出现</td>
</tr>
<tr>
<td align="center">REPEATABLE_READ</td>
<td align="center">确保事务可以多次从一个字段中读取相同的值，在这个事务持续期间，禁止其他事务对这个字段进行更新，可以避免脏读和不可重复读，但幻读的问题仍然存在</td>
</tr>
<tr>
<td align="center">SERIALIZEABLE</td>
<td align="center">确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他事务对该表执行插入，更新和删除操作，所有并发问题都可以避免，但性能非常低</td>
</tr>
</tbody></table>
</li>
<li><p>事务的隔离级别是需要底层数据库引擎库支持，而不是应用程序或框架的支持</p>
</li>
<li><p>Oracle 支持的两种事务隔离级别：READ_COMMITED、SERIALIZEABLE</p>
</li>
<li><p>Mysql 支持四种事务隔离级别</p>
</li>
<li><p>设置隔离事务属性</p>
<ul>
<li>用 @Transactional 注解声明式地管理事务时可以在 @Transactional 的 isolation 属性中设置隔离级别</li>
<li>也可以在配置文件中指定（同传播属性配置方式）</li>
</ul>
</li>
</ul>
</li>
<li><p>设置回滚事务属性</p>
<ul>
<li>默认情况下只有未检查异常（ RuntimeException 和 Error 类型的异常）会导致事务回滚，而受检查异常不会</li>
<li>事务的回滚规则可以通过 @Transactional 注解的 rollbackFor 和 nonRollbackFor 属性来定义，这两个属性被声明为 Class[] 类型的，因此可以为这两个属性指定多个异常类<ul>
<li>rollbackFor：遇到时必须进行回滚</li>
<li>nonRollbakcFor：遇到时必须不回滚</li>
</ul>
</li>
<li>在配置文件中指定的方式与传播属性配置方法相同，如果有不止一种异常，用逗号分隔</li>
</ul>
</li>
<li><p>设置超时和只读属性</p>
<ul>
<li>超时事务属性：事务在强制回滚之前可以保持多久，这样可以防止长期运行的事务占用资源</li>
<li>只读事务属性：表示这个事务只读取数据但不更新数据，这样可以帮助数据库引擎优化事务</li>
<li>超时（ timeout ）和只读（ readOnly ）属性可以在 @Transactional 注解中定义，超时属性以秒为单位</li>
<li>在配置文件中指定的方式与传播属性配置方法相同</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="Spring-整合-Hibernate"><a href="#Spring-整合-Hibernate" class="headerlink" title="Spring 整合 Hibernate"></a>Spring 整合 Hibernate</h5><ul>
<li><p>Spring 整合 Hibernate 是为了让 IOC 容器来管理 Hibernate 的 SessionFactory 以及让 Hibernate 使用 Spring 的声明式事务（注：不推荐使用 HibernateTemplate 和 HibernateDaoSupport，因为使用它们会导致 Hibernate 与 Spring 的耦合）</p>
</li>
<li><p>在 Spring 中配置 SessionFactory</p>
<ul>
<li>可以使用 LocalSessionFactoryBean 工厂 Bean 来声明一个使用 XML 映射文件的 SessionFactory 实例</li>
<li>需要为该工厂 Bean 指定 configLocation 属性来加载 Hibernate 配置文件或者直接使用 hibernateProperties 属性来设定 Hibernate 的配置</li>
<li>如果在 Spring IOC 容器中配置数据源，可以将该数据源注入到 LocalSessionFactoryBean 的 dataSource 属性中，该属性指定的数据源会覆盖掉 Hibernate 配置文件中的数据库配置</li>
<li>可以在 LocalSessionFactoryBean 的 mappingResources 属性中指定 XML 映射文件的位置，该属性为 String[] 类型，因此可以指定一组映射文件</li>
</ul>
</li>
<li><p>使用 Spring 的 ORM 模板持久化对象</p>
<ul>
<li>同 JDBC 一样，Spring 采取了相同的方法，即定义模板类和 DAO 支持类来简化 ORM 框架的使用，而且 Spring 在不同的事务管理 API 之上定义了一个事务抽象层，对于不同的 ORM 框架，只需要选择相应的事务管理器实现即可</li>
</ul>
</li>
<li><p>Spring 对不同数据存储策略的支持类</p>
<table>
<thead>
<tr>
<th align="center">支持类</th>
<th align="center">JDBC</th>
<th align="center">Hibernate</th>
</tr>
</thead>
<tbody><tr>
<td align="center">模板类</td>
<td align="center">JdbcTemplate</td>
<td align="center">HibernateTemplate</td>
</tr>
<tr>
<td align="center">DAO 支持类</td>
<td align="center">JdbcDaoSupport</td>
<td align="center">HibernateDaoSupport</td>
</tr>
<tr>
<td align="center">事务管理类</td>
<td align="center">DataSourceTransactionManager</td>
<td align="center">HibernateTransactionManager</td>
</tr>
</tbody></table>
<ul>
<li>HibernateTemplate 确保了 Hibernate Session 能够正确的打开和关闭</li>
<li>HibernateTemplate 也会让原生的 Hibernate 事务参与到 Spring 的事务管理中体系中，从而利用 Spring 的声明式事务管理事务</li>
<li>HibernateTemplate 中的模板方法管理 Session 和事务，如果在一个支持事务的 DAO 方法中有多个 Hibernate 操作，模板方法可以确保它们会在同一个 Session 和事务中运行，因此没有必要为了 Session 和事务管理去和 Hibernate API 打交道</li>
<li>通过为 DAO 方法添加 @Transactional 注解将其声明为受事务管理的</li>
<li>HibernateTemplate 类是线程安全的，因此可以在 Bean 配置文件中只声明一个实例，然后将其注入到所有的 Hibernate DAO 中</li>
<li>Hibernate DAO 可以通过继承 HibernateDaoSupport 来继承 setSessionFactory() 和 setHibernateTemplate() 方法，然后，只要在 DAO 方法中调用 getHibernateTemplate() 方法就可以获取到模板实例</li>
<li>如果为 HibernateDaoSupport 实现类注入了 SessionFactory 实例就不需要再为之注入 HibernateTemplate 实例了。因为 HibernateDaoSupport 会根据传入的 SessionFactory 在其构造器内创建 HibernateTemplate 实例并赋给 hibernateTemplate 属性</li>
</ul>
</li>
<li><p>使用 Hibernate 的上下文 Session 持久化对象</p>
<ul>
<li><p>Spring 的 HibernateTemplate 可以管理 Session 和事务，简化 DAO 的实现，但是如果要使用 HibernateTemplate 就意味着 DAO 必须依赖于 Spring</p>
</li>
<li><p>Hibernate 上下文 Session 对象和 Spring 的事务管理结合的很好，但此时需要保证所有的 DAO 方法都支持事务。此时不需要在 Bean 配置文件中配置，因为 Spring 已经开始事务了，只需在 ThreadLoacl 对象中绑定 Session 对象即可</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">prop</span> <span class="attr">keys</span>=<span class="string">&quot;hibernate.current_session_context_class&quot;</span>&gt;</span>thread<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>为了保持一致的异常处理方法，即把 Hibernate 异常转换为 Spring 的 DataAccessException 异常，那么必须为需要转换的 DAO 类添加 @Repository 注解，然后再注册一个 org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor 实例，将原生的 Hibernate 异常转换为 Spring 的 DataAccessException 层次结构中的数据存取异常，这个 Bean 后置处理器只为添加了 @Repository 注解的 Bean 转换异常</p>
</li>
<li><p>从 Hibernate3 开始，SessionFactory 新增了一个 getCurrentSession() 方法，该方法可直接获取上下文相关的 Session</p>
</li>
<li><p>Hibernate 通过 CurrentSessionContext 接口的实现类和配置参数 hibernate.current_session_context_class 定义上下文</p>
<ul>
<li>JTASessionContext：根据 JTA 来跟踪和界定 Session 对象</li>
<li>ThreadLocalSessionContext：通过当前正在执行的线程来跟踪和界定 Session 对象</li>
<li>ManagedSessionContext</li>
</ul>
</li>
<li><p>若使用的为 ThreadLocalSessionContext 策略，Hibernate 的 Session 会随着 getCurrentSession() 方法自动打开，随着事务提交而自动关闭</p>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="在-Web-应用中使用-Spring"><a href="#在-Web-应用中使用-Spring" class="headerlink" title="在 Web 应用中使用 Spring"></a>在 Web 应用中使用 Spring</h5><ul>
<li>通过注册 Servlet 监听器 ContextLoaderListener，Web 应用程序可以加载 Spring 的 ApplicationContext 对象，这个监听器会将加载好的 ApplicationContext 对象保存到 Web 应用程序的 ServletContext 中，随后，Servlet 或者可以访问 ServletContext 的任意对象就能通过一个辅助方法来使用 Spring IOC 容器中的对象了</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Hibernate</title>
    <url>/Hibernate/Hibernate/</url>
    <content><![CDATA[<h5 id="ORM-的思想"><a href="#ORM-的思想" class="headerlink" title="ORM 的思想"></a>ORM 的思想</h5><ol>
<li>将关系数据库中记录映射为对象，以对象的形式展现，可以把对数据库的操作转化为对对象的操作<a id="more"></a></li>
</ol>
<hr>
<h5 id="Hibernate-开发步骤"><a href="#Hibernate-开发步骤" class="headerlink" title="Hibernate 开发步骤"></a>Hibernate 开发步骤</h5><ol>
<li>创建 Hibernate 配置文件</li>
<li>创建持久化类</li>
<li>创建对象-关系映射文件</li>
<li>通过 Hibernate API 编写访问数据库的代码</li>
</ol>
<hr>
<h5 id="HibernateTool-For-Eclipse-安装"><a href="#HibernateTool-For-Eclipse-安装" class="headerlink" title="HibernateTool For Eclipse 安装"></a>HibernateTool For Eclipse 安装</h5><ol>
<li><a href="http://download.jboss.org/jbosstools/oxygen/stable/updates/">Install Software 链接</a></li>
<li><a href="https://tools.jboss.org/downloads/">JBoss 官网</a></li>
<li><a href="http://hibernate.org/tools/">Hibernate Tools 官网</a></li>
</ol>
<hr>
<h5 id="Configuration-类"><a href="#Configuration-类" class="headerlink" title="Configuration 类"></a>Configuration 类</h5><ol>
<li><p>Configuration 类负责管理 Hibernate 的配置信息，包括以下内容：</p>
<ul>
<li>Hibernate 运行的底层信息：数据库的 URL、用户名、密码、JDBC 驱动类、数据库 Dialect（方言）、数据库连接池等（对应 <code>hibernate.cfg.xml</code> 文件）</li>
<li>持久化类与数据表的映射关系（ <code>*.hbm.xml</code> 文件）</li>
</ul>
</li>
<li><p>创建 Configuration 的两种方式</p>
<ul>
<li><p>属性文件（ <code>hibernate.properties</code> ）</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration();</span><br></pre></td></tr></table></figure>
</li>
<li><p>XML 文件（ <code>hibernate.cfg.xml</code> ）</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Configuration configuration  = <span class="keyword">new</span> Configuration().configure();</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：Configuration 的 <code>configure()</code> 方法还支持带参数的访问</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;example.xml&quot;</span>);</span><br><span class="line">Configuration configuration  = <span class="keyword">new</span> Configuration().configure(file);</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<hr>
<h5 id="SessionFactory-接口"><a href="#SessionFactory-接口" class="headerlink" title="SessionFactory 接口"></a>SessionFactory 接口</h5><ol>
<li><p>针对单个数据库映射关系经过编译后的内存镜像，是线程安全的</p>
</li>
<li><p>SessionFactory 对象一旦构造完毕，即被赋予特定的配置信息</p>
</li>
<li><p>SessionFactory 是生成 Session 的工厂</p>
</li>
<li><p>构造 SessionFactory 很消耗资源，一般情况下一个应用中只初始化一个 SessionFactory 对象</p>
</li>
<li><p>Hibernate4 新增了一个 ServiceRegistry 接口，所有基于 Hibernate 的配置或者服务都必须统一向这个 ServiceRegistry 注册后才能生效</p>
</li>
<li><p>Hibernate4 中创建 SessionFactory 的步骤</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Configuration对象</span></span><br><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取ServiceRegistry对象</span></span><br><span class="line">ServiceRegistry serviceRegistry = <span class="keyword">new</span> ServiceRegistryBuilder().applySettings(configuration.getProperties()).buildServiceRegistry();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建SessionFactory对象</span></span><br><span class="line">SessionFactory sessionFactory = configuration.buildSessionFactory(serviceRegistry);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h5 id="Session-接口"><a href="#Session-接口" class="headerlink" title="Session 接口"></a>Session 接口</h5><ol>
<li>Session 是应用程序与数据库之间交互操作的一个<strong>单线程对象</strong>，是 Hibernate 运作的中心，所有持久化对象必须在 Session 的管理下才可以进行持久化操作。此对象的生命周期很短。Session 对象有一个一级缓存，显式执行 <code>flush()</code> 之前，所有的持久层操作的数据都缓存在 Session 对象处。相当于 JDBC 中的 Connection，实际上是对 Connection 的封装</li>
<li>Session 接口是 Hibernate 向应用程序提供的操纵数据库的最主要的接口，他提供了基本的<strong>保存，更新，删除和加载 Java 对象</strong>的方法。Session 具有一个一级缓存，位于缓存中的对象称为持久化对象，他和数据库中的相关记录对应。Session 能够在某些时间点，按照缓存中对象的变化来执行相关的 SQL 语句，来同步更新数据库，这一过程被称为刷新缓存（ flush ）。站在持久化的角度，Hibernate 把对象分为四种状态，分别是<strong>持久化状态、临时状态、游离状态、删除状态</strong>等。Session 的特定方法能够将对象从一个状态转换到另外一个状态</li>
</ol>
<hr>
<h5 id="hibernate-cfg-xml-配置文件解释"><a href="#hibernate-cfg-xml-配置文件解释" class="headerlink" title="hibernate.cfg.xml 配置文件解释"></a>hibernate.cfg.xml 配置文件解释</h5><ol>
<li>hbm2ddl.auto<ul>
<li>有四个取值：<ul>
<li>create：会根据 <code>*.hbm.xml</code> 文件来生成数据表，但是每次运行都会删除上一次的表，重新生成表，哪怕第二次没有任何改变</li>
<li>create-drop：会根据 <code>*.hbm.xml</code> 文件来生成数据表，但是 SessionFactory 一关闭，生成的数据表就自动删除</li>
<li>update（最常用）：会根据 <code>*.hbm.xml</code> 文件来生成数据表，但是若 <code>*.hbm.xml</code> 文件中对应的数据表与数据库中对应的数据表结构不同才会更新数据表，不会删除已有的行和列</li>
<li>validate：会和数据库中的表进行比较，若 <code>*.hbm.xml</code> 文件中的列在数据表中不存在，则抛出异常，但不会做任何修改</li>
</ul>
</li>
</ul>
</li>
<li>format_sql<ul>
<li>是否将 SQL 转化为格式良好的 SQL （即格式化 SQL ），取值 true/false</li>
</ul>
</li>
<li>show_sql<ul>
<li>是否在控制台将 SQL 语句打印出来，取值 true/false</li>
</ul>
</li>
<li>dialect<ul>
<li>使用怎样的数据库方言，取值见 <code>hibernate\project\etc\hibernate.properties</code> 文件中</li>
</ul>
</li>
<li>connection.autocommit<ul>
<li>是否自动提交事务，取值 true/false</li>
</ul>
</li>
</ol>
<hr>
<h5 id="flush-缓存"><a href="#flush-缓存" class="headerlink" title="flush 缓存"></a>flush 缓存</h5><ol>
<li><p>flush：Session 按照缓存中对象的属性变化来同步更新数据库</p>
</li>
<li><p>默认情况下 Session 在以下时间点刷新缓存：</p>
<ul>
<li>显式调用 Session 的 <code>flush()</code> 方法</li>
<li>当应用程序调用 Transaction 的 <code>commit()</code> 方法时，该方法会先刷新缓存，然后再向数据库提交事务</li>
<li>当应用程序执行一些查询（ HQL，Criteria ）操作时，如果缓存中持久化对象的属性已经发生了变化，会先刷新缓存，以保证查询结果能够反映持久化对象的最新状态</li>
</ul>
</li>
<li><p>flush 缓存的例外情况：如果对象使用 native 生成器生成 OID，那么当调用 Session 的 <code>save()</code> 方法保存对象时，会立即执行向该数据库插入该实体的 INSERT 语句</p>
</li>
<li><p><code>commit()</code> 方法与 <code>flush()</code> 方法的区别：<code>flush()</code> 方法执行一系列 SQL 语句，但不提交事务；<code>commit()</code> 方法先调用 <code>flush()</code> 方法，然后提交事务，提交事务意味着对数据库的操作将永久保存下来</p>
</li>
<li><p>若希望改变 <code>flush()</code> 方法的默认刷新时间点，可以通过 Session 的 <code>setFlushMode()</code> 方法显式设定刷新的时间点</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>各种查询方法</th>
<th>Transaction 的 commit() 方法</th>
<th>Session 的 flush() 方法</th>
</tr>
</thead>
<tbody><tr>
<td>FlushMode.AUTO(默认模式)</td>
<td>刷新缓存</td>
<td>刷新缓存</td>
<td>刷新缓存</td>
</tr>
<tr>
<td>FlushMode.COMMIT</td>
<td>不刷新缓存</td>
<td>刷新缓存</td>
<td>刷新缓存</td>
</tr>
<tr>
<td>FlushMode.NEVER</td>
<td>不刷新缓存</td>
<td>不刷新缓存</td>
<td>刷新缓存</td>
</tr>
</tbody></table>
</li>
</ol>
<hr>
<h5 id="对象的三种状态"><a href="#对象的三种状态" class="headerlink" title="对象的三种状态"></a>对象的三种状态</h5><ol>
<li>Transient 瞬时状态<ul>
<li>在数据库中没数据，跟 Session 不相关，没存过</li>
<li>使用 new 操作符初始化的对象不是立刻就持久的。他们的状态是瞬时的，也就是说他们没有任何跟数据库表相关联的行为，只要应用不再去引用这些对象（不再被任何其他对象所引用），他们的状态就会丢失，并由垃圾回收机制回收</li>
</ul>
</li>
<li>Persistenet 持久化状态<ul>
<li>在数据库中有记录，Session 中也有记录，自动更新</li>
<li>持久化实例时任何具有数据库标识的实例，他由持久化管理器 Session 统一管理，持久化实例是在事务中进行操作的，他们的状态是在事务结束时同数据库进行同步，当事务提交时，通过执行 SQL 的 INSERT、UPDATE、DELETE 语句把内存中的状态同步到数据库中</li>
</ul>
</li>
<li>Detached 游离态<ul>
<li>在数据库中有记录，但是在 Session 中没有，需要手动同步</li>
<li>Session 关闭后，持久化对象就变成了游离对象，游离表示这个对象不能再和数据库保持同步，他们不再受 Hibernate 管理</li>
</ul>
</li>
<li>三种状态的区分<ul>
<li>Transient 对象：随时可能会被垃圾回收器回收（在数据库中没有与之对应的记录，因为是 new 初始化），没有纳入 Session 管理，而执行 <code>save()</code> 方法后，就变为 Persistent 对象。<strong>内存中一个对象，没有 ID，缓存中也没有</strong></li>
<li>Persistent 对象：在数据库中存在对应记录，纳入 Session 管理，在清理缓存（脏数据检查）时，会和数据库同步。<strong>内存中有，缓存中也有，数据库中有（ID）</strong></li>
<li>Detached 对象：可能被垃圾回收器回收掉（数据库中存在对应的记录，只是没有任何对象引用他是指 Session 引用），没有纳入 Session 管理。<strong>内存中有，缓存中没有，数据库中有（ID）</strong></li>
</ul>
</li>
</ol>
<hr>
<h5 id="Hibernate-主键生成策略"><a href="#Hibernate-主键生成策略" class="headerlink" title="Hibernate 主键生成策略"></a>Hibernate 主键生成策略</h5><ol>
<li>increment：适用于代理主键，由 Hibernate 自动以递增方式生成</li>
<li>identity：适用于代理主键，由底层数据库生成标识符</li>
<li>sequence：适用于代理主键，Hibernate 根据底层数据库的序列生成标识符，这要求底层数据库支持序列</li>
<li>hilo：适用于代理主键，Hibernate 使用 high/low 算法生成标识符</li>
<li>seqhilo：适用于代理主键，使用一个 high/low 算法来高效的生成 long，short 或者 int 类型的标识符</li>
<li>native：适用于代理主键，根据底层数据库自动生成标识符，自动选择 identity，sequence 或者 hilo</li>
<li>uuid.hex：适用于代理主键，Hibernate 采用 128 位的 UUID 算法生成标识符</li>
<li>uuid.string：适用于代理主键，UUID 被编码成一个 16 位字符长的字符串</li>
<li>assigned：适用于自然主键，由 Java 应用程序负责生成标识符</li>
<li>foreign：适用于代理主键，使用另外一个相关联的对象的标识符（外键）</li>
<li>注：常用 identity 和 native 方式</li>
</ol>
<hr>
<h5 id="refresh-方法与-clear-方法"><a href="#refresh-方法与-clear-方法" class="headerlink" title="refresh() 方法与 clear() 方法"></a>refresh() 方法与 clear() 方法</h5><ol>
<li><code>refresh()</code> 方法是强制将 Session 中的对象与数据表中的保持一致（发送一条 SELECT 语句）</li>
<li><code>clear()</code> 方法会将 Session 中缓存的所有的对象清空</li>
</ol>
<hr>
<h5 id="Hibernate-的-get-方法和-load-方法的区别"><a href="#Hibernate-的-get-方法和-load-方法的区别" class="headerlink" title="Hibernate 的 get() 方法和 load() 方法的区别"></a>Hibernate 的 get() 方法和 load() 方法的区别</h5><ol>
<li>执行 <code>get()</code> 方法，会立即加载对象（即立即查询）</li>
<li>执行 <code>load()</code> 方法，若不使用该对象，则不会立即执行查询，而是先返回一个代理对象（即延迟加载）</li>
<li>若数据表中没有对应的记录，Session 没关，<code>get()</code> 方法返回 Null，<code>load()</code> 方法抛出异常（需要使用对象时，不使用对象不抛异常）</li>
<li><code>load()</code> 方法可能会抛出懒加载异常（<code>LazyInitializationException</code>），在需要初始化代理对象之前已经关闭了 Session 对象时会出现这种情况</li>
</ol>
<hr>
<h5 id="Hibernate-的-update-方法"><a href="#Hibernate-的-update-方法" class="headerlink" title="Hibernate 的 update() 方法"></a>Hibernate 的 update() 方法</h5><ol>
<li>更新一个游离对象时需要显式调用 <code>update()</code> 方法（会将一个游离对象变为持久化对象），无论游离对象和数据表中是否一致都会发送 UPDATE 语句</li>
<li>在 <code>*.hbm.xml</code> 文件中 class 节点设置 <code>select-before-update</code> 属性为 true（通常不需要设置，除非有特殊的触发器）</li>
<li>若数据表中没有对应的记录，但也调用了 <code>update()</code> 方法，则会抛出异常</li>
</ol>
<hr>
<h5 id="Hibernate-的-saveOrUpdate-方法"><a href="#Hibernate-的-saveOrUpdate-方法" class="headerlink" title="Hibernate 的 saveOrUpdate() 方法"></a>Hibernate 的 saveOrUpdate() 方法</h5><ol>
<li>判定为临时对象的标准<ul>
<li>Java 对象的 OID 为 Null</li>
<li><code>*.hbm.xml</code> 文件中为 id 设置了 <code>unsaved-value</code> 属性，并且 Java 对象的 OID 取值和这个 <code>unsaved-value</code> 属性相匹配</li>
</ul>
</li>
</ol>
<hr>
<h5 id="Hibernate-的-delete-方法"><a href="#Hibernate-的-delete-方法" class="headerlink" title="Hibernate 的 delete() 方法"></a>Hibernate 的 delete() 方法</h5><ol>
<li>计划执行一条 DELETE 语句</li>
<li>将对象从 Session 缓存中删除，该对象进入删除状态</li>
<li><code>hibernate.cfg.xml</code> 文件中有一个 <code>hibernate.user_identifier_rollback</code> 属性，默认为 false，可以将其置为 true 从而使 <code>delete()</code> 方法在删除对象时将对象的 OID 置为 Null，使其变为临时对象</li>
</ol>
<hr>
<h5 id="Hibernate-的-evict-方法"><a href="#Hibernate-的-evict-方法" class="headerlink" title="Hibernate 的 evict() 方法"></a>Hibernate 的 evict() 方法</h5><ol>
<li>从 Session 缓存中将指定的持久化对象移除</li>
</ol>
<hr>
<h5 id="Hibernate-配置文件"><a href="#Hibernate-配置文件" class="headerlink" title="Hibernate 配置文件"></a>Hibernate 配置文件</h5><ol>
<li>每个 Hibernate 配置文件都对应一个 Configuration 对象</li>
<li>Hibernate 配置文件有两种选项<ul>
<li><code>hibernate.properties</code></li>
<li><code>hibernate.cfg.xml</code></li>
</ul>
</li>
</ol>
<hr>
<h5 id="JDBC-连接属性"><a href="#JDBC-连接属性" class="headerlink" title="JDBC 连接属性"></a>JDBC 连接属性</h5><ol>
<li>connection.url：数据库 URL</li>
<li>connection.name：数据库用户名</li>
<li>connection.password：数据库用户密码</li>
<li>connection.driver_class：数据库 JDBC 驱动</li>
<li>dialect：配置数据库的方言，根据底层的数据库不同产生不同的 SQL 语句，Hibernate 会针对数据库的特性在访问时进行优化</li>
</ol>
<hr>
<h5 id="C3P0-数据库连接池属性"><a href="#C3P0-数据库连接池属性" class="headerlink" title="C3P0 数据库连接池属性"></a>C3P0 数据库连接池属性</h5><ol>
<li>hibernate.c3p0.max_size：数据库连接池的最大连接数</li>
<li>hibernate.c3p0.min_size：数据库连接池的最小连接数</li>
<li>hibernate.c3p0.timeout：数据库连接池中连接对象在多长时间没有使用过后，就应该被销毁</li>
<li>hibernate.c3p0.max_statements：缓存 Statement 对象的数量</li>
<li>hibernate.c3p0.idle_text_period：表示连接池检测线程多长时间检测一次池内的所有连接对象是否超时，连接池本身不会把自己从连接池中移除，而是专门有一个线程按照一定的时间间隔来做这个事，这个线程通过比较连接对象最后一次使用时间和当前时间的时间差来和 timeout 做对比，进而决定是否销毁这个连接对象</li>
<li>hibernate.c3p0.acquire_increment：当数据库连接池中的连接耗尽时，同一时刻获取多少个数据库连接</li>
</ol>
<hr>
<h5 id="在-Hibernate-中使用-C3P0-数据源"><a href="#在-Hibernate-中使用-C3P0-数据源" class="headerlink" title="在 Hibernate 中使用 C3P0 数据源"></a>在 Hibernate 中使用 C3P0 数据源</h5><ol>
<li>导入 jar 包（位于 <code>hibernate\lib\optional\c3p0</code> 路径下）</li>
<li>加入配置</li>
</ol>
<hr>
<h5 id="hibernate-mapping"><a href="#hibernate-mapping" class="headerlink" title="hibernate-mapping"></a>hibernate-mapping</h5><ol>
<li>hibernate-mapping 是 Hibernate 映射文件的根元素，他有以下属性：<ul>
<li>schema：指定所映射的数据 schema 的名称，若指定该属性，则表明会自动添加该 schema 前缀</li>
<li>catalog：指定所映射的数据库的 catalog 名称</li>
<li>default-cascade（默认为 none）：设置 Hibernate 默认的级联风格，若配置 Java 属性，集合映射时没有指定 cascade 属性，则 Hibernate 将采用此处指定的级联风格</li>
<li>default-access（默认为 property）：指定 Hibernate 的默认的属性访问策略，默认值为 property，即使用 getter/setter 方法来访问属性；若指定 access，则 Hibernate 会忽略 getter/setter 方法，而通过反射访问成员变量</li>
<li>default-lazy（默认为 true）：设置 Hibernate 默认的延迟加载策略，该属性的默认值为 true，即启用延迟加载策略，若配置 Java 属性映射，集合映射时没有指定 lazy 属性，则 Hibernate 将采用此处指定的延迟加载策略</li>
<li>auto-import（默认为 true）：指定是否可以在查询语言中使用非全限定的类型（仅限于本映射文件中的类）</li>
<li>package（可选）：指定一个包前缀，如果在映射文档中没有指定一个限定的类名，则使用这个作为包名</li>
</ul>
</li>
</ol>
<hr>
<h5 id="class"><a href="#class" class="headerlink" title="class"></a>class</h5><ol>
<li>class 元素用于指定类和表的映射，他有以下属性：<ul>
<li>name：指定该持久化类映射的持久化类的类名</li>
<li>table：指定该持久化类映射的表名，Hibernate 默认以持久化类的类名作为表名</li>
<li>dynamic-insert：若设置为 true，则表示当保存一个对象时，会动态生成 INSERT 语句，INSERT 语句中仅包含所有取值不为 Null 的字段，默认为 false</li>
<li>dynamic-update：若设置为 true，则表示当更新一个对象时，会动态生成 UPDATE 语句，UPDATE 语句中仅包含所有取值需要更新的字段，默认为 false</li>
<li>select-before-update：设置 Hibernate 在更新某个持久化对象之前是否需要先执行一次查询，默认值为 false</li>
<li>batch-size：指定根据 OID 来抓取实例时每批抓取的实例数</li>
<li>lazy：指定是否使用延迟加载</li>
<li>mutable：若设置为 true，则表示所有的 &lt;property&gt; 元素的 update 属性为 false，表示整个实例都不能被更新，默认为 true</li>
<li>discriminator-value：指定区分不同子类的值，当使用 &lt;subclass&gt; 元素来定义持久化类的继承关系时需要使用该属性</li>
</ul>
</li>
</ol>
<hr>
<h5 id="映射对象标识符"><a href="#映射对象标识符" class="headerlink" title="映射对象标识符"></a>映射对象标识符</h5><ol>
<li>Hibernate 使用对象标识符（ OID ）来建立内存中的对象和数据表中记录的对应关系，对象的 OID 和数据表中的主键对应，Hibernate 通过标识符生成器来为主键赋值</li>
<li>Hibernate 推荐在数据表中使用代理主键（即不具备业务含义的字段），代理主键通常为整数类型，因为能节省空间</li>
<li>Hibernate 提供了标识符生成器接口：IdentifierGenerator，并提供了各种内置实现</li>
</ol>
<hr>
<h5 id="id"><a href="#id" class="headerlink" title="id"></a>id</h5><ol>
<li>设定持久化类的 OID 和表的主键映射，有以下属性：<ul>
<li>name：标识持久化类 OID 的属性名</li>
<li>column：设置标识属性所映射的数据表的列名（主键字段的名字）</li>
<li>unsaved-value：若设定了该属性，Hibernate 会通过比较持久化类的 OID 值和该属性值来区分当前持久化类对象是否为临时对象</li>
<li>type：指定 Hibernate 映射类型，Hibernate 映射类型是 Java 类型与 SQL 类型的桥梁，如果没有为某个属性显式设定映射类型，HIbernate 会运用反射机制先识别出持久化类的特定属性的 Java 类型，然后自动使用与之对应的默认的 Hibernate 映射类型</li>
<li>Java 的基本数据类型和包装类型对应相同的 Hibernate 映射类型，基本数据类型无法表达 Null，所以对于持久化类的 OID 推荐使用包装类型</li>
</ul>
</li>
</ol>
<hr>
<h5 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h5><ol>
<li>设定持久化类的标识符生成器，有一个属性：<ul>
<li>class：指定使用的标识符生成器全限定类名或其缩写名（一般为缩写名）</li>
</ul>
</li>
</ol>
<hr>
<h5 id="主键生成策略"><a href="#主键生成策略" class="headerlink" title="主键生成策略"></a>主键生成策略</h5><ol>
<li><p>increment</p>
<ul>
<li>increment 生成器由 Hibernate 以递增的方式为代理主键赋值</li>
<li>Hibernate 会先读取数据表中主键的最大值，然后在接下来向表中插入新纪录的时候，就在读取到的这个最大值的基础上递增，增量为 1</li>
<li>适用范围<ul>
<li>由于 increment 生成标识符机制不依赖于底层数据库系统，因此他适用于所有的数据库系统</li>
<li>适用于只有单个 Hibernate 应用进程访问同一个数据库的场合，在集群环境下不推荐使用他（在多线程环境下可能会出现脏数据）</li>
<li>OID 必须为 long、int 或者 short 类型，如果把 OID 定义为 byte 类型，在运行时会抛出异常</li>
</ul>
</li>
</ul>
</li>
<li><p>identity</p>
<ul>
<li>identity 标识符生成器由底层数据库来负责生成标识符，他要求底层数据库把主键定义为自动增长字段类型</li>
<li>适用范围<ul>
<li>由于 identity 生成标识符的机制依赖于底层数据库系统，因此，要求底层数据库系统必须支持自动增长字段类型，支持自动增长字段类型的数据库包括：DB2、MySQL、MSSQL Server、Sybase 等</li>
<li>OID 必须为 long、int 或者 short 类型，如果把 OID 定义为 byte 类型，在运行时会抛出异常</li>
</ul>
</li>
</ul>
</li>
<li><p>sequence</p>
<ul>
<li><p>sequence 标识符生成器利用底层数据库提供的序列来生成标识符</p>
</li>
<li><p>要在 &lt;generator&gt; 标签中注明使用的序列是谁</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;sequence&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定的序列名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;sequence&quot;</span>&gt;</span>test_seq<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Hibernate 在持久化一个对象时，先从底层数据库中获得一个唯一的标识号，再把他作为主键值</p>
</li>
<li><p>适用范围</p>
<ul>
<li>由于 sequence 生成标识符的机制依赖于底层数据库系统的序列，因此，要求底层数据库必须支持序列，支持序列的数据库包括：DB2、Oracle 等</li>
<li>OID 必须为 long、int 或者 short 类型，如果把 OID 定义为 byte 类型，在运行时会抛出异常</li>
</ul>
</li>
</ul>
</li>
<li><p>hilo</p>
<ul>
<li><p>hilo 标识符生成器是由 Hibernate 按照一种 high/low 算法来生成标识符，他从数据库的特定表的字段中获取 high 的值</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;hilo&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;table&quot;</span>&gt;</span>HI_TABLE<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;column&quot;</span>&gt;</span>NEXT_VALUE<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;max_lo&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Hibernate 在持久化一个对象时，由 HIbernate 负责生成主键值，hilo 标识符生成器在生成标识符时，需要读取并修改 HI_TABLE 表中的 NEXT_VALUE 值</p>
</li>
<li><p>适用范围</p>
<ul>
<li>由于 hilo 生成标识符机制不依赖于底层数据库系统，因此他适合于所有的数据库系统</li>
<li>OID 必须为 long、int 或者 short 类型，如果把 OID 定义为 byte 类型，在运行时会抛出异常</li>
</ul>
</li>
</ul>
</li>
<li><p>native</p>
<ul>
<li>native 标识符生成器依据底层数据库对自动生成标识符的支持能力，来选择使用 identity、sequence 或者 hilo 标识符生成器</li>
<li>适用范围<ul>
<li>由于 native 能根据底层数据库系统的类型，自动选择合适的标识符生成器，因此很适合于跨数据库平台开发</li>
<li>OID 必须为 long、int 或者 short 类型，如果把 OID 定义为 byte 类型，在运行时会抛出异常</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h5 id="property"><a href="#property" class="headerlink" title="property"></a>property</h5><ol>
<li><p>property 元素用于指定类的属性和表的字段映射，他有以下属性：</p>
<ul>
<li><p>name：指定该持久化类的属性的名字</p>
</li>
<li><p>column：指定与类的属性映射的表的字段名，如果没有设置该属性，Hibernate 则会直接使用类的属性名作为字段名</p>
</li>
<li><p>type：指定 Hibernate 映射类型，Hibernate 映射类型是 Java 类型与 SQL 类型的桥梁，如果没有为某个属性显式设定映射类型，Hibernate 会运用反射机制先识别出持久化类的特定属性的 Java 类型，然后自动使用与之对应的默认的 Hibernate 映射类型</p>
</li>
<li><p>not-null：若该属性值为 true，则表明不允许为 Null，默认为 false</p>
</li>
<li><p>access：指定 Hibernate 默认的属性访问策略，默认值为 property，即使用 getter/setter 方法来访问属性，若指定为 field，则 Hibernate 会忽略 getter/setter 方法，而通过反射机制来访问成员变量</p>
</li>
<li><p>unique：设置是否为该属性所映射的数据列添加 unique 约束</p>
</li>
<li><p>update：设置该列值是否可以被修改，默认为 true</p>
</li>
<li><p>index：指定一个字符串的索引名称，当系统需要 Hibernate 自动建表时，用于为该属性所映射的数据列创建索引，从而加快该数据列的查询</p>
</li>
<li><p>length：指定该属性所映射数据列的字段的长度</p>
</li>
<li><p>scale：指定该属性所映射数据列的小数位数，对 double、float、decimal 等类型的数据列有效</p>
</li>
<li><p>formula：设置一个 SQL 表达式，Hibernate 将根据他来计算出派生属性的值</p>
<ul>
<li><p>派生属性：并不是持久化类的的所有属性都直接和表的字段匹配，持久化类的有些属性的值必须在运行时通过计算才能得出来，这类属性称为派生属性</p>
</li>
<li><p>formula = “( SQL 表达式)” 的英文括号不能少</p>
</li>
<li><p>如果需要在 formula 属性中使用参数，就直接使用 WHERE cur.id = id 形式，其中 id 就是参数，和当前持久化对象的 id 属性对应的列的 id 值将作为参数传入</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 字段名为 test, 表名为 News, test 字段由 title 字段和 author 字段拼接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span> <span class="attr">formula</span>=<span class="string">&quot;(SELECT concat(title, &#x27;: &#x27; author) FROM News news WHERE news.id = id)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h5 id="Java-时间和日期类型的-Hibernate-映射"><a href="#Java-时间和日期类型的-Hibernate-映射" class="headerlink" title="Java 时间和日期类型的 Hibernate 映射"></a>Java 时间和日期类型的 Hibernate 映射</h5><ol>
<li>持久化类中将成员变量类型设置为 java.util.Date 类型</li>
<li><code>*.hbm.xml</code> 文件中在 property 中设置 type 为 Hibernate 映射类型即可</li>
</ol>
<table>
<thead>
<tr>
<th>Hibernate 映射类型</th>
<th>Java 类型</th>
<th>标准 SQL 类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>date</td>
<td>java.util.Date/java.sql.Date</td>
<td>DATE</td>
<td>yyyy-MM-dd</td>
</tr>
<tr>
<td>time</td>
<td>java.util.Date/java.sql.Time</td>
<td>TIME</td>
<td>hh:mm:ss</td>
</tr>
<tr>
<td>timestamp</td>
<td>java.util.Date/java.sql.Timestamp</td>
<td>TIMESTAMP</td>
<td>yyyymmddhhmmss</td>
</tr>
<tr>
<td>calendar</td>
<td>java.util.Calendar</td>
<td>TIMESTAMP</td>
<td>yyyymmddhhmmss</td>
</tr>
<tr>
<td>calendar_date</td>
<td>java.util.Calendar</td>
<td>DATE</td>
<td>yyyy-MM-dd</td>
</tr>
</tbody></table>
<hr>
<h5 id="Java-大对象类型的-Hibernate-映射"><a href="#Java-大对象类型的-Hibernate-映射" class="headerlink" title="Java 大对象类型的 Hibernate 映射"></a>Java 大对象类型的 Hibernate 映射</h5><ol>
<li><p>长字符串可直接使用 java.lang.String 类型表示</p>
</li>
<li><p>字节数组 byte[] 可用于存放图片或文件的二进制数据</p>
</li>
<li><p>JDBC API 中还提供了 java.sql.Clob 和 java.sql.Blob 类型，他们分别表示标准 SQL 中的 CLOB 和 BLOB 类型</p>
</li>
<li><p>MySQL 不支持标准 SQL 的 CLOB 类型，在 MySQL 中，用 TEXT、MEDIUMTEXT 和 LONGTEXT 类型来表示长度超过 255 的长文本数据</p>
</li>
<li><p>在持久化类中，二进制大对象可以声明为 byte[] 类型数组或者 java.sql.Blob 类型，字符串可以声明为 java.lang.String 或者 java.sql.Clob 类型</p>
</li>
<li><p>如果想精确映射 SQL 类型，可以在 &lt;column&gt; 标签中使用 sql-type 属性，sql-type 属性的取值为当前数据库所支持的 SQL 类型</p>
</li>
<li><p>保存一个二进制大对象需要一个 InputStream 来读取图片或文件</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;图片/文件路径&quot;</span>);</span><br><span class="line">Blob image = Hibernate.getLobCreator(session).createBlob(inputStream, inputStream.available());</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h5 id="映射组成关系"><a href="#映射组成关系" class="headerlink" title="映射组成关系"></a>映射组成关系</h5><ol>
<li><p>Hibernate 把持久化类的属性分为两种</p>
<ul>
<li>value type（值类型）：没有 OID，不能被单独持久化，生命周期依赖于所属的持久化类的对象的生命周期</li>
<li>entity type（实体类型）：有 OID，可以被单独持久化，有独立的生命周期</li>
</ul>
</li>
<li><p>Hibernate 使用 &lt;component&gt; 元素来映射组成关系</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 以 Worker 和 Pay 为例， 工人有工资，工资为工人的一部分 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在这里表示 Pay 是 Worker 类的一个组成部分 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在 Hibernate 中称为组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">name</span>=<span class="string">&quot;pay&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Pay&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- parent 元素指定组件属性所属的整体类 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用 parent 元素的前提是在 Pay 中有一个属性为 Worker 的引用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span> <span class="attr">name</span>=<span class="string">&quot;Worker&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;payId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;pay_id&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;payName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;pay_name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h5 id="四个地方会出现懒加载"><a href="#四个地方会出现懒加载" class="headerlink" title="四个地方会出现懒加载"></a>四个地方会出现懒加载</h5><ol>
<li>Session.load() 方法<ul>
<li>如果在 Session 关闭之后再查询此对象会出现懒加载异常，可以在 Session 关闭之前初始化一下查询出来的代理对象：<code>Hibernate.initialize(object);</code> 来解决这个问题</li>
</ul>
</li>
<li>one-to-one 关联关系</li>
<li>many-to-one 关联关系<ul>
<li>n 对 1 时无论哪一端都是默认懒加载的查询，如果不需要懒加载，则要修改映射文件</li>
</ul>
</li>
<li>one-to-many 关联关系</li>
</ol>
<hr>
<h5 id="单向-n-对-1-关联关系"><a href="#单向-n-对-1-关联关系" class="headerlink" title="单向 n 对 1 关联关系"></a>单向 n 对 1 关联关系</h5><ol>
<li><p>使用 many-to-one 来映射多对一的关联关系，以添加外键的形式来描述多对一的关系</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- n 端映射文件中需要加入 1 端的配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">&quot;customer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Customer&quot;</span> <span class="attr">column</span>=<span class="string">&quot;customer_id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">many-to-one</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>name：n 端关联 1 端的属性的名字</li>
<li>class：1 端的属性对应的类名</li>
<li>column：1 端在 n 端的外键的名字</li>
</ul>
</li>
</ol>
<hr>
<h5 id="双向-n-对-1-关联关系"><a href="#双向-n-对-1-关联关系" class="headerlink" title="双向 n 对 1 关联关系"></a>双向 n 对 1 关联关系</h5><ol>
<li><p>在单向 n 对 1 的基础上在 1 端的类中加上 n 端的集合作为一个属性</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以 Customer 和 Order 为例</span></span><br><span class="line"><span class="comment">// Customer 为 1 端类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Order 为 n 端类</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 1 端的映射文件中加入上面那个集合的映射</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- name 为集合名, table 为 n 端的表名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">table</span>=<span class="string">&quot;Orders&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- key 为 外键 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">&quot;customer_id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 映射类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">&quot;Order&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>&lt;set&gt; 元素的 inverse 属性</p>
<ul>
<li>在 Hibernate 中通过 inverse 属性来决定由双向关联的哪一端来维护表和表之间的关系，<code>inverse = false</code> 的为主动方，<code>inverse = true</code> 的为被动方，由主动方负责维护关联关系</li>
<li>在没有设置 inverse 属性的情况下（即默认情况），两边都维护关联关系</li>
<li>在 1 对 n 关系中，将 n 方设为主动方有助于改善性能</li>
</ul>
</li>
<li><p>&lt;set&gt; 元素的 cascade 属性</p>
<ul>
<li><p>在对象-关系映射文件中，用于映射持久化类之间关联关系的元素，&lt;set&gt; 、&lt;many-to-one&gt; 、&lt;one-to-one&gt; 等标签都有一个 cascade 属性，他用于指定如何操纵与当前对象关联的其他对象</p>
<table>
<thead>
<tr>
<th>cascade 属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>当 Session 操纵当前对象时，忽略其他关联的对象（cascade 属性默认值）</td>
</tr>
<tr>
<td>save-update</td>
<td>当通过 Session 的 save() 、update() 、saveOrUpdate() 等方法来保存或更新对象时，级联保存所有关联的新建的临时对象，并且级联更新所有的游离对象</td>
</tr>
<tr>
<td>persist</td>
<td>当通过 Session 的 persist() 方法来保存当前对象时，会级联保存所有关联的新建的临时对象</td>
</tr>
<tr>
<td>delete</td>
<td>当通过 Session 的 delete() 方法删除当前对象时，会级联删除所有关联的对象</td>
</tr>
<tr>
<td>lock</td>
<td>当通过 Session 的 lock() 方法把当前游离对象添加到 Session 缓存中时，会把所有关联的游离对象也添加到 Session 缓存中</td>
</tr>
<tr>
<td>replicate</td>
<td>当通过 Session 的 replicate() 方法复制当前对象时，会级联复制所有关联的对象</td>
</tr>
<tr>
<td>evict</td>
<td>当通过 Session 的 evict() 方法从 Session 缓存中清除当前对象时，会级联清除所有关联的对象</td>
</tr>
<tr>
<td>refresh</td>
<td>当通过 Session 的 refresh() 方法刷新当前对象时，会级联刷新所有关联的对象，所谓刷新是指读取数据库中相应数据，然后根据数据库中的最新数据去同步更新 Session 缓存中的相应对象</td>
</tr>
<tr>
<td>all</td>
<td>包含 save-update、persist、merge、delete、lock、replicate、evict、refresh 等行为</td>
</tr>
<tr>
<td>delete-orphan</td>
<td>删除所有和当前对象解除关联关系的对象</td>
</tr>
<tr>
<td>merge</td>
<td>当通过 Session 的 merge() 方法来保存当前对象时，会级联融合所有关联的游离对象</td>
</tr>
<tr>
<td>all-delete-orphan</td>
<td>包含 all 和 delete-orphan 的行为</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>&lt;set&gt; 元素的 order-by 属性</p>
<ul>
<li><p>&lt;set&gt; 元素有一个 order-by 属性，如果设置了该属性，当 Hibernate 通过 SELECT 语句到数据库中检索集合对象时，利用 order-by 子句进行排序</p>
</li>
<li><p>order-by 属性还可以加入 SQL 函数</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- order-by 中放入的是列名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">inverse</span>=<span class="string">&quot;true&quot;</span> <span class="attr">cascade</span>=<span class="string">&quot;save-update&quot;</span> <span class="attr">order-by</span>=<span class="string">&quot;ORDER_DATE DESC&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">&quot;customer_id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">&quot;Order&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">one-to-many</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<hr>
<h5 id="双向-1-对-1-关联关系"><a href="#双向-1-对-1-关联关系" class="headerlink" title="双向 1 对 1 关联关系"></a>双向 1 对 1 关联关系</h5><ol>
<li><p>按照外键映射（需要使用 unique 约束标记外键）</p>
<ul>
<li><p>对于基于外键映射的 1 对 1 关联，其外键可以存放至任意一边，在需要存放外键的一端，增加 &lt;many-to-one&gt; 元素，为 &lt;many-to-one&gt; 元素增加 <code>unique = “true”</code> 属性来表示为 1 对 1 关联</p>
</li>
<li><p>另一端需要使用 &lt;one-to-one&gt; 元素，该元素使用 <code>property-ref</code> 属性指定使用被关联实体主键以外的字段作为关联字段（即指定引用的外键），如果不使用这个属性指定，则会默认使用该表的主键来作为外键进行查询</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Department&quot;</span> <span class="attr">property-ref</span>=<span class="string">&quot;manager&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">one-to-one</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>按照主键映射</p>
<ul>
<li><p>一端的主键生成器使用 foreign 策略，表明根据 “对方” 的主键来生成自己的主键，自己并不能独立生成主键，&lt;param&gt; 子元素表示指定使用当前持久化类的哪个属性作为 “对方”</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;ID&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用外键方式生成当前表的主键 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;foreign&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- property 属性指定使用当前持久化类的哪一个属性的主键来作为外键 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;property&quot;</span>&gt;</span>manager<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>采用 foreign 主键生成器策略的一端增加 &lt;one-to-one&gt; 元素映射关联属性，其 &lt;one-to-one&gt; 属性还应增加 <code>constrained = “true”</code> 属性，另一端增加 &lt;one-to-one&gt; 元素映射关联属性</p>
</li>
<li><p>constrained（约束）：指定为当前持久化类对应的数据库表的主键添加一个外键约束，引用被关联的对象（ “对方” ）所对应的数据库表主键</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">&quot;manager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Manager&quot;</span> <span class="attr">constrained</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">one-to-one</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<hr>
<h5 id="单向-n-对-n-关联关系"><a href="#单向-n-对-n-关联关系" class="headerlink" title="单向 n 对 n 关联关系"></a>单向 n 对 n 关联关系</h5><ol>
<li><p>（n 对 n 关联必须使用连接表）需要一张存放有两个或多个持久化类主键的索引表</p>
</li>
<li><p>与 1 对 n 映射类似，必须为 &lt;set&gt; 集合元素添加 &lt;key&gt; 子元素，指定 categories_items 表中参照 categories 表的外键为 category_id；与 1 对 n 关联映射不同的是，建立 n 对 n 关联时，集合中的元素使用 &lt;many-to-many&gt; ，&lt;many-to-many&gt; 子元素的 class 属性指定 items 集合中存放的是 Item 对象，column 属性指定 categories_items 表中参照 items 表的外键为 item_id</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- table 属性用来指定中间表 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">&quot;items&quot;</span> <span class="attr">table</span>=<span class="string">&quot;categories_items&quot;</span> <span class="attr">cascade</span>=<span class="string">&quot;save-update&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">&quot;category_id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定 n 对 n 的关联关系 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- column 属性用来指定 Set 集合中的持久化类在中间表的外键列名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">many-to-many</span> <span class="attr">class</span>=<span class="string">&quot;Item&quot;</span> <span class="attr">column</span>=<span class="string">&quot;item_id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">many-to-many</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 注：categories 表和 items 表分别表示商品的分类和商品两个实体</p>
</li>
</ol>
<hr>
<h5 id="双向-n-对-n-关联关系"><a href="#双向-n-对-n-关联关系" class="headerlink" title="双向 n 对 n 关联关系"></a>双向 n 对 n 关联关系</h5><ol>
<li>双向 n 对 n 关联需要两端都使用集合属性</li>
<li>双向 n 对 n 关联必须使用连接表</li>
<li>集合属性应增加 key 子元素用以映射外键列，集合元素里还应增加 &lt;many-to-many&gt; 子元素关联实体类</li>
<li>在双向 n 对 n 关联的两边都需要指定连接表的表名以及外键列的列名，两个集合元素 &lt;set&gt; 的 table 元素的值必须指定，而且必须相同。&lt;set&gt; 元素的两个子元素：&lt;key&gt; 和 &lt;many-to-many&gt; 都必须指定 column 属性，其中，&lt;key&gt; 和 &lt;many-to-many&gt; 分别指定本持久化类和关联类在连接表中的外键列名，因此两边的 &lt;key&gt; 与 &lt;many-to-many&gt; 的 column 属性交叉相同，也就是说，一边的 &lt;set&gt; 元素的 &lt;key&gt; 的 column 值为 a，&lt;many-to-many&gt; 的 column 为 b；则另一边的 &lt;set&gt; 元素的 &lt;key&gt; 的 column 值为 b，&lt;many-to-many&gt; 的 column 值为 a</li>
<li>对于双向 n 对 n 关联，必须把其中一端的 inverse 设置为 true，否则两端都维护关联关系可能会造成主键冲突 </li>
</ol>
<hr>
<h5 id="映射继承关系"><a href="#映射继承关系" class="headerlink" title="映射继承关系"></a>映射继承关系</h5><ol>
<li>Hibernate 支持三种继承映射策略<ul>
<li>使用 subclass 进行映射<ul>
<li>将域模型中的每一个实体对象映射到一个独立的表中，也就是说不用在关系数据模型中考虑域模型中的继承关系和多态</li>
</ul>
</li>
<li>使用 joined-subclass 进行映射<ul>
<li>对于继承关系中的子类使用同一张表，这就需要在数据库中增加额外的区分子类类型的字段</li>
</ul>
</li>
<li>使用 union-subclass 进行映射<ul>
<li>域模型中的每个类映射到一张表，通过关系数据模型中的外键来描述表之间的继承关系。相当于按照域模型的结构来建立数据库中的表，并通过外键来建立表之间的继承关系</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h5 id="使用-subclass-元素的继承映射"><a href="#使用-subclass-元素的继承映射" class="headerlink" title="使用 subclass 元素的继承映射"></a>使用 subclass 元素的继承映射</h5><ol>
<li><p>采用 subclass 的继承映射可以实现对于继承关系中父类和子类使用同一张表</p>
</li>
<li><p>因为父类和子类的实例全部保存在同一张表中，因此需要在该表增加一列，使用该列来区分每行记录到底是哪个类的实例，这一列被称为辨别者列（ discriminator ）</p>
</li>
<li><p>在这种映射策略下，使用 subclass 来映射子类，使用 class 或 subclass 的 <code>discriminator-value</code> 属性来指定辨别者列的值</p>
</li>
<li><p>所有子类定义的字段都不能有非空约束。如果为那些字段添加非空约束，那么父类的实例在那些列其实并没有值，这将引起数据库完整性冲突，导致父类的实例无法保存到数据库中</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父类的配置文件 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 鉴别者列 column为该列列名 type为该列的数据类型 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">column</span>=<span class="string">&quot;TYPE&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>由于父类与子类都使用同一张表，所以无论查询父类记录还是查询子类记录，都只需要查询一张表即可</p>
</li>
<li><p>缺点：</p>
<ul>
<li>多出一列鉴别者列</li>
<li>子类独有的字段无法添加非空约束</li>
<li>数据表的字段会随着继承的层次加深而增多</li>
</ul>
</li>
</ol>
<hr>
<h5 id="使用-joined-subclass-元素的继承映射"><a href="#使用-joined-subclass-元素的继承映射" class="headerlink" title="使用 joined-subclass 元素的继承映射"></a>使用 joined-subclass 元素的继承映射</h5><ol>
<li>使用 joined-subclass 元素的继承映射可以实现每个子类一张表</li>
<li>使用这种映射策略时，父类实例保存在父类表中，子类实例由父类表和子类表共同存储。因为子类实例也是一个特殊的父类实例，因此也必然包含了父类实例的属性，于是将子类和父类共有的属性保存在父类表中，子类中增加的属性，保存在子类表中</li>
<li>在这种映射策略下，无须使用鉴别者列，但需要为每个子类使用 key 元素映射共有主键</li>
<li>子类增加的属性可以添加非空约束（因为父类和子类并不在同一张表中）</li>
<li>由于是每个子类一张表，所以在插入数据时会插入多张表，性能会降低</li>
<li>查询父类记录，使用一个左外连接；查询子类记录，使用一个内连接</li>
<li>优点：<ul>
<li>不需要使用鉴别者列</li>
<li>子类独有的字段可以添加非空约束</li>
<li>没有冗余的字段</li>
</ul>
</li>
</ol>
<hr>
<h5 id="使用-union-subclass-元素的继承映射"><a href="#使用-union-subclass-元素的继承映射" class="headerlink" title="使用 union-subclass 元素的继承映射"></a>使用 union-subclass 元素的继承映射</h5><ol>
<li>使用 union-subclass 元素可以实现将每一个实体对象映射到一个独立的表中</li>
<li>子类增加的属性可以有非空约束，即父类实例的数据保存在父类数据表中，而子类实例的数据保存在子类数据表中</li>
<li>子类实例的数据仅保存在子类表中，而在父类表中没有任何记录</li>
<li>在这种映射策略下，子类表的字段会比父类表的映射字段要多，因为字段表的字段等于父类表的字段与子类增加属性的综合</li>
<li>在这种映射策略下，既不需要使用鉴别者列也不需要使用 key 元素来映射共有主键</li>
<li>使用 union-subclass 映射策略是不可以使用 identity 的主键生成策略的，因为同一类继承层次中所有实体类都需要使用同一个主键种子，即多个持久化实体对应的记录的主键应该是连续的，受此影响，也不该使用 native 生成策略，因为 native 策略会根据数据库来选择使用 identity 或者 sequence 来生成主键</li>
</ol>
<hr>
<h5 id="Hibernate-的检索策略"><a href="#Hibernate-的检索策略" class="headerlink" title="Hibernate 的检索策略"></a>Hibernate 的检索策略</h5><ol>
<li><p>原则</p>
<ul>
<li>不浪费内存（懒加载）</li>
<li>更高的查询效率（发送尽可能少的 SQL 语句）</li>
</ul>
</li>
<li><p>类级别的检索策略</p>
<ul>
<li>类级别可选的检索策略包括<strong>立即检索</strong>和<strong>延迟检索</strong>，默认为延迟检索<ul>
<li>立即检索：立即加载检索方法指定的对象</li>
<li>延迟检索：延迟加载检索方法指定的对象</li>
</ul>
</li>
<li>类级别的检索策略可通过 &lt;class&gt; 元素的 lazy 属性进行设置</li>
<li>如果程序加载一个对象的目的是为了访问他的属性，可以采取立即检索；如果程序加载一个持久化对象仅仅是为了获取他的引用，那么可以采用延迟检索</li>
<li>无论 &lt;class&gt; 元素的 lazy 属性是 true 还是 false，Session 的 <code>get()</code> 方法及 Query 的 <code>list()</code> 方法在类级别总是使用立即检索策略</li>
<li>若 &lt;class&gt; 元素的 lazy 属性为 true 或取默认值，Session 的 <code>load()</code> 方法不会执行查询数据表的 SELECT 语句，仅返回代理类对象的实例，该代理类实例有如下特征：<ul>
<li>由 Hibernate 在运行时采用 CGLIB 工具动态生成</li>
<li>Hibernate 创建代理类实例时，仅初始化其 OID 属性</li>
<li>在应用程序第一次访问代理类实例的非 OID 属性时，Hibernate 会初始化代理类实例</li>
</ul>
</li>
</ul>
</li>
<li><p>1 对 1 和 n 对 n 的检索策略</p>
<ul>
<li>在映射文件中，用 &lt;set&gt; 元素来配置 1 对 n 关联及 n 对 n 关联关系，&lt;set&gt; 元素有 lazy 和 fetch 属性<ul>
<li>lazy：主要决定 orders 集合被初始化的时机，即到底是在加载 Customer 对象时就被初始化还是在程序访问 orders 集合时被初始化</li>
<li>fetch：取值为 select 或 subselect 时，决定初始化 orders 集合的查询语句的形式；若取值为 join，则决定 orders 集合被初始化的时机，默认值为 select</li>
<li>当 fetch 属性为 subselect 时：<ul>
<li>假定 Session 缓存中有 n 个 orders 集合代理类实例没有被初始化，Hibernate 能够通过带子查询的 SELECT 语句，来批量初始化 n 个 orders 集合代理类实例</li>
<li>batch-size 属性将被忽略</li>
<li>子查询中的 SELECT 语句为最初查询 Customers 表的 OID 的 SELECT 语句</li>
</ul>
</li>
<li>当 fetch 属性为 join 时：<ul>
<li>检索 Customer 对象时，会采用迫切左外连接（通过左外连接加载与检索指定的对象关联的对象，也就是说使用左外连接进行查询并且把集合进行初始化）策略来检索所有关联的 Order 对象</li>
<li>lazy 属性会被忽略</li>
<li>Query 的 <code>list()</code> 方法会忽略映射文件中配置的迫切左外连接检索策略，而依旧采用延迟加载策略</li>
</ul>
</li>
<li>&lt;set&gt; 元素的 batch-size 属性：用来为延迟检索策略或立即检索策略设定批量检索的数量，批量检索能减少 SELECT 语句的数目，提高延迟检索或立即检索的运行性能（代表一次可以初始化多少个集合）</li>
</ul>
</li>
</ul>
</li>
<li><p>延迟检索和增强延迟检索</p>
<ul>
<li>在延迟检索（lazy 属性设为 true 时）集合属性时，Hibernate 在以下情况下初始化集合代理类实例：<ul>
<li>应用程序第一次访问集合属性：<code>iterator()</code> 、<code>size()</code> 、<code>contains()</code> 等方法</li>
<li>通过 <code>Hibernate.initialize()</code> 静态方法显式初始化</li>
</ul>
</li>
<li>增强延迟检索（lazy 属性为 extra）：与 <code>lazy = &quot;true&quot;</code> 类似，主要区别是增强延迟检索策略能进一步延迟 Customer 对象的 orders 集合代理实例的初始化时机<ul>
<li>当程序第一次访问 orders 属性的 <code>iterator()</code> 方法时，会导致 orders 集合代理类实例的初始化</li>
<li>当程序第一次访问 orders 属性的 <code>size()</code> 、<code>contains()</code> 和 <code>isEmpty()</code> 方法时，Hibernate 不会初始化 orders 集合类的实例，仅通过特定的 SELECT 语句查询必要的信息，不会检索所有的 Order 对象</li>
</ul>
</li>
</ul>
</li>
<li><p>n 对 1 和 1 对 1 关联的检索策略</p>
<ul>
<li><p>和 &lt;set&gt; 一样，&lt;many-to-one&gt; 元素也有一个 lazy 属性和 fetch 属性</p>
<table>
<thead>
<tr>
<th>lazy 属性（默认为 proxy）</th>
<th>fetch 属性（默认为 select）</th>
<th>检索 Order 对象时对关联的 Customer 对象使用的检索策略</th>
</tr>
</thead>
<tbody><tr>
<td>proxy</td>
<td>未显式设置（取默认值）</td>
<td>延迟检索</td>
</tr>
<tr>
<td>no-proxy</td>
<td>未显式设置（取默认值）</td>
<td>无代理延迟检索</td>
</tr>
<tr>
<td>FALSE</td>
<td>未显式设置（取默认值）</td>
<td>立即检索</td>
</tr>
<tr>
<td>未显式设置（取默认值）</td>
<td>join</td>
<td>迫切左外连接策略</td>
</tr>
</tbody></table>
</li>
<li><p>若 fetch 属性设为 join，那么 lazy 属性会被忽略</p>
</li>
<li><p>迫切左外连接检索策略的优点在于比立即检索策略使用的 SELECT 语句更少</p>
</li>
<li><p>无代理延迟检索需要增加持久化类的字节码才能实现</p>
</li>
<li><p>Query 的 <code>list()</code> 方法会忽略映射文件配置的迫切左外连接检索策略，而采用延迟检索策略</p>
</li>
<li><p>如果在关联级别使用了延迟加载或立即加载检索策略，可以设定批量检索大小，以帮助提高延迟检索或立即检索的运行性能</p>
</li>
<li><p>Hibernate 允许在应用程序中覆盖映射文件中设定的检索策略</p>
</li>
<li><p>1 端 &lt;class&gt; 元素可以通过设置 batch-size 属性值来设定一次初始化 1 端代理对象的个数</p>
</li>
</ul>
</li>
</ol>
<hr>
<h5 id="Hibernate-检索方式"><a href="#Hibernate-检索方式" class="headerlink" title="Hibernate 检索方式"></a>Hibernate 检索方式</h5><ol>
<li>Hibernate 提供了以下几种检索对象的方式<ul>
<li>导航对象图检索方式：根据已经加载的对象导航到其他对象</li>
<li>OID 检索方式：按照对象的 OID 来检索对象（主要指 Session 的 <code>get()</code> 方法和 <code>load()</code> 方法）</li>
<li>HQL 检索方式：使用面向对象的 HQL 查询语言（ HQL：Hibernate Query Language）</li>
<li>QBC 检索方式：使用 QBC（ Query By Criteria ）API 来检索对象，这种 API 封装了基于字符串形式的查询语句，提供了更加面向对象的查询接口</li>
<li>本地 SQL 检索方式：使用本地数据库的 SQL 查询语句</li>
</ul>
</li>
</ol>
<hr>
<h5 id="HQL-检索方式"><a href="#HQL-检索方式" class="headerlink" title="HQL 检索方式"></a>HQL 检索方式</h5><ol>
<li><p>HQL 是面向对象的查询语言，与 SQL 语言类似，在 Hibernate 提供的各种检索方式中，HQL 是使用最广的一种检索方式，有如下功能：</p>
<ul>
<li>在查询语句中设定各种查询条件</li>
<li>支持投影查询，即仅检索出对象的部分属性</li>
<li>支持分页查询</li>
<li>支持连接查询</li>
<li>支持分组查询，允许使用 HAVING 和 GROUP BY 关键字</li>
<li>提供内置聚集函数，如 <code>sum()</code> 、<code>min()</code>、<code>max()</code> </li>
<li>支持子查询</li>
<li>支持动态绑定参数</li>
<li>能够调用用户定义的 SQL 函数或标准的 SQL 函数</li>
</ul>
</li>
<li><p>HQL 检索方式包括以下步骤：</p>
<ul>
<li>通过 Session 的 <code>createQuery()</code> 方法创建一个 Query 对象，他包括一个 HQL 查询语句，HQL 查询语句中可以包含命名参数</li>
<li>动态绑定参数</li>
<li>调用 Query 相关方法执行查询语句</li>
</ul>
</li>
<li><p>Query 接口支持<strong>方法链编程风格</strong>，他的 <code>setXxx()</code> 方法返回自身实例而不是 void 类型</p>
</li>
<li><p>HQL 与 SQL 对比：</p>
<ul>
<li>HQL 是面向对象的，Hibernate 负责解析 HQL 查询语句，然后根据 ORM 映射文件中的映射信息将 HQL 查询语句翻译成相应的 SQL 语句，HQL 查询语句中的主体是域模型中的类及类的属性</li>
<li>SQL 查询语句是与关系数据库绑定在一起的，SQL 查询语句中的主体是数据库表及表的字段</li>
</ul>
</li>
<li><p>绑定参数：</p>
<ul>
<li>Hibernate 的参数绑定机制依赖于 JDBC API 中的 PreparedStatement 的预定义 SQL 语句功能</li>
<li>HQL 的参数绑定有两种形式：<ul>
<li>按参数名字绑定：在 HQL 查询语句中定义命名参数，命名参数以 “:” 开头</li>
<li>按参数位置绑定：在 HQL 查询语句中使用 “?” 来定义参数位置</li>
</ul>
</li>
<li>相关方法：<ul>
<li><code>setEntity()</code> ：把参数与一个持久化类绑定</li>
<li><code>setParameter()</code> ：绑定任意类型的参数，该方法的第三个参数显式指定 Hibernate 映射类型</li>
</ul>
</li>
</ul>
</li>
<li><p>HQL 采用 ORDER BY 关键字对查询结果进行排序</p>
</li>
<li><p>分页查询</p>
<ul>
<li><code>setFirstResult(int firstResult)</code> ：设定从哪一个对象开始检索，参数 firstResult 表示这个对象在查询结果中的索引位置，索引位置的起始值为 0，默认情况下，Query 从查询结果中的第一个对象开始检索</li>
<li><code>setMaxResult(int maxResult)</code> ：设定一次最多检索出的对象的数目，在默认情况下，Query 和 Criteria 接口检索出查询结果中所有的对象</li>
</ul>
</li>
<li><p>在映射文件中定义命名查询语句</p>
<ul>
<li><p>Hibernate 允许在映射文件中定义字符串形式的查询语句</p>
</li>
<li><p>&lt;query&gt; 元素用于定义一个 HQL 查询语句，他和 &lt;class&gt; 元素并列</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">query</span> <span class="attr">name</span>=<span class="string">&quot;findNewsByTitle&quot;</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[</span><br><span class="line">    	FROM News n WHERE n.title LIKE :title</span><br><span class="line">    ]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">query</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在程序中通过 Session 的 <code>getNameQuery()</code> 方法获取查询语句对应的 Query 对象</p>
</li>
</ul>
</li>
<li><p>投影查询</p>
<ul>
<li><p>查询结果仅包含实体的部分属性，通过 SELECT 关键字实现</p>
</li>
<li><p>Query 的 <code>list()</code> 方法返回的集合中包含的是数组类型的元素，每个对象数组代表查询结果的一条记录</p>
</li>
<li><p>可以在持久化类中定义一个对象的构造器来包装投影查询返回的记录，使程序能完全运用面向对象的语义来访问查询结果集</p>
</li>
<li><p>可以通过 DISTINCT 关键字来保证查询结果不会返回重复元素</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 返回一个包含 Object[] 的 List */</span></span><br><span class="line"><span class="keyword">SELECT</span> e.email, e.salary, e.dept <span class="keyword">FROM</span> Employee e <span class="keyword">WHERE</span> e.dept = :dept;</span><br><span class="line"><span class="comment">/* 返回一个包含 Employee 对象的 List (前提是 Employee 类中要有这个构造器) */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">new</span> Employee(e.email, e.salary, e.dept) <span class="keyword">FROM</span> Employee e <span class="keyword">WHERE</span> e.dept = :dept;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>报表查询</p>
<ul>
<li>报表查询用于对数据分组和统计，与 SQL 一样，HQL 利用 GROUP BY 关键字对数据分组，用 HAVING 关键字对数据设定约束条件</li>
<li>在 HQL 查询语句中可以调用以下聚集函数：<ul>
<li><code>count()</code></li>
<li><code>min()</code></li>
<li><code>max()</code></li>
<li><code>sum()</code></li>
<li><code>avg()</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h5 id="HQL-的迫切左外连接"><a href="#HQL-的迫切左外连接" class="headerlink" title="HQL 的迫切左外连接"></a>HQL 的迫切左外连接</h5><ol>
<li><p>迫切左外连接</p>
<ul>
<li><p>LEFT JOIN FETCH 关键字表示迫切左外连接检索策略</p>
</li>
<li><p><code>list()</code> 方法返回的集合中存放实体对象的引用，每个 Department 对象关联的 Employee 集合都被初始化，存放所有关联的 Employee 的实体对象</p>
</li>
<li><p>查询结果中可能会包含重复元素，可以通过一个 HashSet 来过滤重复元素（或者 DISTINCT 关键字）</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* DISTINCT 关键字位置 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> d <span class="keyword">FROM</span> Department d <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="keyword">FETCH</span> d.emps;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>左外连接</p>
<ul>
<li>LEFT JOIN 关键字表示左外连接查询</li>
<li><code>list()</code> 方法返回的集合中存放的是对象数组类型</li>
<li>根据配置文件来决定 Employee 集合的检索策略</li>
<li>如果希望 <code>list()</code> 方法返回的集合仅包含 Department 对象，可以在 HQL 查询语句中使用 SELECT 关键字</li>
</ul>
</li>
</ol>
<hr>
<h5 id="HQL-的迫切内连接"><a href="#HQL-的迫切内连接" class="headerlink" title="HQL 的迫切内连接"></a>HQL 的迫切内连接</h5><ol>
<li>迫切内连接<ul>
<li>INNER JOIN FETCH 关键字表示迫切内连接，也可以省略 INNER 关键字</li>
<li><code>list()</code> 方法返回的集合中存放 Department 对象的引用，每个 Department 对象的 Employee 集合都被初始化，存放所有关联的 Employee 对象</li>
</ul>
</li>
<li>内连接<ul>
<li>INNER JOIN 关键字表示内连接，也可以省略 INNER 关键字</li>
<li><code>list()</code> 方法返回的集合中存放的每个元素对应查询结果的一条记录，每个元素都是对象数组类型</li>
<li>如果希望 <code>list()</code> 方法返回的集合仅包含 Department 对象，可以在 HQL 查询语句中使用 SELECT 关键字</li>
</ul>
</li>
<li>与左外连接的区别：不返回左表不符合条件的记录</li>
</ol>
<hr>
<h5 id="关联级别运行时的检索策略"><a href="#关联级别运行时的检索策略" class="headerlink" title="关联级别运行时的检索策略"></a>关联级别运行时的检索策略</h5><ol>
<li>如果在 HQL 中没有显式指定检索策略，将使用映射文件配置的检索策略</li>
<li>HQL 会忽略映射文件中设置的迫切左外连接策略，如果希望 HQL 采用迫切左外连接策略，就必须在 HQL 查询语句中显式的指定</li>
<li>若在 HQL 代码中显式指定了检索策略，就会覆盖映射文件中配置的检索策略</li>
</ol>
<hr>
<h5 id="QBC-检索"><a href="#QBC-检索" class="headerlink" title="QBC 检索"></a>QBC 检索</h5><ol>
<li><p>QBC 查询就是通过使用 Hibernate 提供的 Query By Criteria API 来查询对象，这种 API 封装了 SQL 语句的动态拼装，对查询提供了更加面向对象的功能接口</p>
</li>
<li><p>本地 SQL 查询来完善 HQL 不能涵盖所有的查询特性</p>
</li>
<li><p>使用步骤</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 Session 创建一个 Criteria 对象</span></span><br><span class="line">Criteria criteria = session.createCriteria(Employee.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加查询条件</span></span><br><span class="line"><span class="comment">// 在 QBC 中查询条件使用 Criterion 来表示</span></span><br><span class="line"><span class="comment">// Criterion 可以通过 Restrictions 的静态方法获取</span></span><br><span class="line">criteria.add(Restrictions.eq(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;SKUMAR&quot;</span>));</span><br><span class="line">criteria.add(Restrictions.gt(<span class="string">&quot;salary&quot;</span>, <span class="number">5000F</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行查询</span></span><br><span class="line">Employee employee = (Employee) criteria.uniqueResult();</span><br></pre></td></tr></table></figure>
</li>
<li><p>SQL 中的 AND 和 OR</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AND 条件使用 Conjunction 类表示, Conjunction 本身又是一个 Criterion 对象</span></span><br><span class="line"><span class="comment">// 而且 Conjunction 中还可以添加 Criterion</span></span><br><span class="line">Conjunction conjunction = Restrictions.conjunction();</span><br><span class="line">conjunction.add(Restrictions.like(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;a&quot;</span>, MatchMode.ANYWHERE));</span><br><span class="line"></span><br><span class="line"><span class="comment">// OR 条件使用 Disjunction 类表示, 与 Conjunction 类似</span></span><br><span class="line">Disjunction disjunction = Restrictions.disjunction();</span><br><span class="line">disjunction.add(Restrictions.ge(<span class="string">&quot;salary&quot;</span>, <span class="number">6000F</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计查询</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 统计查询使用 Projection 类来表示</span></span><br><span class="line">criteria.setProjection(Projections.max(<span class="string">&quot;salary&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>排序查询</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 排序使用 Criteria 的 addOrder()方法</span></span><br><span class="line">criteria.addOrder(Order.asc(<span class="string">&quot;salary&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>分页查询</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分页查询与 HQL 相同, 都是使用 setFirstResult() 方法与 setMaxResults() 方法</span></span><br><span class="line"><span class="keyword">int</span> pageSize = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> pageNum = <span class="number">4</span>;</span><br><span class="line">criteria.setFirstResult((pageNum - <span class="number">1</span>) * pageSize)</span><br><span class="line">    	.setMaxResults(pageSize)</span><br><span class="line">    	.list();</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h5 id="本地-SQL-检索"><a href="#本地-SQL-检索" class="headerlink" title="本地 SQL 检索"></a>本地 SQL 检索</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 与 HQL 类似, 都是使用 Session 来获取一个 Query 对象来进行</span></span><br><span class="line">String sql = <span class="string">&quot;INSERT INTO department VALUES(?, ?)&quot;</span>;</span><br><span class="line">Query query = session.createSQLQuery(sql);</span><br><span class="line">query.setInteger(<span class="number">0</span>, <span class="number">80</span>)</span><br><span class="line">     .setString(<span class="number">1</span>, <span class="string">&quot;name&quot;</span>)</span><br><span class="line">     .executeUpdate();</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="Hibernate-缓存"><a href="#Hibernate-缓存" class="headerlink" title="Hibernate 缓存"></a>Hibernate 缓存</h5><ol>
<li><p>Hibernate 提供了两个级别的缓存</p>
<ul>
<li>第一级别的缓存是 Session 级别的缓存，他是属于事务范围的缓存，这一级别的缓存是由 Hibernate 管理的</li>
<li>第二级别的缓存是 SessionFactory 级别的缓存，他是属于进程范围的缓存</li>
</ul>
</li>
<li><p>SessionFactory 的缓存可以分为两类</p>
<ul>
<li>内置缓存：Hibernate 自带的，不可卸载的，通常在 Hibernate 的初始化阶段，Hibernate 会把映射元数据和预定义的 SQL 语句放到 SessionFactory 的缓存中，映射元数据是映射文件中数据（<code>*.hbm.xml</code> 中数据）的复制，该内置缓存是只读的</li>
<li>外置缓存（二级缓存）：一个可配置的缓存插件，在默认情况下，SessionFactory 不会启用这个缓存插件，外置缓存中的数据是数据库数据的复制，外置缓存的物理介质可以是内存也可以是硬盘</li>
</ul>
</li>
<li><p>适合放入二级缓存中的数据：很少被修改的，不是很重要的数据，允许出现偶尔的并发问题的数据</p>
</li>
<li><p>不适合放入二级缓存中的数据：经常被修改的，财务数据（不允许出现并发问题），与其他应用程序共享的数据</p>
</li>
<li><p>二级缓存的并发访问策略</p>
<ul>
<li>两个并发的事务同时访问持久层的缓存的相同数据时，也有可能出现各类并发问题</li>
<li>二级缓存可以设定如下四种并发访问策略，每一种访问策略对应一种事务隔离级别：<ul>
<li>非严格读写（ Nonstrict-read-write ）：不保证缓存与数据库数据的一致性，提供 Read Uncommited 事务隔离级别，对于极少被修改，而且允许脏读的数据，可以采用本策略</li>
<li>读写型（ Read-write ）：提供 Read Commited 数据隔离级别，对于经常读但是很少被修改的数据，可以采用这种策略（因为可以防止脏读）</li>
<li>事务型（ Transactional ）：仅在受管理环境下使用，提供 Repeatable Read 事务隔离级别，对于经常读但很少被修改的数据，可以采用这种策略（因为可以防止脏读和重复读）</li>
<li>只读型（ Read-Only ）：提供 Serializable 数据隔离级别，对于从来不会被修改的数据，可以采用这种策略</li>
</ul>
</li>
</ul>
</li>
<li><p>管理 Hibernate 的二级缓存</p>
<ul>
<li><p>Hibernate 的二级缓存是进程或集群范围内的缓存</p>
</li>
<li><p>二级缓存是可配置的插件，Hibernate 允许使用以下缓存插件：</p>
<ul>
<li><p>EHCache：可作为进程范围内的缓存，存放数据的物理介质可以使用内存或者硬盘，对 Hibernate 的查询缓存提供了支持</p>
</li>
<li><p>OpenSymphony OSCache：可作为进程范围内的缓存，存放数据的物理介质可以使用内存或硬盘，提供了丰富的缓存数据过期策略，对 Hibernate 的查询缓存提供了支持</p>
</li>
<li><p>SwarmCache：可作为集群范围内的缓存，但不支持 Hibernate 的查询缓存</p>
</li>
<li><p>JBossCache：可作为集群范围内的缓存，支持 Hibernate 的查询缓存</p>
</li>
<li><p>四种缓存插件支持的并发访问策略</p>
<table>
<thead>
<tr>
<th></th>
<th>Read-Only</th>
<th>Nonstrict-read-write</th>
<th>Read-Write</th>
<th>Transactional</th>
</tr>
</thead>
<tbody><tr>
<td>EHCache</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✗</td>
</tr>
<tr>
<td>OpenSymphony OSCache</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✗</td>
</tr>
<tr>
<td>SwarmCache</td>
<td>✓</td>
<td>✓</td>
<td>✗</td>
<td>✗</td>
</tr>
<tr>
<td>JBossCache</td>
<td>✓</td>
<td>✗</td>
<td>✗</td>
<td>✓</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
</li>
<li><p>配置进程范围内的二级缓存</p>
<ul>
<li><p>步骤（以 EHCache 为例）</p>
<ul>
<li><p>选择合适的缓存插件：EHCache（ jar 包和配置文件），并编辑配置文件（ jar 包路径：<code>hibernate\lib\optional\ehcache\*.jar</code>，配置文件路径：<code>hibernate\project\etc\ehcache.xml</code>）</p>
</li>
<li><p>在 Hibernate 的配置文件中启用二级缓存并指定和 EHCache 对应的缓存适配器</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 启用二级缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cache.use_second_level_cache&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 指定对应的缓存适配器, 如果这个值不对就需要去 jar 包里找正确的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.cache.region.factory_class&quot;</span>&gt;</span>org.hibernate.cache.ehcache.EhCacheRegionFactory<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>选择需要使用二级缓存的持久类，设置他的二级缓存并发访问策略</p>
<ul>
<li><p>&lt;class&gt; 元素的 cache 子元素表示 Hibernate 会缓存对象的简单属性，但不会缓存集合属性，若希望缓存集合属性中的元素，必须在 &lt;set&gt; 元素中加入 &lt;cache&gt; 子元素</p>
</li>
<li><p>在 Hibernate 配置文件中通过 &lt;class-cache /&gt; 节点配置使用缓存</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class-cache</span> <span class="attr">usage</span>=<span class="string">&quot;read-write&quot;</span> <span class="attr">class</span>=<span class="string">&quot;完整类路径&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>设置持久化类中集合的二级缓存（注意要同时将集合中元素的类也使用二级缓存）</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">collection-cache</span> <span class="attr">usage</span>=<span class="string">&quot;read-write&quot;</span> <span class="attr">class</span>=<span class="string">&quot;完整类路径.集合属性名&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>ehcache.xml 文件解释</p>
<ul>
<li>&lt;diskStore&gt;：指定一个目录（当 EHCache 把数据写到硬盘上时，就写到这个目录下）</li>
<li>&lt;defaultCache&gt;：设置缓存的默认数据过期策略</li>
<li>&lt;cache&gt;：设定具体的命名缓存的数据过期策略，每个命名缓存代表一个缓存区域</li>
<li>缓存区域（ region ）：一个具体名称的缓存块，可以给每一个缓存块设置不同的缓存策略，如果没有设置任何的缓存区域，则所有被缓存的对象，都将使用默认的缓存策略</li>
<li>Hibernate 在不同的缓存区域保存不同的类/集合<ul>
<li>对于类而言，区域的名称是类名，如 com.beiran.Customer</li>
<li>对于集合而言，区域的名称是类名加属性名，如 com.beiran.Customer.orders</li>
</ul>
</li>
</ul>
</li>
<li><p>查询缓存</p>
<ul>
<li><p>默认情况下设置的二级缓存对 HQL 和 QBC 查询是无效的</p>
</li>
<li><p>对于经常使用的查询语句，如果启用了查询缓存，当第一次执行查询语句时，Hibernate 会把查询结果存放在查询缓存中，以后再次执行该查询语句时，只需从缓存中获得查询结果，从而提高查询性能</p>
</li>
<li><p>查询缓存适用于以下场合：</p>
<ul>
<li>应用程序运行时经常使用查询语句</li>
<li>很少对与查询语句检索到的数据进行插入、删除和更新操作</li>
</ul>
</li>
<li><p>启用查询缓存的步骤：</p>
<ul>
<li><p>配置二级缓存（因为查询缓存依赖于二级缓存）</p>
</li>
<li><p>在 Hibernate 配置文件中启用查询缓存</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置文件中启用查询缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cache.use_query_cache&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于希望启用查询缓存的查询语句调用 Query 的 <code>setCacheable()</code> 方法</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>时间戳缓存区域</p>
<ul>
<li>时间戳缓存区域存放了对于查询结果相关的表进行插入、更新或者删除操作的时间戳，Hibernate 通过时间戳缓存区域来判断缓存的查询结果是否过期<ul>
<li>T1 时刻执行查询操作，把查询结果存放在 QueryCache 区域，记录该区域时间戳为 T1</li>
<li>T2 时刻对查询结果相关的表进行更新，Hibernate 把 T2 时刻存放在 UpdateTimestampCache 区域</li>
<li>T3 时刻执行查询结果前，先比较 QueryCache 区域的时间戳和 UpdateTimestampCache 区域的时间戳，若 T2 &gt; T1，那么就丢弃原先存放在 QueryCache 区域的查询结果，重新到数据库中查询数据，再把结果存放到 QueryCache 区域；若 T2 &lt; T1，则直接从 QueryCache 中获取查询结果</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h5 id="Query-接口的-iterate-方法"><a href="#Query-接口的-iterate-方法" class="headerlink" title="Query 接口的 iterate() 方法"></a>Query 接口的 iterate() 方法</h5><ol>
<li>同 <code>list()</code> 方法一样也能执行查询操作</li>
<li><code>list()</code> 方法执行的 SQL 语句包含实体类对应的数据表的所有字段</li>
<li><code>iterate()</code> 方法执行的 SQL 语句仅包含实体类对应的数据表的 ID 字段</li>
<li>当遍历访问结果集时，该方法先到 Session 缓存及二级缓存中查看是否存在特定的 OID 的对象，如果存在，就直接返回该对象，如果不存在就通过相应的 SELECT 语句去数据库中加载特定的实体对象</li>
<li>大多数情况下应该使用 <code>list()</code> 方法来执行查询，<code>iterate()</code> 方法仅适用于以下场合可以稍微提升一点查询的性能：<ul>
<li>要查询的数据表中包含大量字段</li>
<li>启用了二级缓存，并且二级缓存中可能已经包含了待查询的对象</li>
</ul>
</li>
</ol>
<hr>
<h5 id="管理-Session"><a href="#管理-Session" class="headerlink" title="管理 Session"></a>管理 Session</h5><ol>
<li>Hibernate 自身提供了三种管理 Session 对象的方法<ul>
<li>Session 对象的生命周期与本地线程绑定</li>
<li>Session 对象的生命周期与 JTA 事务绑定</li>
<li>Hibernate 委托程序管理 Session 对象的生命周期</li>
</ul>
</li>
<li>在 Hibernate 的配置文件中，<code>hibernate.current_seesion_context_class</code> 属性用于指定 Session 管理方式，可选值有：<ul>
<li>thread：Session 对象的生命周期与本地线程绑定</li>
<li>jta：Session 对象的生命周期与 JTA 事务绑定</li>
<li>managed：Hibernate 委托程序来管理 Session 对象的生命周期</li>
</ul>
</li>
<li>Hibernate 按以下规则将 Session 与本地线程绑定<ul>
<li>当一个线程（ threadA ）第一次调用 SessionFactory 对象的 <code>getCurrentSession()</code> 方法时，该方法会创建一个新的 Session 对象（ SessionA ），把该对象与 threadA 绑定，然后将 SessionA 返回</li>
<li>当 threadA 再次调用 SessionFactory 对象的 <code>getCurrentSession()</code> 方法时，该方法会将 SessionA 对象返回</li>
<li>当 threadA 提交 SessionA 对象关联的事务时，Hibernate 会自动 flush SessionA 对象的缓存，然后提交事务，关闭 SessionA 对象，当 threadA 撤销 SessionA 对象关联的事务时，也会自动关闭 SessionA 对象</li>
<li>当 threadA 再次调用 SessionFactory 对象的 <code>getCurrentSession()</code> 方法时，该方法又会创建一个新的 Session 对象（ SessionB ），并把该对象与 threadA 绑定，然后将 SessionB 返回</li>
</ul>
</li>
</ol>
<hr>
<h5 id="批量处理数据"><a href="#批量处理数据" class="headerlink" title="批量处理数据"></a>批量处理数据</h5><ol>
<li><p>通常指在一个事务中处理大量的插入、更新、删除操作</p>
</li>
<li><p>通过 Session</p>
<ul>
<li><p>Session 的 <code>save()</code> 以及 <code>update()</code> 方法都会把处理的对象存放在自己的缓存中，如果通过一个 Session 对象来处理大量持久化对象，应该及时从缓存中清空已处理完毕并且不会再访问的对象，具体做法通常是再处理完一个对象或小批量对象后，立即调用 <code>flush()</code> 方法刷新缓存，然后再调用 <code>clear()</code> 方法清空缓存</p>
</li>
<li><p>有以下约束：</p>
<ul>
<li>需要在 Hibernate 配置文件中设置 JDBC 单次批处理的数目，应保证每次向数据库发送批量的 SQL 语句数目与 batch_size 属性一致</li>
<li>若对象采用 ”identity“ 标识符生成器，则 Hibernate 无法在 JDBC 层进行批量插入操作</li>
<li>进行批量操作时，建议关闭二级缓存</li>
</ul>
</li>
<li><p>使用可滚动的结果集 <code>org.hibernate.ScrollableResults</code>，该对象实际上并不包含任何对象，只包含用于在线定位记录的游标，只有当程序遍历访问 ScrollableResults 对象的特定元素时才会到数据库中加载相应的对象</p>
</li>
<li><p><code>org.hibernate.ScrollableResults</code> 对象由 Query 的 <code>scroll()</code> 方法返回</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ScrollableResults sr = session.createQuery(<span class="string">&quot;FROM Department&quot;</span>).scroll();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>通过 HQL</p>
<ul>
<li>HQL 只支持 INSERT INTO … SELECT （子查询）形式的插入语句，但不支持 INSERT INTO … VALUES 形式的插入语句，所以不能用 HQL 进行批量插入操作</li>
</ul>
</li>
<li><p>通过 StatelessSession（无状态 Session）</p>
<ul>
<li>StatelessSession 与 Session 的区别：<ul>
<li>StatelessSession 没有缓存，通过 StatelessSession 来加载、保存或更新后的对象处于游离态</li>
<li>StatelessSession 不会与 Hibernate 的二级缓存交互</li>
<li>当调用 StatelessSession 的 <code>save()</code> 、<code>update()</code>、<code>delete()</code> 方法时，这些方法会立即执行相应的 SQL 语句，而不会仅计划执行一条 SQL 语句</li>
<li>StatelessSession 不会进行脏数据检查，因此修改了对象的属性后，还需要调用 StatelessSession 的 <code>update()</code> 方法来更新数据库中数据</li>
<li>StatelessSession 不会对关联的对象进行任何级联操作</li>
<li>通过同一个 StatelessSession 对象两次加载的 OID 相同的对象，得到的两个对象内存地址不同</li>
<li>StatelessSession 所做的操作可以被 Interceptor 拦截到，但是会被 Hibernate 的事件处理系统忽略掉</li>
</ul>
</li>
</ul>
</li>
<li><p>通过 JDBC API</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>复习</tag>
      </tags>
  </entry>
</search>
